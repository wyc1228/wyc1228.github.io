<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AngularJs学习总结-基本特性</title>
    <url>/2021/08/16/AngularJs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="AngularJs学习总结-基本特性"><a href="#AngularJs学习总结-基本特性" class="headerlink" title="AngularJs学习总结-基本特性"></a>AngularJs学习总结-基本特性</h2><h3 id="1、AngularJs是什么"><a href="#1、AngularJs是什么" class="headerlink" title="1、AngularJs是什么"></a>1、AngularJs是什么</h3><p>Google开源的 前端JS 结构化 框架，简单来说，即javascript的一个框架，通过script标签添加到网页中。即我们使用angularjs时，需要引入下面的代码。</p>
<pre><code>&lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>通常建议把脚本放在<body>元素的底部，作用是：提高网页加载速度。因为html加载不受制于脚本加载。</body></p>
<h3 id="2、AngularJs的作用"><a href="#2、AngularJs的作用" class="headerlink" title="2、AngularJs的作用"></a>2、AngularJs的作用</h3><p>AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p>
<ul>
<li>AngularJS 把应用程序数据绑定到 HTML 元素。(双向数据绑定)</li>
<li>AngularJS 可以克隆和重复 HTML 元素。</li>
<li>AngularJS 可以隐藏和显示 HTML 元素。</li>
<li>AngularJS 可以在 HTML 元素”背后”添加代码。</li>
<li>AngularJS 支持输入验证。</li>
</ul>
<p>其优点总结有：</p>
<ul>
<li>双向数据绑定</li>
<li>声明式依赖注入</li>
<li>解耦应用逻辑, 数据模型和视图</li>
<li>完善的页面指令</li>
<li>定制表单验证</li>
<li>Ajax封装</li>
</ul>
<h3 id="3、AngularJs表达式"><a href="#3、AngularJs表达式" class="headerlink" title="3、AngularJs表达式"></a>3、AngularJs表达式</h3><p>AngularJS 表达式写在双大括号内：****。</p>
<p>AngularJS 表达式把数据绑定到 HTML，这与 <strong>ng-bind</strong> 指令有异曲同工之妙。</p>
<p>AngularJS 将在表达式书写的位置”输出”数据。</p>
<p><strong>AngularJS 表达式</strong> 很像 <strong>JavaScript 表达式</strong>：它们可以包含文字、运算符和变量。</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;!-- 标记angularjs处理整个html页并引导应用 --&gt;
&lt;html ng-app&gt;  
     &lt;head&gt;
         &lt;meta charset=&quot;utf-8&quot;&gt;
         &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
        &lt;p&gt;name:&#123;&#123;"ting"+"feng"&#125;&#125;&lt;/p&gt;
        &lt;p&gt;number:&#123;&#123;5+5&#125;&#125;&lt;/p&gt;
        &lt;div ng-init=&quot;person=&#123;name:&#39;tingfeng&#39;,age:&#39;13&#39;&#125;&quot;&gt;
           &lt;p&gt;name:&#123;&#123;person.name&#125;&#125; age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="4、AngularJs的应用"><a href="#4、AngularJs的应用" class="headerlink" title="4、AngularJs的应用"></a>4、AngularJs的应用</h3><p>主要通过ng-directive扩展html，angularjs指令是以ng作为前缀的html属性，包含有四大特性：mvc，模块化，指令系统（directive），databinding</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;!-- 标记angularjs处理整个html页并引导应用 --&gt;
&lt;html ng-app&gt;  
     &lt;head&gt;
         &lt;meta charset=&quot;utf-8&quot;&gt;
         &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
        &lt;div ng-init=&quot;name=&#39;tingfeng&#39;&quot;&gt;
             &lt;p&gt;name is:&lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;/div&gt;
     &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>ng-init:该指令初始化angularjs应用程序变量。比如下面的列子：</p>
<p>ng-app:该指令表示定义一个angularjs应用程序。通常放在html后面，也可以在局部使用ng-app指令，比如<div ng-app>则angularjs脚本仅在该div中运行,即表明从此处开始，所有内容均为angularjs进行管理。</div></p>
<p>ng-model:该指令是指把元素值（比如输入框的值）绑定到应用程序中。</p>
<p>ng-bind：该指令是把应用程序数据绑定到html视图中。使用相应的指令，即可利用angularjs操作html页面。具体怎么使用，我们来看看代码。</p>
<h3 id="5、关于-scope解释"><a href="#5、关于-scope解释" class="headerlink" title="5、关于$scope解释"></a>5、关于$scope解释</h3><p>$scope是什么？有什么作用？如何使用它？</p>
<p>简单来说，scope是一个pojo（plainoldjavascriptobject）,类似于一个对象，有属性和方法，scope提供了watch()和apply()工具方法。angularjs的mvc全部借助于$scope进行的。</p>
<p> 特性：</p>
<ol>
<li>是表达式的执行环境（或者作用域）</li>
<li>scope是一个树型结构，与dom标签平行，其上含有一个scope是一个树型结构，与dom标签平行，其上含有一个rootscope处于最顶层。</li>
<li>scope会继承父scope会继承父rootscope的属性和方法。</li>
<li>$scope可以传播事件，类似于dom，可以向上传播也可以向下。</li>
<li>$scope不仅是mvc的基础，也是后面实现双向绑定的基础。</li>
</ol>
<h3 id="6、AngularJs的组成部分"><a href="#6、AngularJs的组成部分" class="headerlink" title="6、AngularJs的组成部分"></a>6、AngularJs的组成部分</h3><p> 模板：</p>
<ul>
<li>即编写的html和css的文件，展现应用的视图。angularjs可以在html中构建自己的html标记！</li>
</ul>
<p>控制器:</p>
<ul>
<li>与ajax不同，不需要另外编写侦听器或dom控制器，因为它已经内置到angularjs中。 好处：便于编写，测试，维护和理解。</li>
</ul>
<p>模型数据：</p>
<ul>
<li>模型是从angularjs做用域对象的属性引申的。模型的数据可能是js对象，数组或基本类型，但都属于angularjs作用域对象。</li>
</ul>
<h3 id="7、angularjs中的作用域"><a href="#7、angularjs中的作用域" class="headerlink" title="7、angularjs中的作用域"></a>7、angularjs中的作用域</h3><p>即一个作用域可以视作模板，模型和控制器协同工作的粘接器，angularjs使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但他们两者确实是同步的！任何对于模型的更改都会即时反映到视图上，任何视图的更改都会被立刻体现在模型中。</p>
<p>视图：在angularjs中，一个视图是模型通过html模板渲染之后的映射。即不论模型什么时候发生变化，angularjs会实时更新结合点，随之更新视图。</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html ng-app=&quot;HelloAngular&quot;&gt; 
     &lt;head&gt;
         &lt;meta charset=&quot;utf-8&quot;&gt;
         &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;
         &lt;script&gt;
            //模块化
           var myModule = angular.module(&quot;HelloAngular&quot;, []); －－控制模板HelloAngular
           myModule.controller(&quot;helloAngular&quot;, [&#39;$scope&#39;,
            function HelloAngular($scope) &#123;
                $scope.value = &#123;
                    name: &#39;jiangting&#39;
                &#125;;
            &#125;
        ]);       
       &lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
     &lt;!-- mvc看angular--&gt;
        &lt;div ng-controller=&quot;helloAngular&quot;&gt;  －－控制器为helloAngular
             &lt;p&gt;&#123;&#123;value.name&#125;&#125;,hello!&lt;/p&gt;
        &lt;/div&gt;
        &lt;!-- angular 模块化 --&gt;  

     &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="8、控制器"><a href="#8、控制器" class="headerlink" title="8、控制器"></a>8、控制器</h3><p>我们来看看controller的应用，即控制器，即控制器通过操作数据，将其进行绑定，展现在html页面上。</p>
<p> AngularJS <strong>模块（Module）</strong> 定义了 AngularJS 应用。</p>
<p> AngularJS <strong>控制器（Controller）</strong> 用于控制 AngularJS 应用。</p>
<p> <strong>ng-app</strong>指令定义了应用, <strong>ng-controller</strong> 定义了控制器。我们用上面的列子来看：</p>
<p>AngularJS模块定义应用：</p>
<pre><code class="javascript"> var myModule = angular.module(&quot;HelloAngular&quot;, []); －－控制模板HelloAngular
</code></pre>
<p>angularjs控制器控制应用：</p>
<pre><code class="js">myModule.controller(&quot;helloAngular&quot;, [&#39;$scope&#39;,
            function HelloAngular($scope) &#123;
                $scope.value = &#123;
                    name: &#39;jiangting&#39;
                &#125;;
            &#125;
        ]);    
</code></pre>
<p>关于controller特性：</p>
<ol>
<li>不要试图去复用controller，一个控制器一般只负责一个小块视图</li>
<li>不要直接在controller中操作dom，这不是其职责</li>
<li>不要在controller里面做数据过滤的操作,ng有filter服务</li>
<li>不要在controller里面做数据格式化，ng有很好用的表单控件</li>
<li>controller是不会互相调用，控制器之间的交互会通过事件进行，通过filter服务</li>
<li>不要在controller里面做数据格式化，ng有很好用的表单控件</li>
<li>controller是不会互相调用，控制器之间的交互会通过事件进行，通过scope进行调用。</li>
</ol>
<p>如何自定义指令系统，代码如下：</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html ng-app&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;utf-8&quot;&gt;
         &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;
         &lt;script&gt;
            //指令系统
        var myModule = angular.module(&quot;MyModule&quot;, []);
            myModule.directive(&quot;hello&quot;, function() &#123;
            return &#123;
                restrict: &#39;E&#39;,
                template: &#39;&lt;div&gt;Hi everyone!&lt;/div&gt;&#39;, --这里我们插入一段html标签
                replace: true
            &#125;
        &#125;);
       &lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;   
        &lt;hello&gt;&lt;/hello&gt;
     &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p> directive中，后面返回有三个参数，其中template中指所插入的html标签。</p>
<h3 id="9、常用指令"><a href="#9、常用指令" class="headerlink" title="9、常用指令"></a>9、常用指令</h3><ul>
<li><p>ng-app: 指定模块名，angular管理的区域</p>
</li>
<li><p>ng-model： 双向绑定，输入相关标签</p>
</li>
<li><p>ng-init： 初始化数据</p>
</li>
<li><p>ng-click： 调用作用域对象的方法（点击时）可以传$event</p>
</li>
<li><p>ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）</p>
</li>
<li><p>ng-bind： 解决使用{ { } }显示数据闪屏（在很短时间内显示 { { } }）</p>
</li>
<li><p>ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域</p>
<ul>
<li>$index, $first, $last, $middle, $odd, $even</li>
</ul>
</li>
<li><p>ng-show: 布尔类型， 如果为true才显示</p>
</li>
<li><p>ng-hide: 布尔类型， 如果为true就隐藏</p>
</li>
<li><p>ng-class: 动态引用定义的样式  {aClass:true, bClass:false}</p>
</li>
<li><p>ng-style: 动态引用通过js指定的样式对象   {color:’red’, background:’blue’}</p>
</li>
<li><p>ng-mouseenter: 鼠标移入监听, 值为函数调用, 可以传$event</p>
</li>
<li><p>ng-mouseleave: 鼠标移出监听, 值为函数调用, 可以传$event</p>
</li>
</ul>
<h3 id="10-AngularJs总体思维导图"><a href="#10-AngularJs总体思维导图" class="headerlink" title="10 AngularJs总体思维导图"></a>10 AngularJs总体思维导图</h3><p><img src="/2021/08/16/AngularJs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/1.png" alt="1"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular学习总结-路由</title>
    <url>/2021/09/25/AngularJs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="Angular学习总结-路由"><a href="#Angular学习总结-路由" class="headerlink" title="Angular学习总结-路由"></a>Angular学习总结-路由</h2><p> AngularJs中的路由，应用比较广泛，主要是允许我们通过不同的url访问不同的内容，可实现多视图的单页web应用。下面看看具体怎么使用。</p>
<h3 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h3><p>   通常我们的URL形式为<a href="https://wyc1228.github.io/page/%EF%BC%8C%E4%BD%86%E5%9C%A8%E5%8D%95%E9%A1%B5web%E5%BA%94%E7%94%A8%E4%B8%ADangularjs%E9%80%9A%E8%BF%87#+%E6%A0%87%E8%AE%B0%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%AF%94%E5%A6%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%B0%86%E6%98%AF%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E5%88%97%E5%AD%90%E3%80%82">https://wyc1228.github.io/page/，但在单页web应用中angularjs通过#+标记实现，比如下面的页面，将是下文中的路由列子。</a></p>
<pre><code>http://192.168.1.109:8000/angular-program/src/main.html#/pagetable/page1
http://192.168.1.109:8000/angular-program/src/main.html#/pagetable/page2
http://192.168.1.109:8000/angular-program/src/main.html#/pagetable/page3
</code></pre>
<p>当我们点击以上任一一个链接时，向服务器请求的地址都是<a href="http://192.168.1.109:8000/angular-program/src/main.html">http://192.168.1.109:8000/angular-program/src/main.html</a> ，而＃号之后的内容在向服务器端请求时会被浏览器忽略掉，所以我们在客户端实现＃号后面的功能实现即可。简单来说，路由通过＃＋标记帮助我们区分不同逻辑页面，并将其绑定到对应的控制器上。</p>
<p><img src="/2021/09/25/AngularJs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E8%B7%AF%E7%94%B1/905548-20160806142738497-614875041.png" alt="img"></p>
<p>每个页面均有一个控制器控制，通过路由，从而将不同的页面展示出来。</p>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>新建main.html</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html ng-app=&quot;myapp&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;utf-8&quot;&gt;
         &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;
         &lt;script src=&quot;angular-ui-router.min.js&quot;&gt;&lt;/script&gt;         
         &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt; 
        &lt;!-- 引入angularjs框架和ui-router框架，引入app.js框架 --&gt;
        &lt;h1&gt;AngularJS 路由跳转&lt;/h1&gt; 
        &lt;div ui-view=&quot;&quot;&gt;&lt;/div&gt;     --展示page.html的页面内容
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>新建pagetable.html页面</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;div&gt;
     &lt;div&gt;
         &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.page1&quot;&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/span&gt;
         &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.page2&quot;&gt;&lt;a href=&quot;&quot;&gt;关于我&lt;/a&gt;&lt;/span&gt;
         &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.page3&quot;&gt;&lt;a href=&quot;&quot;&gt;留言板&lt;/a&gt;&lt;/span&gt;
     &lt;/div&gt;
     &lt;div&gt;
          &lt;div ui-view=&quot;&quot;&gt;&lt;/div&gt;  －－展示page1,page2,page3页面的内容
     &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>新建page1.html、page2.html、page3.html页面</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;div&gt;
    &lt;div&gt;
       &lt;h1&gt;page1页面&lt;/h1&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>app.js内容</p>
<pre><code class="js">var app=angular.module(&quot;myapp&quot;,[&#39;ui.router&#39;]);//声明angualrjs模块，并把ui-router传人angularjs模块app.config(function ($stateProvider, $urlRouterProvider) &#123; //声明把$stateprovider和$urlrouterprovider路由引擎作为函数参数传人,为应用程序配置路由
     $urlRouterProvider.otherwise(&quot;/pagetable&quot;); 
     $stateProvider    
        .state(&quot;pagetable&quot;, &#123;
            url: &quot;/pagetable&quot;,
            templateUrl: &quot;pagetable.html&quot;  //第一个显示出来的页面
        &#125;)
        .state(&quot;pagetable.page1&quot;, &#123;
            url:&quot;/page1&quot;,
            templateUrl: &quot;page1.html&quot; //
        &#125;)
        .state(&quot;pagetable.page2&quot;, &#123;
            url:&quot;/page2&quot;,
            templateUrl: &quot;page2.html&quot;
        &#125;)
        .state(&quot;pagetable.page3&quot;, &#123;
            url:&quot;/page3&quot;,
            templateUrl: &quot;page3.html&quot;
        &#125;);
&#125;);
</code></pre>
<p>配置路由：angularjs使用UI－rooter将其传人angularjs模块。我们将项目运行起来，如果是本地直接打开的话，在非safari下面运行，会出现跨域的问题，我们来看下。即只有在safari下才能正常打开，以本地的file://开头的在其它浏览器下是不能打开文件的。主要是js同源策略的影响。</p>
<p><img src="/2021/09/25/AngularJs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E8%B7%AF%E7%94%B1/image-20211017135803680.png" alt="image-20211017135803680"></p>
<p>点击不同的链接，下面将会显示不同的页面。那么简单的路由跳转就完成啦。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Annotation(注解)</title>
    <url>/2020/09/09/Annotation(%E6%B3%A8%E8%A7%A3)/</url>
    <content><![CDATA[<h2 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation(注解)"></a>Annotation(注解)</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>注解是jdk 5.0 新增的功能，Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</p>
<p>通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。</p>
<p>在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
<p><code>框架 = 注解 + 反射机制 + 设计模式</code></p>
<h3 id="1-2-声明注解"><a href="#1-2-声明注解" class="headerlink" title="1.2 声明注解"></a>1.2 声明注解</h3><p>注解是一种代码级别的说明.它与<code>类</code>，<code>接口</code>，<code>枚举</code>在同一个层次,它可以声明在<code>包</code>，<code>类</code>，<code>字段</code>，<code>方法</code>，<code>局部变量</code>，<code>方法参数</code>等的前面用来对这些元素进行说明注释</p>
<h3 id="1-3-注解的分类"><a href="#1-3-注解的分类" class="headerlink" title="1.3 注解的分类"></a>1.3 注解的分类</h3><ul>
<li>基本注解</li>
<li>元注解</li>
<li>自定义注解</li>
</ul>
<h3 id="1-4-基本注解"><a href="#1-4-基本注解" class="headerlink" title="1.4 基本注解"></a>1.4 基本注解</h3><p><code>java.lang</code>包下注解分别是 : <code>@Override</code>,<code>@Deprecated</code>,<code>@SuppressWarnings</code>,<code>@FunctionalInterface</code>,<code>@SafeVarargs</code>,</p>
<ul>
<li><p><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法</p>
<pre><code class="java">class Student extends Person implements Info&#123;
    @Override
    public void work()&#123;
        System.out.println(&quot;学生工作&quot;);
    &#125;
    @Override
    public void show() &#123;

    &#125;
&#125;
</code></pre>
</li>
<li><p><code>@Deprecated</code>: 用于表示所修饰的元素(类, 方法等)<code>已过时</code>。表示此方法或类不再建议使用，调用时也会出现删除线，通常是因为所修饰的结构危险或存在更好的选择，如<code>ViewPager</code>中的<code>setOnPageChangeListener</code>方法，已过时</p>
<pre><code class="java">@Deprecated
public void setOnPageChangeListener(OnPageChangeListener listener) &#123;
    mOnPageChangeListener = listener;
&#125;
</code></pre>
</li>
<li><p><code>@SuppressWarnings</code>: 抑制编译器警告</p>
<pre><code class="java">public class AnnotationTest &#123;
    public static void main(String[] args) &#123;
        @SuppressWarnings(&#123;&quot;unused&quot;,&quot;rawtypes&quot;&#125;)
        ArrayList arrayList=new ArrayList();
   &#125;
&#125;
</code></pre>
</li>
<li><p><code>@FunctionalInterface</code>： 示例</p>
</li>
</ul>
<pre><code class="java">//`Java8`为函数式接口引入了一个新注解`@FunctionalInterface`,其主要用于编译错误检查,
//加上该注释后当你写的接口不符合函数式定义时,编译器就会报错 !
//注意: 是否添加`@FunctionalInterface`对于接口是不是函数式接口没有影响,
//该注释只是提醒`编译器`去检查该接口是否仅仅包含一个抽象方法.
@FunctionalInterface
interface functionalInterface &#123;

    // 注意: 函数式接口中只能有一个抽象方法 !
    void myLambda(String message);

    // 函数式接口里是可以包含默认方法,因为默认方法不是抽象方法,其有一个默认实现,
    //所以是符合函数式接口的定义的.
    default void defaultMethod() &#123;
        // method body..
    &#125;

    // 函数式接口里是可以包含静态方法,因为静态方法不能是抽象方法,是一个已经实现了的方法,
    //所以是符合函数式接口的定义的.
    static void staticMethod() &#123;
        // method body..
    &#125;

    // 函数式接口里是可以包含Object里的public方法,这些方法对于函数式接口来说,
    // 不被当成是抽象方法(虽然它们是抽象方法).因为任何一个函数式接口的实现,默认都继承了Object类,
    //其包含了来自java.lang.Object里对这些抽象方法的实现!
    @Override
    boolean equals(Object object);

&#125;

//使用`@FunctionalInterface`注解的函数式接口继而可以使用`Lambda`表示式来表示该接口的一个实现.
//(Java8 之前一般是使用匿名类实现的).
//functionalInterface  f = message-&gt;System.out.println();
</code></pre>
<ul>
<li><p><code>@SafeVarargs</code>： 声明具有模糊类型（比如：泛型）的可变参数的构造函数或方法时，Java编译器会报unchecked警告。鉴于这些情况，如果程序员断定声明的构造函数和方法的主体不会对其varargs参数执行潜在的不安全的操作，可使用@SafeVarargs进行标记，这样的话，Java编译器就不会报unchecked警告。</p>
<p>只能用于标记构造函数和方法，由于保留策略声明为RUNTIME，所以此注解可以在运行时生效。</p>
</li>
</ul>
<pre><code class="java">public class SafeVarargsAnnotation&lt;S&gt;&#123;

    private S[] args;

    //构造函数可以使用@SafeVarargs标记
    @SafeVarargs
    public SafeVarargsAnnotation(S... args)&#123;
        this.args = args;
    &#125;

    //此处不能使用@SafeVarargs，因为此方法未声明为static或final方法，
    //如果要抑制unchecked警告，可以使用@SuppressWarnings注解
    @SuppressWarnings(&quot;unchecked&quot;)
    //@SafeVarargs
    public void loopPrintArgs(S... args)&#123;
        for (S arg : args) &#123;
            System.out.println(arg);
        &#125;
    &#125;

    //final方法可以使用@SafeVarargs标记
    @SafeVarargs
    public final void printSelfArgs(S... args)&#123;
        for (S arg : this.args) &#123;
            System.out.println(arg);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        SafeVarargsAnnotation.loopPrintInfo(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
    &#125;

    //static方法可以使用@SafeVarargs标记
    @SafeVarargs
    public static &lt;T&gt; void loopPrintInfo(T ... infos)&#123;
        for (T info : infos) &#123;
            System.out.println(info);
        &#125;
    &#125;

&#125;
</code></pre>
<p>如果以上把@SafeVarargs标记注释掉，在编译时就会报unchecked警告</p>
<h3 id="1-5-元注解"><a href="#1-5-元注解" class="headerlink" title="1.5 元注解"></a>1.5 元注解</h3><p><code>java.lang.annotation</code>包下的注解分别是 : <code>@Retention</code>,<code>@Documnetd</code>,<code>@Target</code>,<code>@Inherited</code></p>
<p>以上四个注解被称为<code>元注解</code>,其作用是负责注解其它的注解,用来提供对其它<code>annotation</code>类型做说明.</p>
<pre><code class="java">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings &#123;
    String[] value();
&#125;
</code></pre>
<p>注意: <code>JDK8</code>在<code>java.lang.annotation</code>中添加了<code>Repeatable</code>和<code>Native</code>注解.其中<code>Repeatable</code>支持重复注解,<code>Native</code>用于注解本机代码可以访问的域变量</p>
<ul>
<li><p><code>Retention</code>：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS\RUNTIME，只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p>
<ol>
<li><code>RetentionPolicy.SOURCE</code>：注解只在源码阶段保留，编译器开始编译时它将被丢弃忽视</li>
<li><code>RetentionPolicy.CLASS</code>：注解会保留到编译期，但运行时不会把它加载到JVM中（默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得）</li>
<li><code>RetentionPolicy.RUNTIME</code>：注解可以保留到程序运行时，它会被加载到JVM中，所以程序运行过程中可以获取到它们</li>
</ol>
</li>
<li><p><code>Target</code>:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
<ol>
<li><code>ElementType.PACKAGE</code>：可作用在包上</li>
<li><code>ElementType.TYPE</code>：可作用在类、接口、枚举上</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：可以作用在注解上</li>
<li><code>ElementType.FIELD</code>：可作用在属性上</li>
<li><code>ElementType.CONSTRUCTOR</code>：可作用在构造方法上</li>
<li><code>ElementType.METHOD</code>：可作用在方法上</li>
<li><code>ElementType.PARAMETER</code>：可作用在方法参数上</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：可作用在局部变量上，例如方法中定义的变量</li>
<li><code>ElementType.TYPE_PARAMETER</code>:可作用在类参数的声明上   如：泛型声明。Since jdk1.8以后添加的</li>
<li><code>ElementType.TYPE_USE</code>:可作用在使用的类型  Since jdk1.8以后添加的</li>
</ol>
</li>
<li><p><code>Documented</code>:表示所修饰的注解在被javadoc解析时，保留下来。（不常用）</p>
</li>
<li><p><code>Inherited</code>:被它修饰的 Annotation 将具继承性，一个父类被该类注解修饰，那么它的子类如果没有任何注解修饰，就会继承父类的这个注解。（不常用）</p>
<pre><code class="java">@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Person &#123;
&#125;
 
@Person
public class Teacher &#123;
&#125;
 
public class TeacherA extends Teacher&#123;
&#125;
</code></pre>
<p>注解Person被@Inherited修饰，Teacher被Person修饰，TeacherA继承Teacher（TeacherA上又无其他注解），那么TeacherA就会拥有Person这个注解。</p>
</li>
</ul>
<h4 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h4><ul>
<li><p><code>Repeatable</code>：支持重复注解</p>
<pre><code class="java">@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)
public @interface Persons &#123;
   Person[] value();
&#125;

@Repeatable(Persons.class)
public @interface Person&#123;
    String role() default &quot;&quot;;
&#125;

@Person(role=&quot;Teacher&quot;)
@Person(role=&quot;Student&quot;)
@Person(role=&quot;Doctor&quot;)
public class Man &#123;
    String name=&quot;&quot;;
&#125;
</code></pre>
</li>
</ul>
<h3 id="1-6-自定义注解"><a href="#1-6-自定义注解" class="headerlink" title="1.6  自定义注解"></a>1.6  自定义注解</h3><h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><p>注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>
<pre><code class="java">@Repeatable(Persons.class)
public  @interface Person&#123;
    String role() default &quot;&quot;;
&#125;
</code></pre>
<p>注解Person里面的role属性，role是一个成员变量，只不过书写形式为 String role() default “”； 即所谓的“无形参的方法”形式书写，给role设置了默认值为空字符串 default “”。</p>
<h4 id="标记注解"><a href="#标记注解" class="headerlink" title="标记注解"></a>标记注解</h4><p>因为<code>标记注解没有成员</code>,所以应用标记注解时,后面不需要有圆括号.如果提供空的圆括号,也不会报错,但不是必需的.类似地,对于所有成员都使用<code>默认值(default)</code>的注解也可以没有圆括号.</p>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)
@interface MyMarker_annotation &#123;
&#125;
</code></pre>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>注解声明为：@interface</li>
</ul>
<ul>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没成员，表明是一个标识作用。</li>
</ul>
<ul>
<li>自定义注解是以元注解为基础注解自己定义的注解。</li>
</ul>
<p>自定义运行是注解分为两步：声明注解、解析注解。</p>
<h4 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h4><pre><code class="java">@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)//指定保留策略
public @interface Animal &#123;
    int value() default 5;
&#125;
</code></pre>
<p>上面是自己定义了一个注解Animal，Animal含有一个int类型的属性，该属性的名称为value，默认值为5。该注解主要用来注解成员变量，作用于运行期。</p>
<h4 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h4><pre><code class="java">public class TestMain &#123;
 
    @Animal(value = 12)
    public int age;
    public static void main(String[] args) &#123;
        TestMain testMain=new TestMain();
        Class clazz=testMain.getClass();
        try &#123;
            Field fieldAge=clazz.getField(&quot;age&quot;);
            Animal animal=fieldAge.getAnnotation(Animal.class);
            System.out.println(animal.value()+&quot;===岁===&quot;);
        &#125; catch (NoSuchFieldException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面通过类的反射机制解析注解，先拿到TestMain类里面的age成员变量，再通过成员变量调用getAnnotation方法拿到该成员变量的注解。</p>
<h4 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h4><ul>
<li>定义注解</li>
</ul>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)//指定保留策略
@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)
public @interface MyAnnotation &#123;

    int id() default 1;

    String name() default &quot;default value&quot;;
&#125;
</code></pre>
<ul>
<li>反射获取自定义注解信息</li>
</ul>
<pre><code class="java">public class getAnnotationInfo &#123;
    @MyAnnotation(name = &quot;Hello annotation !&quot;)
    public void fun(double d, String s) &#123;
    &#125;

    public static void main(String[] args) &#123;
        getAnnotationInfo getInfo = new getAnnotationInfo();

        // 获取Class对象
        Class&lt;?&gt; class1 = getInfo.getClass();
        try &#123;
            // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息
            Method method = class1.getMethod(&quot;fun&quot;, double.class, String.class);
            // 通过调用`getAnnotation`获取与对象相关联的特定注解
            MyAnnotation annotatioin = method.getAnnotation(MyAnnotation.class);
            System.out.println(&quot;id : &quot; + annotatioin.id() + &quot;\nname : &quot; + annotatioin.name());
            //id : 1 
            //name : Hello annotation 
        &#125; catch (NoSuchMethodException | SecurityException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>反射获取所有注解</li>
</ul>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 &#123;

    String description();
&#125;
@MyAnnotation()
@MyAnnotation2(description = &quot;Test class&quot;)
public class getAllAnnotationInfo &#123;

    @MyAnnotation(id = 1, name = &quot;Hello annotation !&quot;)
    @MyAnnotation2(description = &quot;Test method&quot;)
    public void fun() &#123;

    &#125;

    public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;
        getAllAnnotationInfo allAnnotationInfo = new getAllAnnotationInfo();

        // 通过`getAnnoations`获取该类所有注解信息
        Annotation annotation[] = allAnnotationInfo.getClass().getAnnotations();

        System.out.println(&quot;`getAllAnnotationInfo`类的所有注解 : &quot;);
        for (Annotation info : annotation) &#123;
            System.out.println(info);
        &#125;

        System.out.println();
        // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息
        Method method = allAnnotationInfo.getClass().getMethod(&quot;fun&quot;);
        // 通过调用`getAnnotation`获取与对象相关联的特定注解
        annotation = method.getAnnotations();

        System.out.println(&quot;方法`fun()`的所有注解 : &quot;);
        for (Annotation info : annotation) &#123;
            System.out.println(info);
        &#125;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>EL表达式</title>
    <url>/2020/09/15/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>概念：Expression Language 表达式语言</p>
<p>作用：：EL表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 因为EL表达式在输出数据的时候，要比 jsp的表达式脚本要简洁很多。</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
        request.setAttribute(&quot;key&quot;,&quot;值&quot;);
    %&gt;
    表达式脚本输出key的值是：&lt;%=request.getAttribute(&quot;key1&quot;)==null?&quot;&quot;:request.getAttribute(&quot;key1&quot;)%&gt;&lt;br/&gt;
    EL表达式输出key的值是：$&#123;key1&#125;
&lt;/body&gt;
</code></pre>
<p>EL 表达式的格式是：${表达式} </p>
<p>EL 表达式在输出 null 值的时候，输出的是空串。（不显示）</p>
<p>jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。（显示null）</p>
<p><strong>注意</strong>：</p>
<blockquote>
<p>jsp默认支持el表达式的。如果要忽略el表达式</p>
<p>设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式</p>
<p> ${表达式} ：忽略当前这个el表达式</p>
</blockquote>
<h3 id="1-2-EL-表达式搜索域数据的顺序"><a href="#1-2-EL-表达式搜索域数据的顺序" class="headerlink" title="1.2 EL 表达式搜索域数据的顺序"></a>1.2 EL 表达式搜索域数据的顺序</h3><p>EL 表达式主要是在 jsp 页面中输出数据。 <strong>主要是输出域对象中的数据</strong>。</p>
<p>当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
        //往四个域中都保存了相同的key的数据。
        request.setAttribute(&quot;key&quot;, &quot;request&quot;);
        session.setAttribute(&quot;key&quot;, &quot;session&quot;);
        application.setAttribute(&quot;key&quot;, &quot;application&quot;);
        pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;);
    %&gt;
    $&#123; key &#125;//先输出pageContext，找不到就找request输出，从小到大搜索，输出

&lt;/body&gt;
</code></pre>
<h3 id="1-3-EL-表达式输出类型"><a href="#1-3-EL-表达式输出类型" class="headerlink" title="1.3 EL 表达式输出类型"></a>1.3 EL 表达式输出类型</h3><p>输出Bean 的普通属性，数组属性，List 集合属性，map 集合属性</p>
<pre><code class="java">public class Person &#123;
//    i.需求——输出Person类中普通属性，数组属性。list集合属性和map集合属性。
    private String name;
    private String[] phones;
    private List&lt;String&gt; cities;
    private Map&lt;String,Object&gt; map;
    private int age;
&#125;
</code></pre>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
        Person person = new Person();
        person.setName(&quot;张三&quot;);
        person.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;);

        List&lt;String&gt; cities = new ArrayList&lt;String&gt;();
        cities.add(&quot;北京&quot;);
        cities.add(&quot;上海&quot;);
        cities.add(&quot;深圳&quot;);
        person.setCities(cities);

        Map&lt;String,Object&gt;map = new HashMap&lt;&gt;();
        map.put(&quot;key1&quot;,&quot;value1&quot;);
        map.put(&quot;key2&quot;,&quot;value2&quot;);
        map.put(&quot;key3&quot;,&quot;value3&quot;);
        person.setMap(map);

        pageContext.setAttribute(&quot;p&quot;, person);
    %&gt;

    输出Person：$&#123; p &#125;&lt;br/&gt;
    输出Person的name属性：$&#123;p.name&#125; &lt;br&gt;
    输出Person的pnones数组属性值：$&#123;p.phones[2]&#125; &lt;br&gt;
    输出Person的cities集合中的元素值：$&#123;p.cities&#125; &lt;br&gt;
    输出Person的List集合中个别元素值：$&#123;p.cities[2]&#125; &lt;br&gt;
    输出Person的Map集合: $&#123;p.map&#125; &lt;br&gt;
    输出Person的Map集合中某个key的值: $&#123;p.map.key3&#125; &lt;br&gt;
    输出Person的age属性：$&#123;p.age&#125; &lt;br&gt;
&lt;/body&gt;
</code></pre>
<p>结果：</p>
<pre><code>输出Person：Person&#123;name=张三, phones=[18610541354, 18688886666, 18699998888], cities=[北京, 上海, 深圳], map=&#123;key1=value1, key2=value2, key3=value3&#125;&#125;
输出Person的name属性：张三 
输出Person的pnones数组属性值：18699998888 
输出Person的cities集合中的元素值：[北京, 上海, 深圳] 
输出Person的List集合中个别元素值：深圳 
输出Person的Map集合: &#123;key1=value1, key2=value2, key3=value3&#125; 
输出Person的Map集合中某个key的值: value3 
输出Person的age属性：18 
</code></pre>
<h3 id="1-4-EL表达式运算"><a href="#1-4-EL表达式运算" class="headerlink" title="1.4 EL表达式运算"></a>1.4 EL表达式运算</h3><p>算数运算符： + - * /(div) %(mod)</p>
<p>比较运算符： &gt; &lt; &gt;= &lt;= == !=</p>
<p>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</p>
<p>三元运算：表达式 1？表达式 2：表达式 3 </p>
<p>如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值。</p>
<p>演示：</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;!--比较运算--&gt;
    $&#123; 12 == 12 &#125; 或 $&#123; 12 eq 12 &#125; &lt;br&gt;
    $&#123; 12 != 12 &#125; 或 $&#123; 12 ne 12 &#125; &lt;br&gt;
    $&#123; 12 &lt; 12 &#125; 或 $&#123; 12 lt 12 &#125; &lt;br&gt;
    $&#123; 12 &gt; 12 &#125; 或 $&#123; 12 gt 12 &#125; &lt;br&gt;
    $&#123; 12 &lt;= 12 &#125; 或 $&#123; 12 le 12 &#125; &lt;br&gt;
    $&#123; 12 &gt;= 12 &#125; 或 $&#123; 12 ge 12 &#125; &lt;br&gt;
    &lt;hr&gt;
    &lt;!--逻辑运算--&gt;
    $&#123; 12 == 12 &amp;&amp; 12 &gt; 11 &#125; 或 $&#123; 12 == 12 and 12 &gt; 11 &#125; &lt;br&gt;
    $&#123; 12 == 12 || 12 &gt; 11 &#125; 或 $&#123; 12 == 12 or 12 &gt; 11 &#125; &lt;br&gt;
    $&#123; ! true &#125; 或 $&#123; not true &#125; &lt;br&gt;
    &lt;hr&gt;
    &lt;!--算数运算--&gt;
    $&#123; 12 + 12 &#125; &lt;br&gt;
    $&#123; 12 - 12 &#125; &lt;br&gt;
    $&#123; 12 * 12 &#125; &lt;br&gt;
    $&#123; 18 / 12 &#125; 或 $&#123; 18 div 12 &#125;&lt;br&gt;
    $&#123; 18 % 12 &#125; 或 $&#123; 18 mod 12 &#125; &lt;br&gt;
    &lt;!--三元运算--&gt;
    $&#123; 12 != 12 ? &quot;hello&quot;:&quot;EL&quot; &#125;
&lt;/body&gt;
//结果
true 或 true 
false 或 false 
false 或 false 
false 或 false 
true 或 true 
true 或 true 
true 或 true 
true 或 true 
false 或 false 
24 
0 
144 
1.5 或 1.5
6 或 6 
</code></pre>
<p><strong>empty 运算</strong></p>
<p>empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。</p>
<p>以下几种情况为空：</p>
<ul>
<li>值为 null 值的时候，为空 </li>
<li>值为空串的时候，为空 </li>
<li>值是 Object 类型数组，长度为零的时候 </li>
<li>ist 集合，元素个数为零</li>
<li>map 集合，元素个数为零</li>
</ul>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
//        1、值为null值的时候，为空
        request.setAttribute(&quot;emptyNull&quot;, null);
//        2、值为空串的时候，为空
        request.setAttribute(&quot;emptyStr&quot;, &quot;&quot;);
//        3、值是Object类型数组，长度为零的时候
        request.setAttribute(&quot;emptyArr&quot;, new Object[]&#123;&#125;);
//        4、list集合，元素个数为零
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
//        list.add(&quot;abc&quot;);
        request.setAttribute(&quot;emptyList&quot;, list);
//        5、map集合，元素个数为零
        Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();
//        map.put(&quot;key1&quot;, &quot;value1&quot;);
        request.setAttribute(&quot;emptyMap&quot;, map);
    %&gt;
    $&#123; empty emptyNull &#125; &lt;br/&gt;
    $&#123; empty emptyStr &#125; &lt;br/&gt;
    $&#123; empty emptyArr &#125; &lt;br/&gt;
    $&#123; empty emptyList &#125; &lt;br/&gt;
    $&#123; empty emptyMap &#125; &lt;br/&gt;
    &lt;!--结果全为true--&gt;
&lt;/body&gt;
</code></pre>
<p><strong>“.”点运算 和 [] 中括号运算符</strong><br>点运算，可以输出 Bean 对象中某个属性的值。 </p>
<p>[]中括号运算，可以输出有序集合中某个元素的值。 </p>
<p>并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
        Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;a.a.a&quot;, &quot;aaaValue&quot;);
        map.put(&quot;b+b+b&quot;, &quot;bbbValue&quot;);
        map.put(&quot;c-c-c&quot;, &quot;cccValue&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
        $&#123; map[&#39;a.a.a&#39;] &#125; &lt;br&gt;
        $&#123; map[&quot;b+b+b&quot;] &#125; &lt;br&gt;
        $&#123; map[&#39;c-c-c&#39;] &#125; &lt;br&gt;

&lt;/body&gt;
</code></pre>
<h3 id="1-5-EL-表达式的-11-个隐含对象"><a href="#1-5-EL-表达式的-11-个隐含对象" class="headerlink" title="1.5 EL 表达式的 11 个隐含对象"></a>1.5 EL 表达式的 11 个隐含对象</h3><p>EL 个达式中 11 个隐含对象，是 EL 表达式中自己定义的，可以直接使用</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContextImpl</td>
<td>它可以获取 jsp 中的九大内置对象</td>
</tr>
<tr>
<td>pageScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取 pageContext 域中的数据</td>
</tr>
<tr>
<td>requestScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取 Request 域中的数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取 Session 域中的数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取 ServletContext 域中的数据</td>
</tr>
<tr>
<td>param</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求参数的值</td>
</tr>
<tr>
<td>paramValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它也可以获取请求参数的值，获取多个值的时候使用。</td>
</tr>
<tr>
<td>header</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求头的信息</td>
</tr>
<tr>
<td>headerValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求头的信息，它可以获取多个值的情况</td>
</tr>
<tr>
<td>cookie</td>
<td>Map&lt;String,Cookie&gt;</td>
<td>它可以获取当前请求的 Cookie 信息</td>
</tr>
<tr>
<td>initParam</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取在 web.xml 中配置的<context-param>上下文参数</context-param></td>
</tr>
</tbody></table>
<h3 id="1-6-EL表达式的11个隐含对象中的四个域对象"><a href="#1-6-EL表达式的11个隐含对象中的四个域对象" class="headerlink" title="1.6 EL表达式的11个隐含对象中的四个域对象"></a>1.6 EL表达式的11个隐含对象中的四个域对象</h3><p>pageScope ====== pageContext 域 </p>
<p>requestScope ====== Request 域 </p>
<p>sessionScope ====== Session 域 </p>
<p>applicationScope ====== ServletContext 域</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;%
        pageContext.setAttribute(&quot;key1&quot;, &quot;pageContext1&quot;);
        pageContext.setAttribute(&quot;key2&quot;, &quot;pageContext2&quot;);
        request.setAttribute(&quot;key2&quot;, &quot;request&quot;);
        session.setAttribute(&quot;key2&quot;, &quot;session&quot;);
        application.setAttribute(&quot;key2&quot;, &quot;application&quot;);
    %&gt;
    $&#123; applicationScope.key2 &#125;
&lt;/body&gt;
</code></pre>
<h3 id="1-7-pageContext-对象的使用"><a href="#1-7-pageContext-对象的使用" class="headerlink" title="1.7 pageContext 对象的使用"></a>1.7 pageContext 对象的使用</h3><p>协议，服务器 ip：，服务器端口： ， 获取工程路径：，获取请求方法：， 获取客户端 ip 地址： ，获取会话的 id 编号：</p>
<pre><code class="jsp">&lt;body&gt;
    &lt;%--
    request.getScheme() 它可以获取请求的协议
    request.getServerName() 获取请求的服务器ip或域名
    request.getServerPort() 获取请求的服务器端口号
    getContextPath() 获取当前工程路径
    request.getMethod() 获取请求的方式（GET或POST）
    request.getRemoteHost()  获取客户端的ip 地址
    session.getId() 获取会话的唯一标识
    --%&gt;
    &lt;%
        pageContext.setAttribute(&quot;req&quot;, request);
    %&gt;
    &lt;%=request.getScheme() %&gt; &lt;br&gt;
    1.协议： $&#123; req.scheme &#125;&lt;br&gt;
    2.服务器ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;
    3.服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;
    4.获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;
    5.获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;
    6.获取客户端ip地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;
    7.获取会话的id编号：$&#123; pageContext.session.id &#125;&lt;br&gt;

&lt;/body&gt;
</code></pre>
<h3 id="1-8-其他隐含对象的使用"><a href="#1-8-其他隐含对象的使用" class="headerlink" title="1.8 其他隐含对象的使用"></a>1.8 其他隐含对象的使用</h3><pre><code class="java">&lt;body&gt;
    &lt;!--param   Map&lt;String,String&gt;   它可以获取请求参数的值--&gt;
    输出请求参数username的值：$&#123; param.username &#125; &lt;br&gt;
    输出请求参数password的值：$&#123; param.password &#125; &lt;br&gt;
    
    &lt;!--paramValuesMap&lt;String,String[]&gt;它也可以获取请求参数的值，获取多个值的时候使用。--&gt;
    输出请求参数username的值：$&#123; paramValues.username[0] &#125; &lt;br&gt;
    输出请求参数hobby的值：$&#123; paramValues.hobby[0] &#125; &lt;br&gt;
    输出请求参数hobby的值：$&#123; paramValues.hobby[1] &#125; &lt;br&gt;
    &lt;hr&gt;
    
    &lt;!--headerMap&lt;String,String&gt;它可以获取请求头的信息--&gt;
    输出请求头【User-Agent】的值：$&#123; header[&#39;User-Agent&#39;] &#125; &lt;br&gt;
    输出请求头【Connection】的值：$&#123; header.Connection &#125; &lt;br&gt;
    输出请求头【User-Agent】的值：$&#123; headerValues[&#39;User-Agent&#39;][0] &#125; &lt;br&gt;
    &lt;hr&gt;
    
    &lt;!--cookie  Map&lt;String,Cookie&gt;  它可以获取当前请求的 Cookie 信息--&gt;
    获取Cookie的名称：$&#123; cookie.JSESSIONID.name &#125; &lt;br&gt;
    获取Cookie的值：$&#123; cookie.JSESSIONID.value &#125; &lt;br&gt;
    &lt;hr&gt;

    &lt;!--initParam   Map&lt;String,String&gt;  它可以获取在 web.xml 中配置的&lt;context-param&gt;上下文参数--&gt;
    输出&amp;lt;Context-param&amp;gt;username的值：$&#123; initParam.username &#125; &lt;br&gt;
    输出&amp;lt;Context-param&amp;gt;url的值：$&#123; initParam.url &#125; &lt;br&gt;

&lt;/body&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie&amp;Session</title>
    <url>/2020/09/23/Cookie&amp;Session/</url>
    <content><![CDATA[<h1 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h1><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话：一次会话中包含多次请求和响应。</p>
<p> 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</p>
<p>会话功能：在一次会话的范围内的多次请求间，共享数据</p>
<p>会话的方式：</p>
<ul>
<li><p>客户端会话技术：Cookie</p>
</li>
<li><p>服务器端会话技术：Session</p>
</li>
</ul>
<h2 id="客户端会话Cookie"><a href="#客户端会话Cookie" class="headerlink" title="客户端会话Cookie"></a>客户端会话Cookie</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>客户端会话技术，将数据保存到客户端</p>
<p>Cookie 是服务器通知客户端保存键值对的一种技术。 </p>
<p>客户端有了 Cookie 后，每次请求都发送给服务器。</p>
<p>每个 Cookie 的大小不能超过 4kb</p>
<h3 id="1-2-Cookie的创建"><a href="#1-2-Cookie的创建" class="headerlink" title="1.2 Cookie的创建"></a>1.2 Cookie的创建</h3><p>创建Cookie对象，绑定数据：<code>new Cookie(String name, String value)</code> </p>
<p>发送Cookie对象：<code>response.addCookie(Cookie cookie)</code> </p>
<p><img src="/2020/09/23/Cookie&Session/cookie%E5%88%9B%E5%BB%BA.jpg" alt="cookie创建"></p>
<pre><code class="java">public class CookieServlet extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //创建cookie
        Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;);
        //通知客户端保存cookie
        response.addCookie(cookie);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<p>从客户端获取cookie，拿到数据： <code>Cookie[]  request.getCookies()</code> </p>
<p><img src="/2020/09/23/Cookie&Session/cookie%E8%8E%B7%E5%8F%96.jpg" alt="cookie获取"></p>
<pre><code class="java">public class CookieDemo2 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //获取Cookie
        Cookie[] cookies = request.getCookies();

        if (cookies!=null)&#123;
            for (Cookie cookie : cookies) &#123;
                System.out.println(cookie.getName());
                System.out.println(cookie.getValue());
            &#125;
        &#125;
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        this.doPost(request, response);
    &#125;
&#125;
</code></pre>
<p>cookie工具类：查找指定名称的cookie</p>
<pre><code class="java">public class CookieUtils &#123;
    /**
     * 查找指定名称的Cookie对象
     */
    public static Cookie findCookie(String name , Cookie[] cookies)&#123;
        if (name == null || cookies == null || cookies.length == 0) &#123;
            return null;
        &#125;
        for (Cookie cookie : cookies) &#123;
            if (name.equals(cookie.getName())) &#123;
                return cookie;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p>使用：</p>
<pre><code class="java">protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        Cookie[] cookies = req.getCookies();
        for (Cookie cookie : cookies) &#123;
            // getName方法返回Cookie的key（名）
            // getValue方法返回Cookie的value值
            resp.getWriter().write(&quot;Cookie[&quot; + cookie.getName() + &quot;=&quot; + cookie.getValue() + &quot;] &lt;br/&gt;&quot;);
        &#125;
        Cookie iWantCookie = CookieUtils.findCookie(&quot;key1&quot;, cookies);
//        for (Cookie cookie : cookies) &#123;
//            if (&quot;key2&quot;.equals(cookie.getName())) &#123;
//                iWantCookie = cookie;
//                break;
//            &#125;
//        &#125;
        // 如果不等于null，说明赋过值，也就是找到了需要的Cookie
        if (iWantCookie != null) &#123;
            resp.getWriter().write(&quot;找到了需要的Cookie&quot;);
        &#125;

    &#125;
</code></pre>
<h3 id="1-3-Cookie值的修改"><a href="#1-3-Cookie值的修改" class="headerlink" title="1.3 Cookie值的修改"></a>1.3 Cookie值的修改</h3><p>方案一：修改key1的值</p>
<ul>
<li>先创建一个要修改的同名的Cookie对象</li>
<li>在构造器中同时赋于新的Cookie值。</li>
<li>Cookie cookie = new Cookie(“key1”,”newValue1”);</li>
<li>调用response.addCookie( Cookie ); 通知 客户端 保存修改</li>
</ul>
<p>方案二：</p>
<ul>
<li><p>先查找到需要修改的Cookie对象</p>
</li>
<li><p>调用setValue()方法赋于新的Cookie值。</p>
</li>
<li><p>调用response.addCookie()通知客户端保存修改</p>
</li>
</ul>
<pre><code class="java">protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
//        方案一：
//        1、先创建一个要修改的同名的Cookie对象
//        2、在构造器中同时赋于新的Cookie值。
//        Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newValue1&quot;);
//        3、调用response.addCookie( Cookie ); 通知 客户端 保存修改
//        resp.addCookie(cookie);

//        方案二：
//        1、先查找到需要修改的Cookie对象
        Cookie cookie = CookieUtils.findCookie(&quot;key2&quot;, req.getCookies());
        if (cookie != null) &#123;
//            2、调用setValue()方法赋于新的Cookie值。
            cookie.setValue(&quot;newValue2&quot;);
//        3、调用response.addCookie()通知客户端保存修改
            resp.addCookie(cookie);
        &#125;
        resp.getWriter().write(&quot;key1的Cookie已经修改好&quot;);
    &#125;
</code></pre>
<h3 id="1-4-Cookie生命周期"><a href="#1-4-Cookie生命周期" class="headerlink" title="1.4 Cookie生命周期"></a>1.4 Cookie生命周期</h3><p>Cookie 的生命控制指的是如何管理Cookie 什么时候被销毁（删除）</p>
<p>设置Cookie的<code>setMaxAge()</code> 方法，得到cookie对象后就设置生命周期</p>
<ul>
<li><p>正数，表示在指定的秒数后过期 </p>
</li>
<li><p>负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） </p>
</li>
<li><p>零，表示马上删除 Cookie</p>
</li>
</ul>
<pre><code class="java">protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        Cookie cookie = new Cookie(&quot;life3600&quot;, &quot;life3600&quot;);
        cookie.setMaxAge(60 * 60); // 设置Cookie一小时之后被删除。无效
        resp.addCookie(cookie);
        resp.getWriter().write(&quot;已经创建了一个存活一小时的Cookie&quot;);
    
        Cookie cookie = CookieUtils.findCookie(&quot;key4&quot;, req.getCookies());
        if (cookie != null) &#123;
            // 调用setMaxAge(0);
            cookie.setMaxAge(0); // 表示马上删除，都不需要等待浏览器关闭
            // 调用response.addCookie(cookie);
            resp.addCookie(cookie);

            resp.getWriter().write(&quot;key4的Cookie已经被删除&quot;);
        &#125;
    
    
    &#125;
</code></pre>
<h3 id="1-5-Cookie有效路径path的设置"><a href="#1-5-Cookie有效路径path的设置" class="headerlink" title="1.5 Cookie有效路径path的设置"></a>1.5 Cookie有效路径path的设置</h3><p>Cookie 的 path 属性可以有效的过滤 哪些 Cookie 可以发送给服务器。哪些不能发送给服务器。 </p>
<p>path 属性是通过请求的地址来进行有效的过滤。</p>
<pre><code class="java">protected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        Cookie cookie = new Cookie(&quot;path1&quot;, &quot;path1&quot;);
        // getContextPath() ===&gt;&gt;&gt;&gt;  得到工程路径
        cookie.setPath(req.getContextPath() + &quot;/abc&quot;); // ===&gt;&gt;&gt;&gt;  /工程路径/abc
        //只有/工程路径/abc下的cookie可以发送给服务器
    
        resp.addCookie(cookie);
        resp.getWriter().write(&quot;创建了一个带有Path路径的Cookie&quot;);
    &#125;
</code></pre>
<h3 id="1-6-Cookie的其他细节"><a href="#1-6-Cookie的其他细节" class="headerlink" title="1.6 Cookie的其他细节"></a>1.6 Cookie的其他细节</h3><ol>
<li><p>一次可不可以发送多个cookie?</p>
<ul>
<li>可以</li>
<li>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li>
</ul>
</li>
<li><p>cookie能不能存中文？</p>
<ul>
<li>在tomcat 8 之前 cookie中不能直接存储中文数据。<ul>
<li>需要将中文数据转码—一般采用URL编码</li>
</ul>
</li>
<li>在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</li>
</ul>
</li>
<li><p>cookie共享问题？</p>
<ol>
<li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</li>
</ol>
<ul>
<li>默认情况下cookie不能共享</li>
<li>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</li>
<li>如果要共享，则可以将path设置为”/“</li>
</ul>
<ol start="2">
<li>不同的tomcat服务器间cookie共享问题？<ul>
<li>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</li>
<li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li>
</ul>
</li>
</ol>
</li>
<li><p>Cookie的特点和作用</p>
<ol>
<li>cookie存储数据在客户端浏览器</li>
<li>浏览器对于单个cookie 的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)</li>
</ol>
<ul>
<li><p>作用：</p>
<ol>
<li><p>cookie一般用于存储少量的不太敏感的数据</p>
</li>
<li><p>在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>例如：</p>
<pre><code class="java">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
     String username = req.getParameter(&quot;username&quot;);
     String password = req.getParameter(&quot;password&quot;);

     if (&quot;wzg168&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;
         //登录 成功
         Cookie cookie = new Cookie(&quot;username&quot;, username);
         cookie.setMaxAge(60 * 60 * 24 * 7);//当前Cookie一周内有效
         resp.addCookie(cookie);
         System.out.println(&quot;登录 成功&quot;);
     &#125; else &#123;
//            登录 失败
         System.out.println(&quot;登录 失败&quot;);
     &#125;

 &#125;
</code></pre>
</li>
</ol>
<h2 id="服务器端会话Session"><a href="#服务器端会话Session" class="headerlink" title="服务器端会话Session"></a>服务器端会话Session</h2></li>
</ul>
<h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3></li>
</ol>
<p>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession </p>
<p>Session 就一个接口（HttpSession）。</p>
<p>Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。</p>
<p>每个客户端都有自己的一个 Session 会话。</p>
<p>Session 会话中，我们经常用来保存用户登录之后的信息。</p>
<p>Session的实现是依赖于Cookie的。</p>
<h3 id="1-2-Session创建与获取"><a href="#1-2-Session创建与获取" class="headerlink" title="1.2 Session创建与获取"></a>1.2 Session创建与获取</h3><p>如何创建和获取 Session。它们的 API 是一样的。 </p>
<p><code>request.getSession()</code> 第一次调用是：创建 Session 会话 </p>
<p>之后调用都是：获取前面创建好的 Session 会话对象。</p>
<p><code>isNew();</code> 判断到底是不是刚创建出来的（新的） true 表示刚创建 false 表示获取之前创建</p>
<p>每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 getId() 得到 Session 的会话 id 值。</p>
<pre><code class="java">//创建
protected void createOrGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 创建和获取Session会话对象
        HttpSession session = req.getSession();
        // 判断 当前Session会话，是否是新创建出来的
        boolean isNew = session.isNew();
        // 获取Session会话的唯一标识 id
        String id = session.getId();
        resp.getWriter().write(&quot;得到的Session，它的id是：&quot; + id + &quot; &lt;br /&gt; &quot;);
        resp.getWriter().write(&quot;这个Session是否是新创建的：&quot; + isNew + &quot; &lt;br /&gt; &quot;);
    &#125;
//设置值
protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;);
        resp.getWriter().write(&quot;已经往Session中保存了数据&quot;);

    &#125;
//获取值
protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        Object attribute = req.getSession().getAttribute(&quot;key1&quot;);
        resp.getWriter().write(&quot;从Session中获取出key1的数据是：&quot; + attribute);
    &#125;
</code></pre>
<h3 id="1-3-Session生命周期"><a href="#1-3-Session生命周期" class="headerlink" title="1.3 Session生命周期"></a>1.3 Session生命周期</h3><p><code>public void setMaxInactiveInterval(intinterval)</code> 作用：</p>
<ul>
<li><p>设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 </p>
</li>
<li><p>值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用）</p>
</li>
</ul>
<p><code>public int getMaxInactiveInterval()</code>：获取 Session 的超时时间</p>
<p><code>public void invalidate()</code> ：让当前 Session 会话马上超时无效</p>
<p>Session 默认的超时时长是多少！</p>
<ul>
<li><p>Session 默认的超时时间长为 30 分钟。 因为在Tomcat服务器的配置文件web.xml中默认有以下的配置，它就表示配置了当前</p>
<p>Tomcat服务器下所有的Session 超时配置默认时长为：30 分钟。</p>
</li>
</ul>
<pre><code class="xml">&lt;session-config&gt;
    &lt;session-timeout&gt;30&lt;/session-timeout&gt; 
&lt;/session-config&gt;
</code></pre>
<p>如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。你可以在你自己的 web.xml 配置文件中做 以上相同的配置。就</p>
<p>可以修改你的 web 工程所有 Seession 的默认超时时长。 </p>
<p>如果你想只修改个别 Session 的超时时长。就可以使用上面的 API。</p>
<p><code>session.setMaxInactiveInterval(intinterval)</code>来进行单独的设置超时时长</p>
<p>实例代码</p>
<pre><code class="java">protected void life3(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 先获取Session对象
        HttpSession session = req.getSession();
        // 设置当前Session3秒后超时
        session.setMaxInactiveInterval(3);

        resp.getWriter().write(&quot;当前Session已经设置为3秒后超时&quot;);
    &#125;

    protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 先获取Session对象
        HttpSession session = req.getSession();
        // 让Session会话马上超时
        session.invalidate();
        resp.getWriter().write(&quot;Session已经设置为超时（无效）&quot;);
    &#125;
</code></pre>
<h3 id="1-4-浏览器和-Session-之间关联"><a href="#1-4-浏览器和-Session-之间关联" class="headerlink" title="1.4 浏览器和 Session 之间关联"></a>1.4 浏览器和 Session 之间关联</h3><p><img src="/2020/09/23/Cookie&Session/session.jpg" alt="session"></p>
<h3 id="1-5-Session其他细节"><a href="#1-5-Session其他细节" class="headerlink" title="1.5 Session其他细节"></a>1.5 Session其他细节</h3><ol>
<li>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</li>
</ol>
<ul>
<li><p>默认情况下。不是。</p>
</li>
<li><p>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</p>
<pre><code class="java">Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());
c.setMaxAge(60*60);
response.addCookie(c);
</code></pre>
</li>
</ul>
<ol start="2">
<li>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</li>
</ol>
<ul>
<li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul>
<li>session的钝化：<ul>
<li>在服务器正常关闭之前，将session对象系列化到硬盘上</li>
</ul>
</li>
<li>session的活化：<ul>
<li>在服务器启动后，将session文件转化为内存中的session对象即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>session什么时候被销毁？</li>
</ol>
<ul>
<li>服务器关闭</li>
<li>session默认失效时间 30分钟</li>
</ul>
<ol start="4">
<li>session的特点</li>
</ol>
<ul>
<li>session用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session可以存储任意类型，任意大小的数据</li>
</ul>
<ol start="5">
<li><p>session与Cookie的区别：</p>
<ul>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Enum(枚举)</title>
    <url>/2020/09/11/Enum(%E6%9E%9A%E4%B8%BE)/</url>
    <content><![CDATA[<h2 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum(枚举)"></a>Enum(枚举)</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p>
<p>例如：星期：Monday(星期一)、……、Sunday(星期天) </p>
<p>性别：Man(男)、Woman(女) </p>
<p>季节：Spring(春节)……Winter(冬天) </p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类</p>
</li>
<li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p>
</li>
</ul>
<h3 id="1-2-自定义枚举类"><a href="#1-2-自定义枚举类" class="headerlink" title="1.2 自定义枚举类"></a>1.2 自定义枚举类</h3><ul>
<li>枚举类的属性 :枚举类对象的属性不应允许被改动, 所以应该使用 <code>private final</code> 修饰 </li>
<li>枚举类的使用: private final 修饰的属性应该在构造器中为其赋值 </li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</li>
<li>私有化类的构造器，保证不能在类的外部创建其对象 </li>
<li>在类的内部创建枚举类的实例。声明为：public static final </li>
</ul>
<pre><code class="java">//自定义枚举类
class Season&#123;
    //声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //私化类的构造器,并给对象属性赋值
    private Season(String seasonName, String seasonDesc) &#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &#125;
    //提供当前枚举类的多个对象：public static final的
    public static final Season SPRING=new Season(&quot;春天&quot;,&quot;四季如春&quot;);
    public static final Season SUMMER=new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);
    public static final Season AUTUMN=new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);
    public static final Season WINTER=new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);

    //其他诉求1：获取枚举类对象的属性
    public String getSeasonName() &#123;
        return seasonName;
    &#125;

    public String getSeasonDesc() &#123;
        return seasonDesc;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;seasonName=&#39;&quot; + seasonName + &#39;\&#39;&#39; +
                &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
//使用
public class SeasonTest &#123;
    public static void main(String[] args) &#123;
        Season str=Season.SPRING;
        System.out.println(str);//Season&#123;seasonName=&#39;春天&#39;, seasonDesc=&#39;四季如春&#39;&#125;
        String seasonDesc = str.getSeasonDesc();
        System.out.println(seasonDesc);//四季如春
    &#125;
&#125;
</code></pre>
<h3 id="1-3-enum定义枚举类"><a href="#1-3-enum定义枚举类" class="headerlink" title="1.3 enum定义枚举类"></a>1.3 enum定义枚举类</h3><ul>
<li>jdk 5.0 新增使用enum定义枚举类。步骤：</li>
</ul>
<pre><code class="java">enum Season1&#123;
    //提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束,最开始就要这样做
    SPRING(&quot;春天&quot;),
    SUMMER(&quot;夏天&quot;),
    AUTUMN(&quot;秋天&quot;),
    WINTER(&quot;冬天&quot;);

    private final String seasonName;

    private Season1(String seasonName) &#123;
        this.seasonName = seasonName;
    &#125;
    public String getSeasonName() &#123;
        return seasonName;
    &#125;
&#125;

//使用
public class SeasonTest &#123;
    public static void main(String[] args) &#123;
        Season1 autumn = Season1.AUTUMN;
        System.out.println(autumn);//重写过toString AUTUMN
        System.out.println(autumn.getSeasonName());

        //枚举类的方法
        //toString():返回枚举类对象的名称
        System.out.println(autumn.toString());//AUTUMN

        //values():返回所的枚举类对象构成的数组
        Season1[] values = Season1.values();
        for(int i = 0;i &lt; values.length;i++)&#123;
            System.out.println(values[i]);
        &#125;//SPRING SUMMER AUTUMN WINTER

        //valueOf(String objName):返回枚举类中对象名是objName的对象
        Season1 winter = Season1.valueOf(&quot;WINTER&quot;);
        //如果没objName的枚举类对象，则抛异常：IllegalArgumentException
//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);
        System.out.println(winter);//WINTER
    &#125;
&#125;
</code></pre>
<h3 id="1-4-枚举类对象分别实现接口"><a href="#1-4-枚举类对象分别实现接口" class="headerlink" title="1.4 枚举类对象分别实现接口"></a>1.4 枚举类对象分别实现接口</h3><pre><code class="java">public class SeasonTest1 &#123;
    public static void main(String[] args) &#123;
        Season2.AUTUMN.show();
    &#125;
&#125;

interface Info&#123;
    void show();
&#125;

//使用enum关键字枚举类
enum Season2 implements Info&#123;
    //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;春天在哪里？&quot;);
        &#125;
    &#125;,
    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;宁夏&quot;);
        &#125;
    &#125;,
    AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;秋天不回来&quot;);
        &#125;
    &#125;,
    WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;大约在冬季&quot;);
        &#125;
    &#125;;

    private final String seasonName;
    private final String seasonDesc;

    private Season2(String seasonName,String seasonDesc)&#123;
        this.seasonName=seasonName;
        this.seasonDesc=seasonDesc;
    &#125;
&#125;

</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter过滤器和Listener监听器</title>
    <url>/2020/09/24/Filter%E8%BF%87%E6%BB%A4%E5%99%A8&amp;Listener%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Filter过滤器和Listener监听器"><a href="#Filter过滤器和Listener监听器" class="headerlink" title="Filter过滤器和Listener监听器"></a>Filter过滤器和Listener监听器</h1><h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器 </p>
</li>
<li><p>Filter 过滤器它是 JavaEE 的规范。也就是接口</p>
</li>
<li><p>Filter 过滤器它的作用是：拦截请求，过滤响应。</p>
</li>
</ul>
<p>拦截请求常见的应用场景有： 权限检查 ，日记操作 ，事务管理 ……等等</p>
<h3 id="1-2-Filter过滤器的使用"><a href="#1-2-Filter过滤器的使用" class="headerlink" title="1.2 Filter过滤器的使用"></a>1.2 Filter过滤器的使用</h3><p>Filter 过滤器的使用步骤： </p>
<ol>
<li>编写一个类去实现 Filter 接口</li>
<li>实现过滤方法 doFilter() </li>
<li>到 web.xml 中去配置 Filter 的拦截路径</li>
</ol>
<pre><code class="java">public class TestFilter implements Filter &#123;
    public void destroy() &#123;
    &#125;

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;
        chain.doFilter(req, resp);
    &#125;

    public void init(FilterConfig config) throws ServletException &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.review.filter.TestFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;!--filter-mapping配置Filter过滤器的拦截路径 --&gt;
    &lt;filter-mapping&gt;
        &lt;!--filter-name表示当前的拦截路径给哪个filter使用 --&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;!--url-pattern配置拦截路径
        /表示请求地址为： http://ip:port/工程路径/映射到IDEA的web目录
        /admin/*表示请求地址为： http://ip:port/工程路径/admin/*
        --&gt;
        &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<ul>
<li>Filter的使用</li>
</ul>
<pre><code class="java">public class ManagerFilter implements Filter &#123;
    public void destroy() &#123;
    &#125;

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;
        HttpServletRequest httpServletRequest= (HttpServletRequest) req;
        Object user = httpServletRequest.getSession().getAttribute(&quot;user&quot;);
        if (user == null)&#123;//判断不符合条件就跳到登录页面
            httpServletRequest.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp);
        &#125;else &#123;//符合条件放行
            chain.doFilter(req, resp);
        &#125;

    &#125;

    public void init(FilterConfig config) throws ServletException &#123;

    &#125;

&#125;
</code></pre>
<h3 id="1-3-Filter的生命周期"><a href="#1-3-Filter的生命周期" class="headerlink" title="1.3 Filter的生命周期"></a>1.3 Filter的生命周期</h3><p>Filter 的生命周期包含几个方法 </p>
<p>构造器方法 </p>
<p>init 初始化方法 </p>
<p>前两个方法在 web 工程启动的时候执行（Filter 已经创建）</p>
<p>doFilter 过滤方法，每次拦截到请求，就会执行</p>
<p>destroy 销毁 ，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</p>
<h3 id="1-4-FilterConfig类"><a href="#1-4-FilterConfig类" class="headerlink" title="1.4 FilterConfig类"></a>1.4 FilterConfig类</h3><p>FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 </p>
<p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。</p>
<p>FilterConfig 类的作用是获取 filter 过滤器的配置内容 </p>
<ol>
<li>获取 Filter 的名称 filter-name 的内容 </li>
<li>获取在 Filter 中配置的 init-param 初始化参数 </li>
<li>获取 ServletContext 对象</li>
</ol>
<h3 id="1-5FilterChain-过滤器链"><a href="#1-5FilterChain-过滤器链" class="headerlink" title="1.5FilterChain 过滤器链"></a>1.5FilterChain 过滤器链</h3><p>Filter 过滤器 Chain 链，链条 FilterChain 就是过滤器链（多个过滤器如何一起工作）</p>
<p><img src="/2020/09/24/Filter%E8%BF%87%E6%BB%A4%E5%99%A8&Listener%E7%9B%91%E5%90%AC%E5%99%A8/FilterChain.jpg" alt="FilterChain"></p>
<h3 id="1-6Filter的拦截路径"><a href="#1-6Filter的拦截路径" class="headerlink" title="1.6Filter的拦截路径"></a>1.6Filter的拦截路径</h3><p><strong>精确匹配</strong><br><url-pattern>/target.jsp</url-pattern> </p>
<p>以上配置的路径，表示请求地址必须为：<a href="http://ip:port/工程路径/target.jsp">http://ip:port/工程路径/target.jsp</a></p>
<p><strong>目录匹配</strong><br><url-pattern>/admin/*</url-pattern> </p>
<p>以上配置的路径，表示请求地址必须为：<a href="http://ip:port/工程路径/admin/">http://ip:port/工程路径/admin/</a>*</p>
<p><strong>后缀名匹配</strong><br><url-pattern>*.html</url-pattern> </p>
<p>以上配置的路径，表示请求地址必须以.html 结尾才会拦截到 </p>
<p> <url-pattern>*.action</url-pattern> </p>
<p>以上配置的路径，表示请求地址必须以.action 结尾才会拦截到</p>
<p>Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！！</p>
<h2 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h2><ul>
<li><p>概述：</p>
<ul>
<li>Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器</li>
<li>Listener 它是 JavaEE 的规范，就是接口</li>
<li>监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。</li>
</ul>
</li>
<li><p><code>ServletContextListener</code> 监听器</p>
<ul>
<li><code>ServletContextListener</code> 它可以监听 <code>ServletContext</code> 对象的创建和销毁。</li>
<li><code>ServletContext</code> 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。</li>
<li>监听到创建和销毁之后都会分别调用 <code>ServletContextListener</code> 监听器的方法反馈。</li>
</ul>
<pre><code class="java">public interface ServletContextListener extends EventListener &#123;
    //初始化调用
    default void contextInitialized(ServletContextEvent sce) &#123;
    &#125;
    //销毁调用
    default void contextDestroyed(ServletContextEvent sce) &#123;
    &#125;
&#125;
</code></pre>
<p>如何使用 ServletContextListener 监听器监听 ServletContext 对象</p>
<ul>
<li>编写一个类去实现 ServletContextListener </li>
<li>实现其两个回调方法</li>
<li>到 web.xml 中去配置监听器</li>
</ul>
<pre><code class="java">public class MyServletContextListenerImpl implements ServletContextListener &#123;

    @Override
    public void contextInitialized(ServletContextEvent sce) &#123;
        System.out.println(&quot;ServletContext对象被创建了&quot;);
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent sce) &#123;
        System.out.println(&quot;ServletContext对象被销毁了&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml"> &lt;listener&gt;
        &lt;listener-class&gt;com.review.listener.MyServletContextListenerImpl&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+github搭建个人博客</title>
    <url>/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="Hexo-github搭建个人博客"><a href="#Hexo-github搭建个人博客" class="headerlink" title="Hexo+github搭建个人博客"></a>Hexo+github搭建个人博客</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>下载两个软件 <code>NodeJs</code> 和 <code>Git</code>，我用的是这两个版本的<img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908205500251.png" alt="image-20200908205500251"></p>
<p>你们可以自己在官网下载，然后找个地方安装好</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.jpg" alt="批注 2020-09-08 204850"></p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.jpg" alt="批注 2020-09-08 205037"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>新建一个文件夹，以后博客内容放在此文件夹中，名字自取</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908205847652.png" alt="image-20200908205847652"></p>
<p>然后在此界面输入cmd，然后回车</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908210202406.png" alt="image-20200908210202406"></p>
<p>进入到此页面后输入以下命令</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908210300373.png" alt="image-20200908210300373"></p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>//用来设置镜像网站，下面的下载会快很多</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908210447090.png" alt="image-20200908210447090"></p>
<pre><code>npm install hexo-cli -g
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/9.png" alt="9"></p>
<p>（xxx是你的博客的名字）如：betblog（bet+blog）的格式</p>
<pre><code>hexo init xxxblog
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908211305999.png" alt="image-20200908211305999"></p>
<p>完成之后进入你的博客目录中安装依赖</p>
<pre><code>cd xxxblog
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908211335457.png" alt="image-20200908211335457"></p>
<p>在此目录(E:\blog\betblog)下执行以下命令</p>
<pre><code>npm install
</code></pre>
<p>完成之后，本地服务器搭建完毕，此时可以运行本地服务器看看</p>
<pre><code>hexo s
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908211858920.png" alt="image-20200908211858920"></p>
<p>复制此网址，在浏览器打开</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908211932952.png" alt="image-20200908211932952"></p>
<p>出现这样的页面说明本地服务器搭建完毕，接下来就是将此网站与github连接</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>准备一个github账号，创建一个库</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908212215126.png" alt="image-20200908212215126"></p>
<p>然后可以测试一下自己的github的网址(用户名.github.io)是否可用(可省略)</p>
<p>新建一个index.html,里面输入hello word，然后再浏览器输入自己的github的网址(例如：用户名.github.io)查看</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908212520528.png" alt="image-20200908212520528"></p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908212544538.png" alt="image-20200908212544538"></p>
<p>至此，github的网址也运行成功</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>将hexo和github关联，需要用到git</p>
<p>打开blog文件夹，进入到xxxblog文件夹中打开cmd输入以下命令，安装git依赖</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908213047451.png" alt="image-20200908213047451"></p>
<p>然后我们在安装好的git文件夹中找到git-bash程序，也可以鼠标右键打开(在哪文件夹下打开都可以)</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908213346362.png" alt="image-20200908213346362"></p>
<p>然后输入以下几行命令</p>
<pre><code>git config --global user.name &quot;xxx&quot;
</code></pre>
<pre><code>git config --global user.email &quot;此處填寫你綁定github的郵箱地址&quot;
</code></pre>
<pre><code>ssh-keygen -t rsa -C  &quot;此處填你綁定github的郵箱地址&quot;
</code></pre>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908213849487.png" alt="image-20200908213849487"></p>
<p>出现次次界面则表示成功</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908213927110.png" alt="image-20200908213927110"></p>
<p>然后我们打开C盘——打开用户——打開你當前使用的用户名见图</p>
<p>你會找到一个叫<strong>ssh</strong>的文件夹 里面有一个**.pub** 格式的叫 <strong>id_rsa</strong>的文件</p>
<p>打开它复制里面的内容</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908214117397.png" alt="image-20200908214117397"></p>
<p>我们复制ssh到你的github 的 New SSH keys中</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908214202757.png" alt="image-20200908214202757"></p>
<p>最后修改以下blog文件夹中的_config.yml文件，打开文件<br><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png" alt="3"></p>
<p>拉到文本内容最下面</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908214432362.png" alt="image-20200908214432362"></p>
<pre><code>deploy:  
type:  git
repository: 此处填写你的仓库地址
branch: master
</code></pre>
<p>仓库地址在github上复制，输入SSH的地址，以后上传就不需要输入用户名和密码</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908214541605.png" alt="image-20200908214541605"></p>
<p>然后再修改url，拉到文本内容开头</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908214654078.png" alt="image-20200908214654078"></p>
<p>然后ctrl+s保存，关闭文件</p>
<p>最后，打开blog文件夹进入xxxblog，打开cmd</p>
<p>输入hexo cl清除缓存然后输入hexo g部署，最后输入hexo d上传仓库上传仓库需要输入github用户名和密码</p>
<p><img src="/2020/09/08/Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200908215230460.png" alt="image-20200908215230460"></p>
<p>至此，博客搭建完成</p>
<p><a href="https://bet-yc.gitee.io/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%96%87%E5%AD%97%E6%95%99%E7%A8%8B%E5%86%85%E5%90%AB%E6%89%80%E9%9C%80%E4%BB%A3%E7%A0%81/">参考文章</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON&amp;AJAX基本使用</title>
    <url>/2020/09/25/JSON&amp;AJAX%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="JSON-amp-AJAX基本使用"><a href="#JSON-amp-AJAX基本使用" class="headerlink" title="JSON&amp;AJAX基本使用"></a>JSON&amp;AJAX基本使用</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p>
<p>JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等），这样就使得 JSON 成为理想的数据交换格式。</p>
<p>json 是一种轻量级的数据交换格式，轻量级指的是跟 xml 做比较。</p>
<p>数据交换指的是客户端和服务器之间业务数据的传递格式。</p>
<h3 id="1-2-JSON的使用"><a href="#1-2-JSON的使用" class="headerlink" title="1.2 JSON的使用"></a>1.2 JSON的使用</h3><p>json 是由键值对组成，并且由花括号包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。</p>
<p>键用引号(单双都行)引起来，也可以不使用引号</p>
<p>花括号保存对象：使用{}定义json 格式</p>
<p>方括号保存数组：[]</p>
<p>值的取值类型：</p>
<ul>
<li><p>数字（整数或浮点数）</p>
</li>
<li><p>字符串（在双引号中）</p>
</li>
<li><p>逻辑值（true 或 false）</p>
</li>
<li><p>数组（在方括号中）    {“persons”:[{},{}]}</p>
</li>
<li><p>对象（在花括号中） {“address”:{“province”：”陕西”….}}</p>
</li>
<li><p>null</p>
</li>
</ul>
<p>获取数据方式:</p>
<ul>
<li>json对象.键名</li>
<li>json对象[“键名”]</li>
<li>数组对象[索引]</li>
<li>遍历</li>
</ul>
<pre><code class="json">&lt;script&gt;
        //定义基本格式
        var person=&#123;&quot;name&quot;:&quot;张三&quot;,age:23,&#39;gender&#39;:true&#125;;
        //获取name值
        var name = person.name;
        var age = person[&quot;age&quot;];
        // alert(name);
        // alert(age);
        // alert(person);
        //获取person对象中所有的键值对，遍历
        //for in 循环
        for(var key in person)&#123;
            //这样的方式不行，相当于person.&quot;name&quot;
            alert(key+&quot;:&quot;+person[key]);
        &#125;
        //嵌套格式
        var persons = &#123;
            &quot;persons&quot;: [
                &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,
                &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,
                &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;]
        &#125;;
        var gender = persons.persons[0].gender;
        // alert(gender);
        // alert(persons);
        var ps=[
            &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,
            &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;,
            &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;
            ];
        var name1 = ps[1].name;
        // alert(name1);
        // alert(ps);
        //获取ps所有值
        for(var i=0;i&lt;ps.length;i++)&#123;
            for (var j in ps[i])&#123;
                alert(j+&quot;:&quot;+ps[i][j]);
            &#125;
        &#125;
    &lt;/script&gt;
</code></pre>
<h3 id="1-3-JSON中常用的方法"><a href="#1-3-JSON中常用的方法" class="headerlink" title="1.3 JSON中常用的方法"></a>1.3 JSON中常用的方法</h3><p>json 的存在有两种形式。 </p>
<p>一种是：对象的形式存在，我们叫它 json 对象。 </p>
<p>一种是：字符串的形式存在，我们叫它 json 字符串。 </p>
<p>一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 </p>
<p>一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。</p>
<p><code>JSON.stringify()</code> 把 json 对象转换成为 json 字符串</p>
<p><code>JSON.parse()</code> 把 json 字符串转换成为 json 对象</p>
<pre><code class="Json">// 把json对象转换成为 json字符串
            var jsonObjString = JSON.stringify(jsonObj); // 特别像 Java中对象的toString
            alert(jsonObjString)
            // 把json字符串。转换成为json对象
            var jsonObj2 = JSON.parse(jsonObjString);
            alert(jsonObj2.key1);// 12
            alert(jsonObj2.key2);// abc
</code></pre>
<h3 id="1-4-JSON数据和java对象的相互转换"><a href="#1-4-JSON数据和java对象的相互转换" class="headerlink" title="1.4 JSON数据和java对象的相互转换"></a>1.4 JSON数据和java对象的相互转换</h3><p>JSON常见的解析器</p>
<ul>
<li>常见的解析器：Jsonlib，Gson，fastjson，jackson</li>
</ul>
<p><strong>JSON和java对象互相转换</strong>(使用Gson)</p>
<ul>
<li>导入Gson的相关jar包</li>
<li>创建Gson核心对象 Gson</li>
<li>调用Gson的相关方法进行转换</li>
</ul>
<pre><code class="java">  //javaBean和json的互转
    @Test
    public void test1()&#123;
        Person person = new Person(1,&quot;国哥好帅!&quot;);
        // 创建Gson对象实例
        Gson gson = new Gson();
        // toJson方法可以把java对象转换成为json字符串
        String personJsonString = gson.toJson(person);
        System.out.println(personJsonString);
        // fromJson把json字符串转换回Java对象
        // 第一个参数是json字符串
        // 第二个参数是转换回去的Java对象类型
        Person person1 = gson.fromJson(personJsonString, Person.class);
        System.out.println(person1);
    &#125;
</code></pre>
<p><strong>List和JSON的互相转换</strong></p>
<pre><code class="java">   //List 和json的互转
    @Test
    public void test2() &#123;
        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();

        personList.add(new Person(1, &quot;hello&quot;));
        personList.add(new Person(2, &quot;康师傅&quot;));

        Gson gson = new Gson();

        // 把List转换为json字符串
        String personListJsonString = gson.toJson(personList);
        System.out.println(personListJsonString);
        //把json转换为list
        List&lt;Person&gt; list = gson.fromJson(personListJsonString, new PersonListType().getType());
        System.out.println(list);
        Person person = list.get(0);
        System.out.println(person);
    &#125;
</code></pre>
<p><strong>Map和JSON的互相转换</strong></p>
<pre><code class="java">@Test
    public void test3()&#123;
        Map&lt;Integer,Person&gt; personMap = new HashMap&lt;&gt;();

        personMap.put(1, new Person(1, &quot;Hello&quot;));
        personMap.put(2, new Person(2, &quot;Json&quot;));

        Gson gson = new Gson();
        // 把 map 集合转换成为 json字符串
        String personMapJsonString = gson.toJson(personMap);
        System.out.println(personMapJsonString);

//        Map&lt;Integer,Person&gt; personMap2 = gson.fromJson(personMapJsonString, new PersonMapType().getType());
        Map&lt;Integer,Person&gt; personMap2 = gson.fromJson(personMapJsonString, new TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;()&#123;&#125;.getType());

        System.out.println(personMap2);
        Person p = personMap2.get(1);
        System.out.println(p);

    &#125;
</code></pre>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML，指一种创建交互式网页应用的网页开发技术</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<ul>
<li>同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</li>
<li>异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</li>
</ul>
<p>ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。</p>
<p>Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容</p>
<p>Ajax 是一种在<strong>无需重新加载整个网页</strong>的情况下，能够更新部分网页的技术。</p>
<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。</p>
<p>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。使用Ajax可以提升用户的体验</p>
<h3 id="1-2-Ajax的使用"><a href="#1-2-Ajax的使用" class="headerlink" title="1.2 Ajax的使用"></a>1.2 Ajax的使用</h3><p>原生Ajax的实现</p>
<pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;
            // 在这里使用javaScript语言发起Ajax请求，访问服务器AjaxServlet中javaScriptAjax
            function ajaxRequest() &#123;
//                 1、我们首先要创建XMLHttpRequest 
                var xmlhttprequest = new XMLHttpRequest();
//                 2、调用open方法设置请求参数
                xmlhttprequest.open(&quot;GET&quot;,&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot;,true);
//                 4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。
                xmlhttprequest.onreadystatechange = function()&#123;
                    if (xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status == 200) &#123;
                        alert(&quot;收到服务器返回的数据：&quot; + xmlhttprequest.responseText);
                        var jsonObj = JSON.parse(xmlhttprequest.responseText);
                        // 把响应的数据显示在页面上
                        document.getElementById(&quot;div01&quot;).innerHTML = &quot;编号：&quot; + jsonObj.id + &quot; , 姓名：&quot; + jsonObj.name;
                    &#125;
                &#125;
//                 3、调用send方法发送请求
                xmlhttprequest.send();
                alert(&quot;我是最后一行的代码&quot;);
            &#125;
        &lt;/script&gt;
</code></pre>
<p>JQeury实现方式：$.ajax()</p>
<ul>
<li>语法：$.ajax({键值对});</li>
<li>使用$.ajax()发送异步请求</li>
</ul>
<p>参数</p>
<ul>
<li>url 表示请求的地址 </li>
<li>type 表示请求的类型 GET 或 POST 请求 </li>
<li>data 表示发送给服务器的数据 格式有两种：name=value&amp;name=value ，{key:value} </li>
<li>success 请求成功，响应的回调函数 ，error错误，返回啥</li>
<li>dataType 响应的数据类型</li>
</ul>
<pre><code class="js">function fun() &#123;
            //使用$.ajax()发送异步请求
            $.ajax(&#123;
                url:&quot;ajaxServlet&quot; ,//请求路径
                type:&quot;POST&quot;,//请求方式，默认get
                // data:&quot;username=jack&amp;age=23&quot;,//请求参数,两种写法
                data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;,//建议这种
                success:function (data) &#123;
                    alert(data);
                &#125;,//响应成功后的回调函数
                error:function () &#123;
                    alert(&quot;出错了&quot;)
                &#125;,//如果请求响应出现错误，会执行的回调函数
                dataType:&quot;text&quot;//设置接收到的响应数据的格式
                //最后一个键值对不加逗号
            &#125;);
        &#125;
</code></pre>
<p>  $.get()：发送get请求</p>
<p>  语法：$.get(url, [data], [callback], [type])</p>
<p>  参数：</p>
<ul>
<li><p>url：请求路径</p>
</li>
<li><p>data：请求参数</p>
</li>
<li><p>callback：回调函数</p>
</li>
<li><p>type：响应结果的类型</p>
<pre><code class="js">//定义方法
      function fun() &#123;
          //使用$.ajax()发送异步请求
          $.get(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;,age:23&#125;,function (data) &#123;
              alert(data)
          &#125;,&quot;text&quot;);
      &#125;
</code></pre>
<p>$.post()：发送post请求</p>
<p>语法：$.post(url, [data], [callback], [type])</p>
<p>参数：</p>
</li>
<li><p>url：请求路径</p>
</li>
<li><p>data：请求参数</p>
</li>
<li><p>callback：回调函数</p>
</li>
<li><p>type：响应结果的类型</p>
<pre><code class="js">//定义方法
      function fun() &#123;
          //使用$.ajax()发送异步请求
          $.post(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;,age:23&#125;,function (data) &#123;
              alert(data)
          &#125;,&quot;text&quot;);
      &#125;
</code></pre>
<p>$.getJSON() 方法 ：get请求固定，返回的类型固定是json数据，所以比前面的方法省略了type参数</p>
</li>
<li><p>url 请求的 url 地址 </p>
</li>
<li><p>data 发送给服务器的数据 </p>
</li>
<li><p>callback 成功的回调函数</p>
<pre><code class="js">              // ajax--getJson请求
              $(&quot;#getJSONBtn&quot;).click(function()&#123;
                  $.getJSON(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQueryGetJSON&quot;,function (data) &#123;
                      $(&quot;#msg&quot;).html(&quot; getJSON 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);
                  &#125;);
              &#125;);
</code></pre>
</li>
</ul>
<h3 id="1-3-表单序列化"><a href="#1-3-表单序列化" class="headerlink" title="1.3 表单序列化"></a>1.3 表单序列化</h3><p>表单序列化 serialize()</p>
<p>serialize()可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value 的形式进行拼接。</p>
<pre><code class="js">// ajax请求
                $(&quot;#submit&quot;).click(function()&#123;
                    // 把参数序列化
                    $.getJSON(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQuerySerialize&amp;&quot; + $(&quot;#form01&quot;).serialize(),function (data) &#123;
                        $(&quot;#msg&quot;).html(&quot; Serialize 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);
                    &#125;);
                &#125;);
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP基本使用</title>
    <url>/2020/09/18/JSP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="JSP基本使用"><a href="#JSP基本使用" class="headerlink" title="JSP基本使用"></a>JSP基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>jsp : java server pages。Java 的服务器页面。</li>
<li>jsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。</li>
<li>因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。</li>
<li><strong>jsp 页面本质上是一个 Servlet 程序</strong>。</li>
</ul>
<p>当执行一个index.jsp页面，会生成对应的index_jsp.java文件，可以看出此java类继承于HttpJspBase</p>
<pre><code class="java">public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent,org.apache.jasper.runtime.JspSourceImports &#123;&#125;
</code></pre>
<h3 id="1-2-JSP语法"><a href="#1-2-JSP语法" class="headerlink" title="1.2 JSP语法"></a>1.2 JSP语法</h3><h4 id="1-2-1-JSP指令"><a href="#1-2-1-JSP指令" class="headerlink" title="1.2.1 JSP指令"></a>1.2.1 JSP指令</h4><ol>
<li><strong>page指令</strong>(最常用)</li>
</ol>
<p><strong>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</strong></p>
<ul>
<li><p>jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为。</p>
</li>
<li><p>language 属性      表示 jsp 翻译后是什么语言文件。暂时只支持 java。 </p>
</li>
<li><p>contentType 属性          表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值 </p>
</li>
<li><p>pageEncoding 属性         表示当前 jsp 页面文件本身的字符集。 </p>
</li>
<li><p>import 属性 跟 java 源代码中一样。用于导包，导类。</p>
</li>
<li><p>errorPage 属性 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径</p>
</li>
<li><p>isErrorPage 属性 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。</p>
</li>
<li><p>ix.session 属性 设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。</p>
</li>
<li><p>extends 属性 设置 jsp 翻译出来的 java 类默认继承谁。<br>========================两个属性是给 out 输出流使用=============================</p>
</li>
<li><p>autoFlush 属性   设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。</p>
</li>
<li><p>buffer 属性 设置 out 缓冲区的大小。默认是 8kb</p>
</li>
</ul>
<ol start="2">
<li><p><strong>include指令</strong></p>
<p><strong>JSP静态包含</strong>(常用)</p>
</li>
</ol>
<ul>
<li><p>include    ： 页面包含的。导入页面的资源文件</p>
<ul>
<li><strong>&lt;%@ include file=”top.jsp”%&gt;</strong></li>
</ul>
</li>
<li><p>此方式也称为jsp <strong>静态包含</strong></p>
</li>
<li><p>file属性指定你要包含的jsp页面的路径</p>
</li>
<li><p>地址中第一个斜杠/表示为<a href="http://ip:port/工程路径/映射到代码的web目">http://ip:port/工程路径/映射到代码的web目</a> 录</p>
</li>
<li><p>静态包含的特点： </p>
<ul>
<li>静态包含不会翻译被包含的jsp页面 。</li>
<li>静态包含其实是把被包含的jsp页面的代码拷贝到包含的位置执行输 出 。</li>
</ul>
<p><strong>jsp动态包含</strong></p>
<pre><code class="jsp">&lt;%--
        &lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;     这是动态包含
        page 属性是指定你要包含的jsp页面的路径
        动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置

        动态包含的特点：
            1、动态包含会把包含的jsp页面也翻译成为java代码
            2、动态包含底层代码使用如下代码去调用被包含的jsp页面执行输出。
                JspRuntimeLibrary.include(request, response, &quot;/include/footer.jsp&quot;, out, false);
            3、动态包含，还可以传递参数
    --%&gt;
    &lt;jsp:include page=&quot;/include/footer.jsp&quot;&gt;
        &lt;jsp:param name=&quot;username&quot; value=&quot;bbj&quot;/&gt;
        &lt;jsp:param name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/jsp:include&gt;
</code></pre>
<p><strong>动态包含原理</strong></p>
<p><img src="/2020/09/18/JSP%E8%AF%A6%E8%A7%A3/JSP2.jpg" alt="JSP"></p>
</li>
</ul>
<ol start="3">
<li><strong>taglib</strong>    ： 导入资源</li>
</ol>
<ul>
<li><strong>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</strong></li>
<li>prefix：前缀，自定义的</li>
</ul>
<h4 id="1-2-2-JSP脚本"><a href="#1-2-2-JSP脚本" class="headerlink" title="1.2.2 JSP脚本"></a>1.2.2 JSP脚本</h4><ol>
<li><p><strong>声明脚本</strong>(不常用)</p>
<ul>
<li>格式： &lt;%! 声明 java 代码 %&gt; </li>
<li>作用：可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块。内部类等。</li>
</ul>
<pre><code class="jsp">&lt;%--1、声明类属性--%&gt;
    &lt;%!
        private Integer id;
        private String name;
        private static Map&lt;String,Object&gt; map;
    %&gt;
&lt;%--2、声明static静态代码块--%&gt;
    &lt;%!
        static &#123;
            map = new HashMap&lt;String,Object&gt;();
            map.put(&quot;key1&quot;, &quot;value1&quot;);
            map.put(&quot;key2&quot;, &quot;value2&quot;);
            map.put(&quot;key3&quot;, &quot;value3&quot;);
        &#125;
    %&gt;
&lt;%--3、声明类方法--%&gt;
    &lt;%!
        public int abc()&#123;
            return 12;
        &#125;
    %&gt;
&lt;%--4、声明内部类--%&gt;
    &lt;%!
        public static class A &#123;
            private Integer id = 12;
            private String abc = &quot;abc&quot;;
        &#125;
    %&gt;
</code></pre>
</li>
<li><p><strong>表达式脚本</strong></p>
<ul>
<li>格式是：&lt;%=表达式%&gt; </li>
<li>作用是：的 jsp 页面上输出数据。</li>
<li>表达式脚本的特点： <ul>
<li>所有的表达式脚本都会被翻译到jspService() 方法中</li>
<li>表达式脚本都会被翻译成为 out.print()输出到页面上</li>
<li>由于表达式脚本翻译的内容都在jspService() 方法中,所以jspService()方法中的对象都可以直接使用。 </li>
<li>表达式脚本中的表达式不能以分号结束。</li>
</ul>
</li>
</ul>
<pre><code class="jsp">1.输出整型
2.输出浮点型
3.输出字符串
4.输出对象
    &lt;%=12 %&gt; &lt;br&gt;

    &lt;%=12.12 %&gt; &lt;br&gt;

    &lt;%=&quot;我是字符串&quot; %&gt; &lt;br&gt;

    &lt;%=map%&gt; &lt;br&gt;

    &lt;%=request.getParameter(&quot;username&quot;)%&gt;
</code></pre>
</li>
<li><p><strong>代码脚本</strong></p>
<ul>
<li>格式是： &lt;% java 语句 %&gt; </li>
<li>作用是：可以在 jsp 页面中，编写我们自己需要的功能（写的是 java 语句）。</li>
<li>代码脚本的特点是：<ul>
<li>代码脚本翻译之后都在jspService 方法中 </li>
<li>代码脚本由于翻译到jspService()方法中，所以在jspService()方法中的现有对象都可以直接使用。</li>
<li>还可以由多个代码脚本块组合完成一个完整的 java 语句。</li>
<li>代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数据</li>
</ul>
</li>
</ul>
<pre><code class="jsp">&lt;%--1.代码脚本----if 语句--%&gt;
    &lt;%
        int i = 13 ;
        if (i == 12) &#123;
            System.out.println(&quot;Hello&quot;);
        &#125; else &#123;
            System.out.println(&quot;JSP&quot;);
        &#125;
    %&gt;
&lt;br&gt;
&lt;%--2.代码脚本----for 循环语句--%&gt;
    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
    &lt;%
        for (int j = 0; j &lt; 10; j++) &#123;
            System.out.println(&quot;第&quot;+j+&quot;行&quot;);
        &#125;
    %&gt;
    &lt;/table&gt;
&lt;%--3.翻译后java文件中_jspService方法内的代码都可以写--%&gt;
    &lt;%
        String username = request.getParameter(&quot;username&quot;);
        System.out.println(&quot;用户名的请求参数值是：&quot; + username);
    %&gt;
</code></pre>
</li>
</ol>
<p>所执行的java语句都会被放在jspService中</p>
<pre><code class="java">public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException &#123;

    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;
      final java.lang.String _jspx_method = request.getMethod();
      if (&quot;OPTIONS&quot;.equals(_jspx_method)) &#123;
        response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;);
        return;
      &#125;
      if (!&quot;GET&quot;.equals(_jspx_method) &amp;&amp; !&quot;POST&quot;.equals(_jspx_method) &amp;&amp; !&quot;HEAD&quot;.equals(_jspx_method)) &#123;
        response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;);
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, &quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;);
        return;
      &#125;
    &#125;

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
&#125;
</code></pre>
<p><strong>因为所有的jsp页面代码都放在jspService方法中，所以jspService方法中声明的对象，我们都可以直接在jsp页面使用，不需要再创建，所以jspService方法中的对象称为内置对象</strong></p>
<h4 id="1-2-3注释"><a href="#1-2-3注释" class="headerlink" title="1.2.3注释"></a>1.2.3注释</h4><ol>
<li><p>html 注释：<!-- 这是 html注释 --></p>
<ul>
<li>html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端。</li>
</ul>
</li>
<li><p>java注释：</p>
<pre><code>&lt;%
//单行java注释
/*多行java注释*/
%&gt;
</code></pre>
<ul>
<li>java 注释会被翻译到 java 源代码中。</li>
</ul>
</li>
<li><p>jsp 注释：&lt;%– 这是jsp注释 –%&gt;</p>
<ul>
<li>jsp 注释可以注掉，jsp 页面中所有代码。</li>
</ul>
</li>
</ol>
<h3 id="1-3-JSP的内置对象"><a href="#1-3-JSP的内置对象" class="headerlink" title="1.3 JSP的内置对象"></a>1.3 JSP的内置对象</h3><ul>
<li>jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象</li>
<li>jsp一共有9个内置对象。内置对象在jsp页面中不需要获取和创建，可以直接使用</li>
</ul>
<table>
<thead>
<tr>
<th>变量名</th>
<th>真实类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContext</td>
<td>当前页面共享数据，还可以获取其他八个内置对象</td>
</tr>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>一次请求访问的多个资源(转发)</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>一次会话的多个请求间</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>所有用户间共享数据</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
<td>响应对象</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>当前页面(Servlet)的对象  this</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
<td>输出对象，数据输出到页面上</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>Servlet的配置对象</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>异常对象</td>
</tr>
</tbody></table>
<ul>
<li><p>前四个为域对象</p>
<ul>
<li>四个域对象分别是： <ul>
<li>pageContext (PageContextImpl 类) 当前 jsp 页面范围内有效</li>
<li>request (HttpServletRequest 类)、 一次请求内有效 </li>
<li>session (HttpSession 类)、 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） </li>
<li>application (ServletContext 类) 整个 web 工程范围内都有效（只要 web 工程不停止，数据都在）</li>
</ul>
</li>
<li>域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围。</li>
<li>虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。</li>
<li>四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。</li>
<li>pageContext ====&gt;&gt;&gt; request ====&gt;&gt;&gt; session ====&gt;&gt;&gt; application</li>
</ul>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;scope.jsp页面&lt;/h1&gt;
    &lt;%
        // 往四个域中都分别保存了数据
        pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;);
        request.setAttribute(&quot;key&quot;, &quot;request&quot;);
        session.setAttribute(&quot;key&quot;, &quot;session&quot;);
        application.setAttribute(&quot;key&quot;, &quot;application&quot;);
    %&gt;
    pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;
    request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;
    session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;
    application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;
    &lt;%
//        request.getRequestDispatcher(&quot;/scope2.jsp&quot;).forward(request,response);
    //请求转发，request也有值，但是pageContext置为null
    %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
<h3 id="1-4-jsp中的out输出和response-getWriter输出的区别"><a href="#1-4-jsp中的out输出和response-getWriter输出的区别" class="headerlink" title="1.4 jsp中的out输出和response.getWriter输出的区别"></a>1.4 jsp中的out输出和response.getWriter输出的区别</h3><ul>
<li><p>JSP的内置对象response有getwriter方法输出，JSP的内置对象out也有write方法输出，两者区别</p>
</li>
<li><p>response和jsp都有各自的缓冲区</p>
</li>
<li><p>response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的</p>
<p><img src="/2020/09/18/JSP%E8%AF%A6%E8%A7%A3/JSP1.jpg" alt="jsp"></p>
</li>
<li><p>由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。</p>
</li>
<li><p>out.write() 输出字符串没有问题 </p>
</li>
<li><p>out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出）</p>
</li>
<li><p>深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输出 </p>
</li>
</ul>
<h3 id="1-5-请求转发标签"><a href="#1-5-请求转发标签" class="headerlink" title="1.5 请求转发标签"></a>1.5 请求转发标签</h3><pre><code class="jsp">&lt;%--
        &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 是请求转发标签，它的功能就是请求转发
            page 属性设置请求转发的路径
    --%&gt;
    &lt;jsp:forward page=&quot;/scope2.jsp&quot;&gt;&lt;/jsp:forward&gt;
</code></pre>
<h3 id="1-6-JSP的使用"><a href="#1-6-JSP的使用" class="headerlink" title="1.6 JSP的使用"></a>1.6 JSP的使用</h3><p><img src="/2020/09/18/JSP%E8%AF%A6%E8%A7%A3/JSP3.jpg" alt="JSP3"></p>
<pre><code class="java">@Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 获取请求的参数
        // 发sql语句查询学生的信息
        // 使用for循环生成查询到的数据做模拟
        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();
        for (int i = 0; i &lt; 10; i++) &#123;
            int t = i + 1;
            studentList.add(new Student(t,&quot;name&quot;+t, 18+t,&quot;phone&quot;+t));
        &#125;
        //自己设置的参数，不是请求传来的参数，所以要用setAttribute保存
        // 保存查询到的结果（学生信息）到request域中
        req.setAttribute(&quot;stuList&quot;, studentList);
        // 请求转发到showStudent.jsp页面
        req.getRequestDispatcher(&quot;/test/showStudent.jsp&quot;).forward(req,resp);
    &#125;
</code></pre>
<p>JSP显示数据，通过getAttribute方法</p>
<pre><code class="jsp">&lt;%
        List&lt;Student&gt; studentList = (List&lt;Student&gt;) request.getAttribute(&quot;stuList&quot;);
    %&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;编号&lt;/td&gt;
            &lt;td&gt;姓名&lt;/td&gt;
            &lt;td&gt;年龄&lt;/td&gt;
            &lt;td&gt;电话&lt;/td&gt;
            &lt;td&gt;操作&lt;/td&gt;
        &lt;/tr&gt;
    &lt;% for (Student student : studentList) &#123; %&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;%=student.getId()%&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%=student.getName()%&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%=student.getAge()%&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%=student.getPhone()%&gt;&lt;/td&gt;
            &lt;td&gt;删除、修改&lt;/td&gt;
        &lt;/tr&gt;
    &lt;% &#125; %&gt;
    &lt;/table&gt;
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>JSTL 标签库的基本使用</title>
    <url>/2020/09/16/JSTL%20%E6%A0%87%E7%AD%BE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>JSTL 标签库 全称是指  JSP   Standard   Tag   Library   JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标签库。</p>
<p>EL 表达式主要是为了替换 jsp 中的<strong>表达式脚本</strong>，而标签库则是为了替换<strong>代码脚本</strong>。这样使得整个 jsp 页面 变得更佳简洁。</p>
<p>JSTL 由五个不同功能的标签库组成。 </p>
<table>
<thead>
<tr>
<th>功能范围</th>
<th>URI</th>
<th>前缀</th>
</tr>
</thead>
<tbody><tr>
<td>核心标签库–重点</td>
<td><a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a></td>
<td>c</td>
</tr>
<tr>
<td>格式化</td>
<td><a href="http://java.sun.com/jsp/jstl/fmt">http://java.sun.com/jsp/jstl/fmt</a></td>
<td>fmt</td>
</tr>
<tr>
<td>函数</td>
<td><a href="http://java.sun.com/jsp/jstl/functions">http://java.sun.com/jsp/jstl/functions</a></td>
<td>fn</td>
</tr>
<tr>
<td>数据库(不使用)</td>
<td><a href="http://java.sun.com/jsp/jstl/sql">http://java.sun.com/jsp/jstl/sql</a></td>
<td>sql</td>
</tr>
<tr>
<td>XML(不使用)</td>
<td><a href="http://java.sun.com/jsp/jstl/xml">http://java.sun.com/jsp/jstl/xml</a></td>
<td>x</td>
</tr>
</tbody></table>
<h3 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h3><ol>
<li>先导入 jstl 标签库的 jar 包。 <ul>
<li>taglibs-standard-impl-1.2.1.jar </li>
<li>taglibs-standard-spec-1.2.1.jar</li>
</ul>
</li>
<li>第二步，使用 taglib 指令引入标签库。 (输入JSTL标签时会自动引入)</li>
</ol>
<p>CORE 标签库 ：&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt; </p>
<p>XML 标签库：&lt;%@ taglib prefix=”x” uri=”<a href="http://java.sun.com/jsp/jstl/xml&quot;">http://java.sun.com/jsp/jstl/xml&quot;</a> %&gt; </p>
<p>FMT 标签库： &lt;%@ taglib prefix=”fmt” uri=”<a href="http://java.sun.com/jsp/jstl/fmt&quot;">http://java.sun.com/jsp/jstl/fmt&quot;</a> %&gt; </p>
<p>SQL 标签库： &lt;%@ taglib prefix=”sql” uri=”<a href="http://java.sun.com/jsp/jstl/sql&quot;">http://java.sun.com/jsp/jstl/sql&quot;</a> %&gt; </p>
<p>FUNCTIONS 标签库  &lt;%@ taglib prefix=”fn” uri=”<a href="http://java.sun.com/jsp/jstl/functions&quot;">http://java.sun.com/jsp/jstl/functions&quot;</a> %&gt;</p>
<h3 id="1-3-core-核心库使用"><a href="#1-3-core-核心库使用" class="headerlink" title="1.3 core 核心库使用"></a>1.3 core 核心库使用</h3><p> &lt;c:set/&gt;（使用很少）作用：set 标签可以往域中保存数据</p>
<pre><code class="jsp">&lt;%--
    i.&lt;c:set /&gt;
        作用：set标签可以往域中保存数据

        域对象.setAttribute(key,value);
        scope 属性设置保存到哪个域
            page表示PageContext域（默认值）
            request表示Request域
            session表示Session域
            application表示ServletContext域
        var属性设置key是多少
        value属性设置值
    --%&gt;
    保存之前：$&#123; sessionScope.abc &#125; &lt;br&gt;
    &lt;c:set scope=&quot;session&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;
    保存之后：$&#123; sessionScope.abc &#125; &lt;br&gt;
    &lt;hr&gt;
</code></pre>
<p> &lt;c:if/&gt;  if 标签用来做 if 判断。</p>
<pre><code class="jsp">&lt;%--
       ii.&lt;c:if /&gt;
         if标签用来做if判断。
         test属性表示判断的条件（使用EL表达式输出）
    --%&gt;
    &lt;c:if test=&quot;$&#123; 12 == 12 &#125;&quot;&gt;
        &lt;h1&gt;12等于12&lt;/h1&gt;
    &lt;/c:if&gt;
    &lt;c:if test=&quot;$&#123; 12 != 12 &#125;&quot;&gt;
        &lt;h1&gt;12不等于12&lt;/h1&gt;
    &lt;/c:if&gt;
</code></pre>
<p> &lt;c:choose&gt;   &lt;c:when&gt;    &lt;c:otherwise&gt;   标签  作用：多路判断。跟 switch…case….default 非常接近</p>
<pre><code class="java"> &lt;%--
    iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签
    作用：多路判断。跟switch ... case .... default非常接近

    choose标签开始选择判断
    when标签表示每一种判断情况
        test属性表示当前这种判断情况的值
    otherwise标签表示剩下的情况

    &lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：
        1、标签里不能使用html注释，要使用jsp注释
        2、when标签的父标签一定要是choose标签
    --%&gt;
    &lt;%
        request.setAttribute(&quot;height&quot;, 180);
    %&gt;
    &lt;c:choose&gt;
        &lt;%-- 这是html注释 --%&gt;
        &lt;c:when test=&quot;$&#123; requestScope.height &gt; 190 &#125;&quot;&gt;
            &lt;h2&gt;小巨人&lt;/h2&gt;
        &lt;/c:when&gt;
         &lt;c:when test=&quot;$&#123; requestScope.height &gt; 180 &#125;&quot;&gt;
            &lt;h2&gt;很高&lt;/h2&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;$&#123; requestScope.height &gt; 170 &#125;&quot;&gt;
            &lt;h2&gt;还可以&lt;/h2&gt;
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;
            &lt;c:choose&gt;
                &lt;c:when test=&quot;$&#123;requestScope.height &gt; 160&#125;&quot;&gt;
                    &lt;h3&gt;大于160&lt;/h3&gt;
                &lt;/c:when&gt;
                &lt;c:when test=&quot;$&#123;requestScope.height &gt; 150&#125;&quot;&gt;
                    &lt;h3&gt;大于150&lt;/h3&gt;
                &lt;/c:when&gt;
                &lt;c:when test=&quot;$&#123;requestScope.height &gt; 140&#125;&quot;&gt;
                    &lt;h3&gt;大于140&lt;/h3&gt;
                &lt;/c:when&gt;
                &lt;c:otherwise&gt;
                    其他小于140
                &lt;/c:otherwise&gt;
            &lt;/c:choose&gt;
        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
</code></pre>
<p> &lt;c:forEach/&gt;  作用：遍历输出使用。</p>
<pre><code class="jsp">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;
&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;
&lt;%@ page import=&quot;java.util.List&quot; %&gt;
&lt;%@ page import=&quot;com.review.entity.Student&quot; %&gt;
&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;

&lt;body&gt;
    &lt;%--1.遍历1到10，输出
        begin属性设置开始的索引
        end 属性设置结束的索引
        var 属性表示循环的变量(也是当前正在遍历到的数据)
        for (int i = 1; i &lt; 10; i++)

    &lt;table border=&quot;1&quot;&gt;
        &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;第$&#123;i&#125;行&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;
    &lt;/table&gt;--%&gt;
    &lt;hr&gt;
   &lt;%-- 2.遍历Object数组
        for (Object item: arr)
        items 表示遍历的数据源（遍历的集合）
        var 表示当前遍历到的数据

    &lt;%
        request.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;);
    %&gt;
    &lt;c:forEach items=&quot;$&#123; requestScope.arr &#125;&quot; var=&quot;item&quot;&gt;
        $&#123; item &#125; &lt;br&gt;
    &lt;/c:forEach&gt; --%&gt;
    &lt;hr&gt;
    &lt;%
        Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;key1&quot;, &quot;value1&quot;);
        map.put(&quot;key2&quot;, &quot;value2&quot;);
        map.put(&quot;key3&quot;, &quot;value3&quot;);
//        for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) &#123;
//        &#125;
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    &lt;c:forEach items=&quot;$&#123; requestScope.map &#125;&quot; var=&quot;entry&quot;&gt;
        &lt;h1&gt;$&#123;entry.key&#125; = $&#123;entry.value&#125;&lt;/h1&gt;
    &lt;/c:forEach&gt;
    &lt;hr&gt;
    &lt;%--4.遍历List集合---list中存放 Student类，有属性：编号，用户名，密码，年龄，电话信息--%&gt;
    &lt;%
        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();
        for (int i = 1; i &lt;= 10; i++) &#123;
            studentList.add(new Student(i,&quot;username&quot;+i ,&quot;pass&quot;+i,18+i,&quot;phone&quot;+i));
        &#125;
        request.setAttribute(&quot;stus&quot;, studentList);
    %&gt;
    &lt;form action=&quot;&quot; enctype=&quot;&quot;&gt;&lt;/form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;编号&lt;/th&gt;
            &lt;th&gt;用户名&lt;/th&gt;
            &lt;th&gt;密码&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
            &lt;th&gt;电话&lt;/th&gt;
            &lt;th&gt;操作&lt;/th&gt;
        &lt;/tr&gt;
        &lt;%--
            items 表示遍历的集合
            var 表示遍历到的数据
            begin表示遍历的开始索引值
            end 表示结束的索引值
            step 属性表示遍历的步长值
            varStatus 属性表示当前遍历到的数据的状态
            for（int i = 1; i &lt; 10; i+=2）
        --%&gt;
    &lt;c:forEach begin=&quot;2&quot; end=&quot;7&quot; step=&quot;2&quot; varStatus=&quot;status&quot; items=&quot;$&#123;requestScope.stus&#125;&quot; var=&quot;stu&quot;&gt;
        &lt;tr&gt;
            &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt;
            &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt;
            &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt;
            &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt;
            &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt;
            &lt;td&gt;$&#123;status.step&#125;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/c:forEach&gt;
    &lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2020/10/09/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><h3 id="1-Linux的目录结构"><a href="#1-Linux的目录结构" class="headerlink" title="1. Linux的目录结构"></a>1. Linux的目录结构</h3><ul>
<li><p>Linux文件系统是采用层级式的树状目录结构，在此结构中嘴上层是根目录“/”，然后在此目录下再创建其他目录</p>
</li>
<li><p>在linux中，一些皆为文件</p>
</li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011084739788.png" alt="image-20201011084739788"></p>
<ul>
<li><p>具体的目录结构：</p>
<ul>
<li>/bin [重点] (/usr/bin 、 /usr/local/bin) <ul>
<li>是Binary的缩写, 这个目录存放着最经常使用的命令</li>
</ul>
</li>
<li>/sbin (/usr/sbin 、 /usr/local/sbin)<ul>
<li>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
</ul>
</li>
<li>/home [重点] <ul>
<li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般 该目录名是以用户的账号命名的。</li>
</ul>
</li>
<li>/root [重点]<ul>
<li>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
</ul>
</li>
<li>/lib <ul>
<li>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几 乎所有的应用程序都需要用到这些共享库。</li>
</ul>
</li>
<li>/lost+found<ul>
<li>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
</ul>
</li>
<li>/etc [重点] <ul>
<li>所有的系统管理所需要的配置文件和子目录 my.conf</li>
</ul>
</li>
<li>/usr [重点]<ul>
<li>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows下的program files目录。</li>
</ul>
</li>
<li>/boot [重点]<ul>
<li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li>
</ul>
</li>
<li>/proc：<strong>涉及linux内核，不要轻易动</strong><ul>
<li>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li>
</ul>
</li>
<li>/srv：<strong>涉及linux内核，不要轻易动</strong><ul>
<li>service缩写，该目录存放一些服务启动之后需要提取的数据。 </li>
</ul>
</li>
<li>/sys：<strong>涉及linux内核，不要轻易动</strong><ul>
<li>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs </li>
</ul>
</li>
<li>/tmp<ul>
<li>这个目录是用来存放一些临时文件的。</li>
</ul>
</li>
<li>/dev<ul>
<li>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</li>
</ul>
</li>
<li>/media [重点]<ul>
<li>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</li>
</ul>
</li>
<li>/mnt [重点]<ul>
<li>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare</li>
</ul>
</li>
<li>/opt<ul>
<li>这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。 默认为空。 </li>
</ul>
</li>
<li>/usr/local [重点]<ul>
<li>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</li>
</ul>
</li>
<li>/var [重点]<ul>
<li>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。 包括各种日志文件。</li>
</ul>
</li>
<li>/selinux [security-enhanced linux] 360<ul>
<li>SELinux是一种安全子系统,它能控制程序只能访问特定文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>linux目录总结：</p>
<ul>
<li>linux的目录中有且只有一个根目录</li>
<li>linux的各个目录存放的内容是规划好的，不要乱放文件</li>
<li>linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件</li>
<li>linux目录树，每个目录的作用</li>
</ul>
</li>
</ul>
<h3 id="2-vi和vim编辑器"><a href="#2-vi和vim编辑器" class="headerlink" title="2.vi和vim编辑器"></a>2.vi和vim编辑器</h3><ul>
<li>所有的linux系统都会内建vi文本编辑器</li>
<li>vim具有程序编辑能力，可以看做vi的增强版</li>
</ul>
<p>vi和vim的三种模式</p>
<ul>
<li><p>正常模式</p>
<ul>
<li>以vim打开一个档案就直接进入一般模式，在这个模式中，你可以使用上下左右按键来移动光标可以使用删除字符或删除整行来处理档案，也可以使用赋值，粘贴来处理文件数据</li>
</ul>
</li>
<li><p>插入模式</p>
<ul>
<li>按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，一般按i即可</li>
</ul>
</li>
<li><p>命令行模式</p>
</li>
<li><p>在这个模式中，可以提供你相关的指令，完成读取，存盘，替换，离开vim，显示行号等的动作则在此模式中达成的</p>
</li>
<li><p>vim模式的相互切换</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201010205432518.png" alt="image-20201010205432518"></p>
</li>
</ul>
<p>快捷键的使用：</p>
<ul>
<li>拷贝当前行，将光标停留在当前行，模式切换为正常模式，点击yy赋值成功，p粘贴到光标所在的下一行</li>
<li>拷贝当前行向下的五行(包含当前行) 5yy，p粘贴到光标的下五行</li>
<li>删除当前行，输入dd，删除光标下面的5行(包含光标所在的行)</li>
<li>在文件中查找某个单词，首先进入到命令行，输入/，再输入要查找的关键字，有多个，输入n跳转到下一个</li>
<li>设置文件的行号，取消文件的行号，在命令行模式下输入：set nu  取消set：nonu</li>
<li>使用快捷键到达文档的最末行和最首行，在正常模式下输入g到达最末行，输入gg到最首行</li>
<li>撤销一个动作，在正常模式下输入u撤销</li>
<li>将光标移动到第20行，先显示行号，再回到正常模式下，输入20，再输入shift+g跳转到第20行</li>
</ul>
<h3 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h3><p>关机和重启指令</p>
<ul>
<li>shutdown<ul>
<li>shutdown -h now：表示立即关机</li>
<li>shutdown -h 1：表示1分钟后关机</li>
<li>shutdown -r now：立即重启</li>
</ul>
</li>
<li>halt：直接使用，效果等价于关机</li>
<li>reboot：重启系统</li>
<li>syn：把内存的数据同步到磁盘上，防止关机或重启的时候没有保存的数据丢失，建议在关机或重启前执行此命令</li>
</ul>
<p>用户登录和注销指令</p>
<ul>
<li>登录尽量不用root账号登录，系统管理员，权限很大，避免操作失误，可以登录普通用户，再用su-用户名命令来切换成系统管理员身份</li>
<li>logout 注销用户</li>
<li>注意：<ul>
<li>logout注销指令在图形运行级别无效，在运行级别3下有效</li>
</ul>
</li>
</ul>
<p>用户和用户组：</p>
<ul>
<li>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li>
<li>linux的用户至少要属于一个组</li>
</ul>
<p>添加用户</p>
<ul>
<li><p>在创建用户时，如果没有指定组，默认会创建和用户名相同的组，将此用户放进去</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011093459470.png" alt="image-20201011093459470"></p>
</li>
<li><p>useradd[选项] 用户名</p>
<ul>
<li><p>添加一个用户xm，当用户创建成功后，会自动创建和用户同名的家目录，home文件夹下创建</p>
</li>
<li><p>也可以通过<code>useradd -d 指定目录 新的用户名</code>，来给新创建的用户指定家目录</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011085217655.png" alt="image-20201011085217655"></p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011090431300.png" alt="image-20201011090431300"></p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011090634208.png" alt="image-20201011090634208"></p>
<ul>
<li>指定或者修改密码：passwd 用户名</li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011085925737.png" alt="image-20201011085925737"></p>
<ul>
<li><p>删除用户 userdel 用户名，此删除指令会保存家目录</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011090128716.png" alt="image-20201011090128716"></p>
</li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011085244221.png" alt="image-20201011085244221"></p>
<ul>
<li><p>删除用户xh以及用户家目录</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011090519036.png" alt="image-20201011090519036"></p>
</li>
<li><p>在删除用户时，我们一般不会将家目录删除</p>
</li>
</ul>
<p>查询用户信息</p>
<ul>
<li><p>id 用户名</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011090830464.png" alt="image-20201011090830464"></p>
</li>
<li><p>uid：用户id号，gid：所在组id号，组：组名</p>
</li>
<li><p>当用户不存在时，返回无此用户</p>
</li>
</ul>
<p>切换用户</p>
<ul>
<li><p>在linux中，如果当前用户的权限不够，可以通过su - 指令，切换到高权限用户，比如root</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011091857516.png" alt="image-20201011091857516"></p>
</li>
<li><p>高权限root用户，切换到xh用户，不需要密码，xh属于普通用户，可能权限不够</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011092013695.png" alt="image-20201011092013695"></p>
</li>
<li><p>输入exit可以返回到上一个用户</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011092134703.png" alt="image-20201011092134703"></p>
</li>
<li><p>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要输入密码</p>
</li>
<li><p>当返回原来用户时，可以使用exit指令来返回到原来的用户</p>
</li>
</ul>
<p>用户组</p>
<ul>
<li><p>类似于角色，系统可以对有共性的多个用户进行统一管理，多个用户放在同一个组里</p>
</li>
<li><p>创建组：groupadd 组名</p>
</li>
<li><p>删除组：groupdel 组名</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011092912825.png" alt="image-20201011092912825"></p>
</li>
<li><p>增加用户时直接加上组，<code>useradd -g 组名 用户名</code></p>
</li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011093337910.png" alt="image-20201011093337910"></p>
<p>修改用户的组</p>
<ul>
<li><p><code>usermod -g 用户组 用户名</code></p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011093656038.png" alt="image-20201011093656038"></p>
</li>
</ul>
<p>用户和组相关的文件</p>
<ul>
<li><p>/etc/passwd 文件 用户（user）的配置文件，记录用户的各种信息 </p>
<ul>
<li>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell </li>
</ul>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011095022648.png" alt="image-20201011095022648"></p>
<ul>
<li>zwj：用户名，x：密码，501：用户id，502：组id，/home/zwj：家目录，/bin/bash：对应shell</li>
</ul>
</li>
<li><p>/etc/group 文件 组(group)的配置文件，记录Linux包含的组的信息 </p>
<ul>
<li><p>每行含义：组名:口令:组标识号:组内用户列表</p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011095434913.png" alt="image-20201011095434913"></p>
</li>
</ul>
</li>
<li><p>/etc/shadow 文件 口令的配置文件 ，主要存储密码和登录的相关信息，是加密的</p>
<ul>
<li><p>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警 告时间:不活动时间:失效时间:标志 </p>
<p><img src="/2020/10/09/Linux%E5%9F%BA%E7%A1%80/image-20201011095613937.png" alt="image-20201011095613937"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用指令</title>
    <url>/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux实用指令"><a href="#Linux实用指令" class="headerlink" title="Linux实用指令"></a>Linux实用指令</h2><h3 id="1-指令运行级别"><a href="#1-指令运行级别" class="headerlink" title="1. 指令运行级别"></a>1. 指令运行级别</h3><p>七个运行级别：配置文件为/etc/inittab</p>
<ul>
<li>0：关机</li>
<li>1：单用户【找回丢失密码】，在这个级别下进入linux系统不需要密码</li>
<li>2：多用户状态没有网络服务</li>
<li>3：多用户状态有网络服务【用的最多】</li>
<li>4：系统未使用保留给用户【不要进入，未使用】</li>
<li>5：图形界面</li>
<li>6：系统重启</li>
</ul>
<p>重用的运行级别是3和5，要修改默认的运行级别可以修改文件</p>
<p>/etc/inittab的id:5:initdefault:这一行的数字</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011100723582.png" alt="image-20201011100723582"></p>
<p>切换指定运行级别的指令</p>
<ul>
<li><p>init [0,1,2,3,5,6]</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011101317826.png" alt="image-20201011101317826"></p>
</li>
</ul>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011101523387.png" alt="image-20201011101523387"></p>
<p>面试题</p>
<ul>
<li><p>如何找回root密码？（修改密码只能在主机进行，不能远程进行，所以还是很安全的）</p>
<ul>
<li><p>进入到单用户模式，然后修改root密码，因为进入单用户模式，root不需要密码就可以登录</p>
</li>
<li><p>第一步，linux开机之前，按enter键进入此界面</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011102622709.png" alt="image-20201011102622709"></p>
</li>
<li><p>然后按e，进入到此界面</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011102703435.png" alt="image-20201011102703435"></p>
</li>
<li><p>选中第二个，然后按e进入到此页面</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011102849840.png" alt="image-20201011102849840"></p>
</li>
<li><p>然后输入空格，再输入1，进入单用户模式</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011103000871.png" alt="image-20201011103000871"></p>
</li>
<li><p>然后enter键，回到此界面，【告诉内核进入单用户模式】</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011103139995.png" alt="image-20201011103139995"></p>
</li>
<li><p>然后输入b，开始启动，进入单用户模式，而且以root模式登陆，然后输入passwd修改root密码，正常重启之后完成root密码修改</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011103520697.png" alt="image-20201011103520697"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-帮助指令"><a href="#2-帮助指令" class="headerlink" title="2. 帮助指令"></a>2. 帮助指令</h3><p>当我们对某个指令不熟，可以使用linux提供的帮助指令来了解这个指令的使用方法</p>
<p>基本语法</p>
<ul>
<li><p>man [命令或配置文件]</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011105208203.png" alt="image-20201011105208203"></p>
</li>
</ul>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011105256123.png" alt="image-20201011105256123"></p>
<ul>
<li><p>help 指令，获取shell内置命令的帮助信息</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011105412729.png" alt="image-20201011105412729"></p>
</li>
</ul>
<h3 id="3-文件目录指令"><a href="#3-文件目录指令" class="headerlink" title="3. 文件目录指令"></a>3. 文件目录指令</h3><ul>
<li><p>pwd 指令，显示当前工作目录的绝对路径</p>
</li>
<li><p>ls 指令，查看当前目录的所有内容信息</p>
<ul>
<li><p>ls -a ，查看当前目录所有文件和目录，包括隐藏信息</p>
</li>
<li><p>ls -l ，以列表的方式显示信息</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011105905442.png" alt="image-20201011105905442"></p>
</li>
</ul>
</li>
<li><p>cd 指令，切换到指定目录</p>
<ul>
<li>cd [参数]</li>
<li>cd ~：回到自己的家目录，普通用户家目录在/home下，root用户家目录在/root</li>
<li>cd ..：回到当前目录的上一级目录也可以直接用cd命令，更快捷</li>
</ul>
</li>
<li><p>mkdir 指令：创建目录</p>
<ul>
<li><p>mkdir 目录</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011113401308.png" alt="image-20201011113401308"></p>
</li>
<li><p>mkdir -p 目录名：创建多级目录</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011113633152.png" alt="image-20201011113633152"></p>
</li>
</ul>
</li>
<li><p>rmdir 指令：删除空目录</p>
<ul>
<li><p>rmdir 目录</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011113854099.png" alt="image-20201011113854099"></p>
</li>
<li><p>rm -rf 要删除的内容：删除非空目录</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011114155758.png" alt="image-20201011114155758"></p>
</li>
<li><p>rm -rf /*：删库跑路，慎重选择</p>
</li>
</ul>
</li>
<li><p>touch 指令：创建空文件</p>
<ul>
<li><p>touch 文件名称</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011114453043.png" alt="image-20201011114453043"></p>
</li>
</ul>
</li>
<li><p>cp指令，拷贝文件到指定目录</p>
<ul>
<li><p>cp [选项] source dest：将source文件拷贝到dest，将world.txt复制到bbb文件夹</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011130300801.png" alt="image-20201011130300801"></p>
</li>
<li><p>-r：递归复制整个文件夹 ：cp -r resource dest</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011130804101.png" alt="image-20201011130804101"></p>
</li>
<li><p>强制覆盖不提示：\cp</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011130942404.png" alt="image-20201011130942404"></p>
</li>
</ul>
</li>
<li><p>rm指令：移除或删除文件或目录</p>
<ul>
<li><p>rm [选项] 要删除的文件或目录</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011131111736.png" alt="image-20201011131111736"></p>
</li>
<li><p>-r：递归删除整个文件夹，-f：强制删除不提示</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011131400736.png" alt="image-20201011131400736"></p>
</li>
<li><p>rm -rf /*：删除所有文件，且不提示</p>
</li>
</ul>
</li>
<li><p>mv指令：移动文件与目录重命名</p>
<ul>
<li><p>mv oldNameFile newNameFile （重命名）</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011131642146.png" alt="image-20201011131642146"></p>
</li>
<li><p>mv /temp/movefile  /targetFolder（移动文件）</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011132308376.png" alt="image-20201011132308376"></p>
</li>
</ul>
</li>
<li><p>cat 指令：查看文件内容，只是以只读的方式打开</p>
<ul>
<li><p>cat [选项] 要查看的文件</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011132610348.png" alt="image-20201011132610348"></p>
</li>
<li><p>-n：显示行号</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011133252276.png" alt="image-20201011133252276"></p>
</li>
<li><p>cat只能浏览文件，不能修改文件，为了浏览方便，一般会带上管道命令|more</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011133445177.png" alt="image-20201011133445177"></p>
</li>
</ul>
</li>
<li><p>more指令</p>
<ul>
<li><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页来显示文本文件的内容，more指令中内置了若干快捷键</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011133913987.png" alt="image-20201011133913987"></p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011133931642.png" alt="image-20201011133931642"></p>
</li>
<li><p>快捷键：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键(space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 more ，不再显示该文件内容。</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>=</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>less指令</p>
<ul>
<li><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是 根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011135145939.png" alt="image-20201011135145939"></p>
</li>
<li><p>快捷键</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键(space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 less ，不再显示该文件内容。</td>
</tr>
<tr>
<td>pagedown</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>pageup</td>
<td>向上翻动一页</td>
</tr>
<tr>
<td>/字串</td>
<td>向下搜寻字串的内容</td>
</tr>
<tr>
<td>？字串</td>
<td>向上搜寻字串的内容</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>输出重定向指令 &gt; 和追加指令 &gt;&gt;</p>
<ul>
<li><p>输出重定向&gt;：会将原来的文件的内容覆盖掉</p>
<ul>
<li>例如 ls -l &gt; 文件 （将列表的内容写入到文件中(覆盖写)）</li>
<li>例如ls &gt;&gt; 文件（将列表的内容追加到文件中）</li>
<li>例如cat 文件1&gt;&gt;文件2（将文件1的内容追加到文件2）</li>
</ul>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011140859478.png" alt="image-20201011140859478"></p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011141357540.png" alt="image-20201011141357540"></p>
</li>
</ul>
</li>
<li><p>echo指令：输出内容到控制台</p>
<ul>
<li><p>echo [选项] [输出内容]</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011141615203.png" alt="image-20201011141615203"></p>
</li>
</ul>
</li>
<li><p>head指令</p>
<ul>
<li><p>用于显示文件的开头部分，默认情况下head指令显示文件的前十行内容</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011141814571.png" alt="image-20201011141814571"></p>
</li>
<li><p>head -n 5 文件：显示文件头五行内容</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011141914008.png" alt="image-20201011141914008"></p>
</li>
</ul>
</li>
<li><p>tail指令</p>
<ul>
<li><p>用于输出文件中尾部内容，默认输出文件的后十行</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011142211200.png" alt="image-20201011142211200"></p>
</li>
<li><p>tail -n 5 文件：查看文件后五行的内容</p>
</li>
<li><p>tail -f 文件：实时追踪该文档的所有更新，工作中经常使用，ctrl+c退出tail模式</p>
</li>
</ul>
</li>
<li><p>ln指令</p>
<ul>
<li><p>软连接也叫符号链接，类似于windows中的快捷方式，主要存放了链接其他文件的路径</p>
</li>
<li><p>ln -s [原文件目录] [软链接名]：给原文件创建一个软连接</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011143639992.png" alt="image-20201011143639992"></p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011143738658.png" alt="image-20201011143738658"></p>
</li>
<li><p>此时，进入到linkToRoot文件夹，显示的内容是root文件夹中的内容，但是此时你输入pwd，显示的还是本路径文件夹</p>
</li>
<li><p>删除软链接</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011144125607.png" alt="image-20201011144125607"></p>
</li>
<li><p>在删除软链接时，不要带有/，否则提示资源忙</p>
</li>
</ul>
</li>
<li><p>history命令</p>
<ul>
<li><p>查看已经执行过的历史命令，也可以执行历史命令</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011144319802.png" alt="image-20201011144319802"></p>
</li>
<li><p>显示最近使用过的10个指令，执行编号为149的历史指令</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011144501406.png" alt="image-20201011144501406"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-时间日期指令"><a href="#4-时间日期指令" class="headerlink" title="4. 时间日期指令"></a>4. 时间日期指令</h3><ul>
<li><p>date指令：显示当前日期</p>
<ul>
<li><p>date：显示当前时间</p>
</li>
<li><p>date  +%Y：显示当前年</p>
</li>
<li><p>date   +%m：显示当前是哪个月</p>
</li>
<li><p>date   +%d：显示当前是那一天</p>
</li>
<li><p>date  “+%Y-%m-%d %H:%M:%S”：显示年月日时分秒</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011145247572.png" alt="image-20201011145247572"></p>
</li>
</ul>
</li>
<li><p>date指令-设置日期</p>
<ul>
<li><p>date -s 字符串时间</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011145426002.png" alt="image-20201011145426002"></p>
</li>
<li><p>cal[选项]：查看日历指令，不加选项，显示本月日历</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011145559467.png" alt="image-20201011145559467"></p>
</li>
<li><p>cal 2020 ：显示2020年日历</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011150244555.png" alt="image-20201011150244555"></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-搜索查找指令"><a href="#5-搜索查找指令" class="headerlink" title="5. 搜索查找指令"></a>5. 搜索查找指令</h3><ul>
<li><p>find指令：find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终 端。</p>
<ul>
<li><p>find [搜索范围] [选项]</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-name&lt;查询方式&gt;</td>
<td>按照指定的文件名查找模式来查找文件</td>
</tr>
<tr>
<td>-user&lt;用户名&gt;</td>
<td>查找属于指定用户名所有文件</td>
</tr>
<tr>
<td>-size&lt;文件大小&gt;</td>
<td>按照指定的文件大小查找文件</td>
</tr>
</tbody></table>
</li>
<li><p>按文件名：根据名称查找/home目录下的hello.txt文件</p>
</li>
<li><p>按拥有者：查找/opt目录下，用户名称称为root的文件</p>
</li>
<li><p>查找整个linux系统下大于20m的文件（+n 大于 -n小于 n等与）</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011153853517.png" alt="image-20201011153853517"></p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011153914930.png" alt="image-20201011153914930"></p>
</li>
<li><p>查询 /目录下所有txt文件</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011154057534.png" alt="image-20201011154057534"></p>
</li>
</ul>
</li>
<li><p>locate指令</p>
<ul>
<li><p>locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径 的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。 为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p>
</li>
<li><p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011154833831.png" alt="image-20201011154833831"></p>
</li>
</ul>
</li>
<li><p>grep指令和管道符号|</p>
<ul>
<li><p>grep过滤查找，管道符”|”表示将前一个命令的处理结果输出传递到后面的命令处理</p>
</li>
<li><p>grep [选项] 查找内容 源文件，-n：显示匹配行及行号，-i：忽略大小写</p>
</li>
<li><p>案例：查找a.txt文件中，”ces”所在的行，并显示行号</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011155318000.png" alt="image-20201011155318000"></p>
</li>
<li><p>grep -ni ces：表示不区分大小写</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-压缩和解压文件命令"><a href="#6-压缩和解压文件命令" class="headerlink" title="6. 压缩和解压文件命令"></a>6. 压缩和解压文件命令</h3><ul>
<li><p>gzip/gunzip 指令</p>
<ul>
<li><p>gzip 文件：用于压缩文件，只能将文件压缩为*.gz文件</p>
</li>
<li><p>gunzip 文件.gz：用于解压文件</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011155903218.png" alt="image-20201011155903218"></p>
</li>
<li><p>当我们使用gzip对文件进行压缩后，不会保留原来的文件，解压后也不会保留压缩包</p>
</li>
</ul>
</li>
<li><p>zip/unzip 指令</p>
<ul>
<li><p>zip [选项] 自定义文件名.zip ：压缩文件和目录的命令</p>
<ul>
<li>-r：递归压缩：即压缩目录</li>
</ul>
</li>
<li><p>unzip [选项] 文件名.zip ：解压缩文件</p>
</li>
<li><p>常用选项</p>
<ul>
<li>-d&lt;目录&gt; ：指定解压后文件的存放目录</li>
</ul>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011161425758.png" alt="image-20201011161425758"></p>
</li>
</ul>
</li>
<li><p>tar指令</p>
<ul>
<li><p>tar指令是打包指令，最后打包后的文件是.tar.gz的文件</p>
</li>
<li><p>tar [选项] XXX.tar.gz 打包的内容 (功能描述：压缩后的文件格式.tar.gz)</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生.tar打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>-z</td>
<td>打包的同时压缩</td>
</tr>
<tr>
<td>-x</td>
<td>解包.tar文件</td>
</tr>
</tbody></table>
</li>
<li><p>案例：压缩多个文件，a.tar.gz是打包后的文件名</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011162228870.png" alt="image-20201011162228870"></p>
</li>
<li><p>案例：解压test01文件夹下，test01文件夹要事先存在才能成功</p>
<p><img src="/2020/10/10/Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20201011162538610.png" alt="image-20201011162538610"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis动态SQL</title>
    <url>/2020/10/06/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h2 id="MyBatis动态SQL"><a href="#MyBatis动态SQL" class="headerlink" title="MyBatis动态SQL"></a>MyBatis动态SQL</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>动态 SQL是MyBatis强大特性之一。极大的简化我们拼装 SQL的操作。</p>
<p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。</p>
<p>MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作。 </p>
<ul>
<li> if </li>
<li> choose (when, otherwise) </li>
<li> trim (where, set) </li>
<li>foreach</li>
</ul>
<h3 id="1-2-if的使用："><a href="#1-2-if的使用：" class="headerlink" title="1.2 if的使用："></a>1.2 if的使用：</h3><p>直接写入表达式，在使用时不管传入几个参数都可以执行</p>
<p>mapper映射文件</p>
<pre><code class="xml"> &lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;
    &lt;!--where标签解决解决sql语句拼装的and的问题：and拼接在前面--&gt;
     &lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;
     &lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
         select * from tbl_employee
         &lt;!-- where --&gt;
         &lt;where&gt;
             &lt;!-- test：判断表达式（OGNL）
             OGNL参照PPT或者官方文档。
                    c:if  test
             从参数中取值进行判断
             遇见特殊符号应该去写转义字符：
             &amp;&amp;：
             --&gt;
             &lt;if test=&quot;id!=null&quot;&gt;&lt;!--传上来的id参数不为空才会将其拼接--&gt;
                 id=#&#123;id&#125;
             &lt;/if&gt;
             &lt;if test=&quot;lastName!=null &amp;amp;&amp;amp; lastName!=&amp;quot;&amp;quot;&quot;&gt;&lt;!--&amp;amp;&amp;amp;==&amp;&amp; &amp;quot;&amp;quot;=&quot;&quot; --&gt;
                 and last_name like #&#123;lastName&#125;
             &lt;/if&gt;
             &lt;if test=&quot;email!=null and email.trim()!=&amp;quot;&amp;quot;&quot;&gt;
                 and email=#&#123;email&#125;
             &lt;/if&gt; 
             &lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;
             &lt;if test=&quot;gender==0 or gender==1&quot;&gt;
                  and gender=#&#123;gender&#125;
             &lt;/if&gt;
         &lt;/where&gt;
     &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java"> public SqlSessionFactory getSqlSessionFactory() throws IOException &#123;
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        return new SqlSessionFactoryBuilder().build(inputStream);
    &#125;

    //测试if中的where标签
    @Test
    public void test1() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);
            Employee employee = new Employee(3,&quot;%c%&quot;,null,null);
            List&lt;Employee&gt; empsByConditionIf = mapper.getEmpsByConditionIf(employee);
            for (Employee employee1 : empsByConditionIf) &#123;
                System.out.println(employee1);
            &#125;
            //查询时某些条件没带sql拼装有问题
            //1.在where后面加上1=1
            //2.mybatis可以使用where标签来讲所有的查询条件包括在内
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<p>此时若将输入的id值置为null，你会发现sql语句拼接出了问题，所以我们可以使用trim标签</p>
<h3 id="1-3trim标签"><a href="#1-3trim标签" class="headerlink" title="1.3trim标签"></a>1.3trim标签</h3><pre><code class="xml">&lt;!--使用trim标签解决sql语句拼装的and的问题：and拼接在后面--&gt;
    &lt;!--public List&lt;Employee&gt; getEmpsByConditionTrim(Employee employee);  --&gt;
    &lt;select id=&quot;getEmpsByConditionTrim&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select * from tbl_employee
        &lt;!-- 后面多出的and或者or where标签不能解决
        prefix=&quot;&quot;:前缀：trim标签体中是整个字符串拼串 后的结果。
                prefix给拼串后的整个字符串加一个前缀
        prefixOverrides=&quot;&quot;:
                前缀覆盖： 去掉整个字符串前面多余的字符
        suffix=&quot;&quot;:后缀
                suffix给拼串后的整个字符串加一个后缀
        suffixOverrides=&quot;&quot;
                后缀覆盖：去掉整个字符串后面多余的字符

        --&gt;
        &lt;!-- 自定义字符串的截取规则 --&gt;
        &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt;
            &lt;if test=&quot;id!=null&quot;&gt;
                id=#&#123;id&#125; and
            &lt;/if&gt;
            &lt;if test=&quot;lastName!=null &amp;amp;&amp;amp; lastName!=&amp;quot;&amp;quot;&quot;&gt;
                last_name like #&#123;lastName&#125; and
            &lt;/if&gt;
            &lt;if test=&quot;email!=null and email.trim()!=&amp;quot;&amp;quot;&quot;&gt;
                email=#&#123;email&#125; and
            &lt;/if&gt;
            &lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;
            &lt;if test=&quot;gender==0 or gender==1&quot;&gt;
                gender=#&#123;gender&#125;
            &lt;/if&gt;
        &lt;/trim&gt;
    &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">//测试if中的trim标签，and放在后面
    @Test
    public void test2() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);
            Employee employee = new Employee(null,&quot;%c%&quot;,null,null);
            List&lt;Employee&gt; empsByConditionIf = mapper.getEmpsByConditionTrim(employee);
            for (Employee employee1 : empsByConditionIf) &#123;
                System.out.println(employee1);
            &#125;
            //查询时某些条件没带sql拼装有问题
            //1.在where后面加上1=1
            //2.mybatis可以使用where标签来讲所有的查询条件包括在内
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-4-choose标签使用"><a href="#1-4-choose标签使用" class="headerlink" title="1.4 choose标签使用"></a>1.4 choose标签使用</h3><pre><code class="xml">&lt;!--choose标签：如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个--&gt;
    &lt;!-- public List&lt;Employee&gt; getEmpsByConditionChoose(Employee employee); --&gt;
    &lt;select id=&quot;getEmpsByConditionChoose&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select * from tbl_employee
        &lt;where&gt;
            &lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 --&gt;
            &lt;choose&gt;
                &lt;when test=&quot;id!=null&quot;&gt;
                    id=#&#123;id&#125;
                &lt;/when&gt;
                &lt;when test=&quot;lastName!=null&quot;&gt;
                    last_name like #&#123;lastName&#125;
                &lt;/when&gt;
                &lt;when test=&quot;email!=null&quot;&gt;
                    email = #&#123;email&#125;
                &lt;/when&gt;
                &lt;otherwise&gt;
                    gender = 0
                &lt;/otherwise&gt;
            &lt;/choose&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java"> //测试choose标签
    @Test
    public void test3() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);
            Employee employee = new Employee(1,&quot;%c%&quot;,null,&quot;1&quot;);
            List&lt;Employee&gt; empsByConditionIf = mapper.getEmpsByConditionChoose(employee);
            for (Employee employee1 : empsByConditionIf) &#123;
                System.out.println(employee1);
            &#125;
            //查询时某些条件没带sql拼装有问题
            //1.在where后面加上1=1
            //2.mybatis可以使用where标签来讲所有的查询条件包括在内
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-5-set标签使用"><a href="#1-5-set标签使用" class="headerlink" title="1.5 set标签使用"></a>1.5 set标签使用</h3><pre><code class="xml">&lt;!--set更新操作，封装修改，传入哪一个参数更新哪一个--&gt;
    &lt;!--public void updateEmp(Employee employee);  --&gt;
    &lt;update id=&quot;updateEmp&quot;&gt;
        &lt;!-- Set标签的使用 ,后面多个逗号，加set标签可以去掉，加trim标签也可以--&gt;
        update tbl_employee
        &lt;set&gt;
            &lt;if test=&quot;lastName!=null&quot;&gt;
                last_name=#&#123;lastName&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;email!=null&quot;&gt;
                email=#&#123;email&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;gender!=null&quot;&gt;
                gender=#&#123;gender&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id=#&#123;id&#125;
        &lt;!--
                Trim：更新拼串
                update tbl_employee
                &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;
                    &lt;if test=&quot;lastName!=null&quot;&gt;
                        last_name=#&#123;lastName&#125;,
                    &lt;/if&gt;
                    &lt;if test=&quot;email!=null&quot;&gt;
                        email=#&#123;email&#125;,
                    &lt;/if&gt;
                    &lt;if test=&quot;gender!=null&quot;&gt;
                        gender=#&#123;gender&#125;
                    &lt;/if&gt;
                &lt;/trim&gt;
                where id=#&#123;id&#125;  --&gt;
    &lt;/update&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">//测试set标签
    @Test
    public void test4() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);
            Employee employee = new Employee(1,&quot;%c%&quot;,null,&quot;1&quot;);
            mapper.updateEmp(employee);
            //查询时某些条件没带sql拼装有问题
            //1.在where后面加上1=1
            //2.mybatis可以使用where标签来讲所有的查询条件包括在内
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-6-foreach标签"><a href="#1-6-foreach标签" class="headerlink" title="1.6 foreach标签"></a>1.6 foreach标签</h3><pre><code class="xml">&lt;!--foreach 遍历集合--&gt;
    &lt;!--public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids);  --&gt;
    &lt;select id=&quot;getEmpsByConditionForeach&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        &lt;!--
            collection：指定要遍历的集合：
                list类型的参数会特殊处理封装在map中，map的key就叫list
            item：将当前遍历出的元素赋值给指定的变量
            separator:每个元素之间的分隔符
            open：遍历出所有结果拼接一个开始的字符
            close:遍历出所有结果拼接一个结束的字符
            index:索引。遍历list的时候是index就是索引，item就是当前值
                          遍历map的时候index表示的就是map的key，item就是map的值

            #&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素
          --&gt;
        select * from tbl_employee
        &lt;foreach collection=&quot;ids&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;where id in(&quot; close=&quot;)&quot;&gt;
            #&#123;item_id&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java"> //测试foreach标签
    @Test
    public void test5() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);

            List&lt;Employee&gt; empsByConditionForeach = mapper.getEmpsByConditionForeach(Arrays.asList(1, 2, 3, 4));
            for (Employee byConditionForeach : empsByConditionForeach) &#123;
                System.out.println(byConditionForeach);
            &#125;
            //查询时某些条件没带sql拼装有问题
            //1.在where后面加上1=1
            //2.mybatis可以使用where标签来讲所有的查询条件包括在内
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<p><strong>foreach的批量保存</strong></p>
<pre><code class="xml">&lt;!--foreach批量保存--&gt;
    &lt;!-- 批量保存 --&gt;
    &lt;!--public void addEmps(@Param(&quot;emps&quot;)List&lt;Employee&gt; emps);  --&gt;
    &lt;!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法--&gt;
    &lt;insert id=&quot;addEmps&quot;&gt;
        insert into tbl_employee(last_name,email,gender)
        values
        &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;
            (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;&lt;!--   --&gt;

    &lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true；
         这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt;
     &lt;!--&lt;insert id=&quot;addEmps&quot;&gt;
        &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;
            insert into tbl_employee(last_name,email,gender)
            values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt; --&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">//测试foreach批量保存
    @Test
    public void test6() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);

            List&lt;Employee&gt; emps=new ArrayList&lt;&gt;();
            emps.add(new Employee(null,&quot;jerry&quot;,&quot;jerry@163.com&quot;,&quot;0&quot;));
            emps.add(new Employee(null,&quot;smith&quot;,&quot;smith@163.com&quot;,&quot;1&quot;));
            emps.add(new Employee(null,&quot;test&quot;,&quot;test@163.com&quot;,&quot;0&quot;));
            mapper.addEmps(emps);

            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-7-内置参数"><a href="#1-7-内置参数" class="headerlink" title="1.7 内置参数"></a>1.7 内置参数</h3><pre><code class="xml">&lt;!-- 两个内置参数：
         不只是方法传递过来的参数可以被用来判断，取值。。。
         mybatis默认还有两个内置参数：
         _parameter:代表整个参数
             单个参数：_parameter就是这个参数
             多个参数：参数会被封装为一个map；_parameter就是代表这个map

         _databaseId:如果配置了databaseIdProvider标签。
             _databaseId就是代表当前数据库的别名oracle
      --&gt;

    &lt;!--public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee);  --&gt;
    &lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        &lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 --&gt;
        &lt;bind name=&quot;_lastName&quot; value=&quot;&#39;%&#39;+lastName+&#39;%&#39;&quot;/&gt;
        &lt;if test=&quot;_databaseId==&#39;mysql&#39;&quot;&gt;
            select * from tbl_employee
            &lt;if test=&quot;_parameter!=null&quot;&gt;
                where last_name like #&#123;lastName&#125;
            &lt;/if&gt;
        &lt;/if&gt;
        &lt;if test=&quot;_databaseId==&#39;oracle&#39;&quot;&gt;
            select * from employees
            &lt;if test=&quot;_parameter!=null&quot;&gt;
                where last_name like #&#123;_parameter.lastName&#125;
            &lt;/if&gt;
        &lt;/if&gt;
    &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java"> //测试mybatis的两个内置参数_parameter和_databaseId
    @Test
    public void test7() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try &#123;
            EmployeeMapperDynamicSQL mapper = sqlSession.getMapper(EmployeeMapperDynamicSQL.class);

            Employee employee2 = new Employee();
            employee2.setLastName(&quot;%e%&quot;);
            List&lt;Employee&gt; list = mapper.getEmpsTestInnerParameter(employee2);
            for (Employee employee : list) &#123;
                System.out.println(employee);
            &#125;

            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis映射文件Select元素</title>
    <url>/2020/10/05/MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6Select%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="MyBatis映射文件Select元素"><a href="#MyBatis映射文件Select元素" class="headerlink" title="MyBatis映射文件Select元素"></a>MyBatis映射文件Select元素</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><p>Select元素来定义查询操作。</p>
<ul>
<li><p>Id：唯一标识符。 – 用来引用这条语句，需要和接口的方法名一致 </p>
</li>
<li><p>parameterType：参数类型。 – 可以不传，MyBatis会根据TypeHandler自动推断</p>
</li>
<li><p>resultType：返回值类型。 – 别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用</p>
</li>
</ul>
<p>使用：</p>
<p>第一种：返回的是一个List集合</p>
<pre><code class="xml">&lt;!-- public List&lt;Employee&gt; getEmpsByLastNameLike(String lastName); --&gt;
    &lt;!--resultType：如果返回的是一个集合，要写集合中元素的类型  --&gt;
    &lt;select id=&quot;getEmpsByLastNameLike&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select * from tbl_employee where last_name like #&#123;lastName&#125;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">@Test
    public void test05() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            mapper = sqlSession.getMapper(EmployeeMapper.class);
            List&lt;Employee&gt; like = mapper.getEmpsByLastNameLike(&quot;%e%&quot;);
            for (Employee employee : like) &#123;
                System.out.println(employee);
            &#125;
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<p>第二种：返回一条记录的Map</p>
<pre><code class="xml">&lt;!--public Map&lt;String, Object&gt; getEmpByIdReturnMap(Integer id);  --&gt;
     &lt;select id=&quot;getEmpByIdReturnMap&quot; resultType=&quot;map&quot;&gt;
         select * from tbl_employee where id=#&#123;id&#125;
     &lt;/select&gt;
</code></pre>
<pre><code class="java">@Test
    public void test05() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            mapper = sqlSession.getMapper(EmployeeMapper.class);
            Map&lt;String, Object&gt; map = mapper.getEmpByIdReturnMap(1);
            System.out.println(map);
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<p>第三种：返回多条记录的Map</p>
<pre><code class="java">//多条记录封装一个map：Map&lt;Integer,Employee&gt;:键是这条记录的主键，值是记录封装后的javaBean
    //@MapKey:告诉mybatis封装这个map的时候使用哪个属性作为map的key
    @MapKey(&quot;lastName&quot;)
    public Map&lt;String, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName);
</code></pre>
<pre><code class="xml">&lt;!--public Map&lt;String, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName);  --&gt;
     &lt;select id=&quot;getEmpByLastNameLikeReturnMap&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
         select * from tbl_employee where last_name like #&#123;lastName&#125;
     &lt;/select&gt;
</code></pre>
<pre><code class="java">@Test
    public void test05() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            Map&lt;String, Employee&gt; map = mapper.getEmpByLastNameLikeReturnMap(&quot;%r%&quot;);
            System.out.println(map);
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-2-resultMap使用"><a href="#1-2-resultMap使用" class="headerlink" title="1.2 resultMap使用"></a>1.2 resultMap使用</h3><p><code>resultMap</code>，实现高级结果集映射</p>
<p>之前讲过数据库字段名和javabean属性名不对应，则取不出数据，解决方法有设置开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true。此设置可以使数据库字段名为last_name映射为javabean的lastName</p>
<p>现在使用resultMap实现高级结果集映射，首先在mapper文件中自定义resultMap的封装规则</p>
<pre><code class="xml">&lt;!--自定义某个javaBean的封装规则
    type：自定义规则的Java类型
    id:唯一id方便引用
      --&gt;
    &lt;resultMap type=&quot;com.review.mybatis.bean.Employee&quot; id=&quot;MySimpleEmp&quot;&gt;
        &lt;!--指定主键列的封装规则
        id定义主键会底层有优化；
        column：指定哪一列
        property：指定对应的javaBean属性
          --&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        
        &lt;!-- 定义普通列封装规则 --&gt;
        &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
        &lt;!-- 其他不指定的列会自动封装：我们只要写resultMap就把全部的映射规则都写上。 --&gt;
        &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
        &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
    &lt;/resultMap&gt;

&lt;!--然后使用resultMap执行sql语句--&gt;
&lt;!-- resultMap:自定义结果集映射规则；  --&gt;
    &lt;!-- public Employee getEmpById(Integer id); --&gt;
    &lt;select id=&quot;getEmpById&quot;  resultMap=&quot;MySimpleEmp&quot;&gt;
        select * from tbl_employee where id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<p>注意：resultMap和resultType只能使用一个，二选一</p>
<h3 id="1-3-resultMap关联查询"><a href="#1-3-resultMap关联查询" class="headerlink" title="1.3 resultMap关联查询"></a>1.3 resultMap关联查询</h3><p>查询Employee的同时查询员工对应的部门：Employee===Department<br> 一个员工有与之对应的部门信息； id  last_name  gender    d_id     did  dept_name (private Department dept;)</p>
<p><img src="/2020/10/05/MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6Select%E5%85%83%E7%B4%A0/employee.jpg" alt="employee"></p>
<p><img src="/2020/10/05/MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6Select%E5%85%83%E7%B4%A0/dept.jpg" alt="employee"></p>
<pre><code class="java">public class Employee &#123;
    private Integer id;
    private String lastName;
    private String email;
    private String gender;
    private Department dept;
&#125;
</code></pre>
<p>mapper映射文件</p>
<pre><code class="xml">&lt;!--
        联合查询：级联属性封装结果集
id  last_name  gender    d_id     did  dept_name (private Department dept;)
      --&gt;
    &lt;resultMap type=&quot;com.review.mybatis.bean.Employee&quot; id=&quot;MyDifEmp&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
        &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
        &lt;result column=&quot;did&quot; property=&quot;dept.id&quot;/&gt;
        &lt;result column=&quot;dept_name&quot; property=&quot;dept.departmentName&quot;/&gt;
    &lt;/resultMap&gt;
&lt;!--  public Employee getEmpAndDept(Integer id);--&gt;
    &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;MyDifEmp&quot;&gt;
        SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,
        d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d
        WHERE e.d_id=d.id AND e.id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<h3 id="1-4-association的使用"><a href="#1-4-association的使用" class="headerlink" title="1.4 association的使用"></a>1.4 association的使用</h3><p>另一种关联方式</p>
<pre><code class="xml">&lt;!-- 
        使用association定义关联的单个对象的封装规则；
     --&gt;
    &lt;resultMap type=&quot;com.review.mybatis.bean.Employee&quot; id=&quot;MyDifEmp2&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
        &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
        
        &lt;!--  association可以指定联合的javaBean对象
        property=&quot;dept&quot;：指定哪个属性是联合的对象
        javaType:指定这个属性对象的类型[不能省略]
        --&gt;
        &lt;association property=&quot;dept&quot; javaType=&quot;com.review.mybatis.bean.Department&quot;&gt;
            &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;!--  public Employee getEmpAndDept(Integer id);--&gt;
    &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;MyDifEmp&quot;&gt;
        SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,
        d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d
        WHERE e.d_id=d.id AND e.id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<p>分步查询</p>
<p>departmentMapper映射文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.review.mybatis.dao.DepartmentMapper&quot;&gt;
    &lt;!--public Department getDeptById(Integer id);  --&gt;
    &lt;select id=&quot;getDeptById&quot; resultType=&quot;com.review.mybatis.bean.Department&quot;&gt;
        select id,dept_name departmentName from tbl_dept where id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<pre><code class="xml">&lt;!-- 使用association进行分步查询：
        1、先按照员工id查询员工信息
        2、根据查询员工信息中的d_id值去部门表查出部门信息
        3、部门设置到员工中；
     --&gt;
     
     &lt;!--  id  last_name  email   gender    d_id   --&gt;
     &lt;resultMap type=&quot;com.review.mybatis.bean.Employee&quot; id=&quot;MyEmpByStep&quot;&gt;
         &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
         &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
         &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
         &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
         &lt;!-- association定义关联对象的封装规则
             select:表明当前属性是调用select指定的方法查出的结果
             column:指定将哪一列的值传给这个方法
             流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性
          --&gt;
         &lt;association property=&quot;dept&quot; 
             select=&quot;com.review.mybatis.dao.DepartmentMapper.getDeptById&quot;
             column=&quot;d_id&quot;&gt;
         &lt;/association&gt;
     &lt;/resultMap&gt;
     &lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;
     &lt;select id=&quot;getEmpByIdStep&quot; resultMap=&quot;MyEmpByStep&quot;&gt;
         select * from tbl_employee where id=#&#123;id&#125;
         &lt;if test=&quot;_parameter!=null&quot;&gt;
             and 1=1
         &lt;/if&gt;
     &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
    public void test06() throws IOException&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession openSession = sqlSessionFactory.openSession();
        try&#123;
            EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);
            Employee employee = mapper.getEmpByIdStep(3);
            System.out.println(employee);
            System.out.println(employee.getDept());
        &#125;finally&#123;
            openSession.close();
        &#125;
    &#125;
</code></pre>
<p>分步查询可以使用延迟加载</p>
<p>可以使用延迟加载（懒加载）；(按需加载)</p>
<p>Employee==&gt;Dept：</p>
<p>我们每次查询Employee对象的时候，都将一起查询出来。</p>
<p>部门信息在我们使用的时候再去查询；</p>
<p>分段查询的基础之上加上两个配置：在mybatis的配置文件中设置</p>
<pre><code class="xml">&lt;settings&gt;
        &lt;!-- &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; --&gt;
        &lt;!-- &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt; --&gt;
        
        &lt;!--显示的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题  --&gt;
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
    &lt;/settings&gt;
</code></pre>
<h3 id="1-5-关联集合封装规则"><a href="#1-5-关联集合封装规则" class="headerlink" title="1.5 关联集合封装规则"></a>1.5 关联集合封装规则</h3><p>查询部门的时候将部门对应的所有员工信息也查询出来：注释在DepartmentMapper.xml中</p>
<pre><code class="xml">&lt;!-- 
    public class Department &#123;
            private Integer id;
            private String departmentName;
            private List&lt;Employee&gt; emps;
      did  dept_name  ||  eid  last_name  email   gender  
     --&gt;
</code></pre>
<p>如何封装集合List<Employee></Employee></p>
<pre><code class="xml">&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则  --&gt;
    &lt;resultMap type=&quot;com.review.mybatis.bean.Department&quot; id=&quot;MyDept&quot;&gt;
        &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt;
        &lt;!-- 
            collection定义关联集合类型的属性的封装规则 
            ofType:指定集合里面元素的类型
        --&gt;
        &lt;collection property=&quot;emps&quot; ofType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
            &lt;!-- 定义这个集合中元素的封装规则 --&gt;
            &lt;!--did  dept_name  ||  eid  last_name  email   gender --&gt;
            &lt;id column=&quot;eid&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
            &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
            &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;!-- public Department getDeptByIdPlus(Integer id); --&gt;
    &lt;select id=&quot;getDeptByIdPlus&quot; resultMap=&quot;MyDept&quot;&gt;
        SELECT d.id did,d.dept_name dept_name,
                e.id eid,e.last_name last_name,e.email email,e.gender gender
        FROM tbl_dept d
        LEFT JOIN tbl_employee e
        ON d.id=e.d_id
        WHERE d.id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<h3 id="1-6-鉴别器"><a href="#1-6-鉴别器" class="headerlink" title="1.6 鉴别器"></a>1.6 鉴别器</h3><pre><code class="xml">&lt;!-- &lt;discriminator javaType=&quot;&quot;&gt;&lt;/discriminator&gt;
        鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为
        封装Employee：
            如果查出的是女生：就把部门信息查询出来，否则不查询；
            如果是男生，把last_name这一列的值赋值给email;
     --&gt;
     &lt;resultMap type=&quot;com.review.mybatis.bean.Employee&quot; id=&quot;MyEmpDis&quot;&gt;
         &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
         &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
         &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;
         &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
         &lt;!--
             column：指定判定的列名
             javaType：列值对应的java类型  --&gt;
         &lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt;
             &lt;!--女生  resultType:指定封装的结果类型；不能缺少。/resultMap--&gt;
             &lt;case value=&quot;0&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
                 &lt;association property=&quot;dept&quot; 
                     select=&quot;com.review.mybatis.dao.DepartmentMapper.getDeptById&quot;
                     column=&quot;d_id&quot;&gt;
                 &lt;/association&gt;
             &lt;/case&gt;
             &lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt;
             &lt;case value=&quot;1&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
                 &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
                 &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
                 &lt;result column=&quot;last_name&quot; property=&quot;email&quot;/&gt;
                 &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
             &lt;/case&gt;
         &lt;/discriminator&gt;
     &lt;/resultMap&gt;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis缓存</title>
    <url>/2020/10/07/MyBatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>MyBatis 包含一个非常强大的查询缓存特性,它可以非 常方便地配置和定制。缓存可以极大的提升查询效率。</p>
<p>MyBatis系统中默认定义了两级缓存。 </p>
<p>一级缓存和二级缓存。</p>
<ul>
<li><p>默认情况下，只有一级缓存（SqlSession级别的缓存， 也称为本地缓存）开启。</p>
</li>
<li><p>二级缓存需要手动开启和配置，他是基于namespace级 别的缓存。</p>
</li>
<li><p>为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p>
</li>
</ul>
<h3 id="1-2-一级缓存"><a href="#1-2-一级缓存" class="headerlink" title="1.2 一级缓存"></a>1.2 一级缓存</h3><p>一级缓存(local cache), 即本地缓存, 作用域默认 为sqlSession。</p>
<p>当 Session flush 或 close 后, 该 Session 中的所有 Cache 将被清空。 </p>
<p>本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域</p>
<p>在mybatis3.1之后, 可以配置本地缓存的作用域. 在 mybatis.xml 中配置</p>
<p>一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；SqlSession级别的一个Map<br>与数据库同一次会话期间查询到的数据会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；</p>
<p><strong>一级缓存失效情况</strong>（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）：</p>
<ul>
<li>sqlSession不同。</li>
<li>sqlSession相同，查询条件不同.(当前一级缓存中还没有这个数据)</li>
<li>sqlSession相同，两次查询之间执行了增删改操作(这次增删改可能对当前数据有影响)</li>
<li>sqlSession相同，手动清除了一级缓存（缓存清空）</li>
</ul>
<p>一级缓存默认开启，一直存在</p>
<pre><code class="java"> @Test
    public void testSecondLevelCache02() throws IOException&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession openSession = sqlSessionFactory.openSession();
        try&#123;
            //只要是同一个sqlsession，查询相同的语句，就是一级缓存
            DepartmentMapper mapper = openSession.getMapper(DepartmentMapper.class);
            Department deptById = mapper.getDeptById(1);
            Department deptById2 = mapper.getDeptById(1);
            System.out.println(deptById);
               System.out.println(deptById2);
            System.out.println(deptById2==deptById);//true          

        &#125;finally&#123;
             openSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-2-二级缓存"><a href="#1-2-二级缓存" class="headerlink" title="1.2 二级缓存"></a>1.2 二级缓存</h3><p>二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存：</p>
<ul>
<li><p>工作机制：</p>
<ul>
<li>一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
</ul>
</li>
<li><p>如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；</p>
<ul>
<li>不同namespace查出的数据会放在自己对应的缓存中（map）</li>
</ul>
</li>
<li><p>效果：</p>
<ul>
<li>数据会从二级缓存中获取</li>
<li>查出的数据都会被默认先放在一级缓存中。</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ul>
<p><strong>使用</strong>：</p>
<ol>
<li><p>开启全局二级缓存配置(在mybatis-config.xml中)：</p>
<pre><code class="xml">&lt;settings&gt;
        &lt;!--开启驼峰命名法--&gt;
      &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;/settings&gt;
</code></pre>
</li>
<li><p>去mapper.xml中配置使用二级缓存：</p>
</li>
</ol>
<pre><code class="xml">&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
    &lt;cache&gt;&lt;/cache&gt;
   &lt;!--public Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName);  --&gt;
     &lt;select id=&quot;getEmpByLastNameLikeReturnMap&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
       select * from tbl_employee where last_name like #&#123;lastName&#125;
     &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ol start="3">
<li>我们的POJO需要实现序列化接口Serializable</li>
</ol>
<pre><code class="java">public class Department implements Serializable&#123;
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String departmentName;
    private List&lt;Employee&gt; emps;
&#125;
</code></pre>
</li>
</ul>
<h3 id="1-3-和缓存有关的设置"><a href="#1-3-和缓存有关的设置" class="headerlink" title="1.3 和缓存有关的设置"></a>1.3 和缓存有关的设置</h3><p>和缓存有关的设置/属性：</p>
<ul>
<li>cacheEnabled=true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用的)（在全局配置文件中）</li>
</ul>
<pre><code class="xml">&lt;settings&gt;
        &lt;!--开启驼峰命名法--&gt;
         &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
     &lt;/settings&gt;
</code></pre>
<ul>
<li>每个select标签都有useCache=”true”：false：不使用缓存（一级缓存依然使用，二级缓存不使用）（在mapper文件中）</li>
</ul>
<pre><code class="xml">&lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;
        databaseId=&quot;mysql&quot; useCache=&quot;true&quot;&gt;
        select * from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<ul>
<li>【每个增删改标签的：flushCache=”true”：（一级二级都会清除）】增删改执行完成后就会清楚缓存；</li>
</ul>
<pre><code class="xml">&lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.review.mybatis.bean.Employee&quot;
        useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; databaseId=&quot;mysql&quot;
        flushCache=&quot;true&quot;&gt;
        insert into tbl_employee(last_name,email,gender) 
        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)
    &lt;/insert&gt;
</code></pre>
<ul>
<li>flushCache=”true”：一级缓存就清空了；二级也会被清除；</li>
<li>如果flushCache=true;每次查询之后都会清空缓存；缓存是没有被使用的；</li>
<li>sqlSession.clearCache();只是清除当前session的一级缓存；</li>
</ul>
<pre><code class="java">@Test
    public void testFirstLevelCache() throws IOException&#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        SqlSession openSession = sqlSessionFactory.openSession();
        try&#123;
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            Employee emp01 = mapper.getEmpById(1);
            System.out.println(emp01);

            //4、sqlSession相同，手动清除了一级缓存（缓存清空）
            openSession.clearCache();

            Employee emp02 = mapper.getEmpById(1);
            //Employee emp03 = mapper.getEmpById(3);
            System.out.println(emp02);
            //System.out.println(emp03);
            System.out.println(emp01==emp02);

            //openSession2.close();
        &#125;finally&#123;
            openSession.close();
        &#125;
    &#125;
</code></pre>
<ul>
<li>localCacheScope：本地缓存作用域(在全局配置文件的setting中设置，很少设置)：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中；STATEMENT：可以禁用一级缓存；</li>
</ul>
<p>在mapper文件中的cache设置</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt;
    &lt;!--  
    eviction:缓存的回收策略：
        • LRU – 最近最少使用的：移除最长时间不被使用的对象。
        • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
        • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
        • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
        • 默认的是 LRU。
    flushInterval：缓存刷新间隔
        缓存多长时间清空一次，默认不清空，设置一个毫秒值
    readOnly:是否只读：
        true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。
                 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快
        false：非只读：mybatis觉得获取的数据可能会被修改。
                mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢
    size：缓存存放多少元素；
    type=&quot;&quot;：指定自定义缓存的全类名；
            实现Cache接口即可；
    --&gt;
    &lt;select id=&quot;getEmpByLastNameLikeReturnMap&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
         select * from tbl_employee where last_name like #&#123;lastName&#125;
     &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="1-4-第三方缓存整合"><a href="#1-4-第三方缓存整合" class="headerlink" title="1.4 第三方缓存整合"></a>1.4 第三方缓存整合</h3><p>第三方缓存整合：</p>
<ul>
<li><p>导入第三方缓存包即可；</p>
</li>
<li><p>导入与第三方缓存整合的适配包；官方有；</p>
</li>
<li><p>mapper.xml中使用自定义缓存 <cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Request&amp;Response</title>
    <url>/2020/09/22/Request&amp;Response/</url>
    <content><![CDATA[<h2 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h2><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="1-1-HttpServletRequest类"><a href="#1-1-HttpServletRequest类" class="headerlink" title="1.1 HttpServletRequest类"></a>1.1 HttpServletRequest类</h3><ul>
<li><p>作用</p>
<p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的 信息。</p>
</li>
</ul>
<h3 id="1-2-HttpServletRequest类方法"><a href="#1-2-HttpServletRequest类方法" class="headerlink" title="1.2 HttpServletRequest类方法"></a>1.2 HttpServletRequest类方法</h3><ul>
<li><code>getRequestURI()</code> 获取请求的资源路径</li>
<li><code>getRequestURL()</code> 获取请求的统一资源定位符（绝对路径）</li>
<li><code>getRemoteHost()</code> 获取客户端的 ip 地址 </li>
<li><code>getHeader()</code> 获取请求头 </li>
<li><code>getParameter()</code> 获取请求的参数 </li>
<li><code>getParameterValues()</code> 获取请求的参数（多个值的时候使用）</li>
<li><code>getMethod()</code> 获取请求的方式 GET 或 POST</li>
<li><code>setAttribute(key, value)</code> 设置域数据 </li>
<li><code>getAttribute(key)</code> 获取域数据</li>
<li><code>getRequestDispatcher()</code> 获取请求转发对象</li>
</ul>
<pre><code class="java"> protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        /*
        1. 获取请求方式 ：GET
            * String getMethod()
        2. (*)获取虚拟目录：/09_Request
            * String getContextPath()
        3. 获取Servlet路径: /RequestDemo1
            * String getServletPath()
        4. 获取get方式请求参数：username=aaa
            * String getQueryString()
        5. (*)获取请求URI：/09_Request/RequestDemo1
            * String getRequestURI():        /09_Request/RequestDemo1
            * StringBuffer getRequestURL()  :http://localhost//09_Request/RequestDemo1

            * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国
            * URI：统一资源标识符 : /day14/demo1                    共和国
        6. 获取协议及版本：HTTP/1.1
            * String getProtocol()

        7. 获取客户机的IP地址：
            * String getRemoteHost()
         */
        //1. 获取请求方式 ：GET
        String method = request.getMethod();
        System.out.println(method);//GET
        //2. 获取虚拟目录：
        String contextPath = request.getContextPath();
        System.out.println(contextPath);///09_Request_war_exploded
        //3. 获取Servlet路径:
        String servletPath = request.getServletPath();
        System.out.println(servletPath);///RequestDemo1
        // 4. 获取get方式请求参数
        String queryString = request.getQueryString();
        System.out.println(queryString);//null
        //5. (*)获取请求URI：
        String requestURI = request.getRequestURI();
        System.out.println(requestURI);//  /09_Request_war_exploded/RequestDemo1
        StringBuffer requestURL = request.getRequestURL();
        System.out.println(requestURL);//  http://localhost:8080/09_Request_war_exploded/RequestDemo1
        //6. 获取协议及版本
        String protocol = request.getProtocol();
        System.out.println(protocol);//HTTP/1.1
        // 7. 获取客户机的IP地址：
        String remoteAddr = request.getRemoteHost();
        System.out.println(remoteAddr);//127.0.0.1,ipv6的结果为0:0:0:0:0:0:0:1
         //8. 获取请求头，请求头都是键值对，输入键，获取值
         String header = request.getHeader(&quot;User-Agent&quot;);
        System.out.println(header);//Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36
    &#125;
</code></pre>
<p><strong>客户端发送请求，服务器获取请求参数</strong></p>
<p><strong>涉及的方法</strong></p>
<ul>
<li><code>String getParameter(String name)</code>:根据参数名称获取参数值    username=zs&amp;password=123</li>
<li><code>String[] getParameterValues(String name)</code>:根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code>:获取所有请求的参数名称</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code>:获取所有参数的map集合</li>
</ul>
<p>客户端发送请求参数内容</p>
<pre><code class="html">&lt;body&gt;
    &lt;form action=&quot;http://localhost:8080/07_servlet/parameterServlet&quot; method=&quot;post&quot;&gt;
        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;
        兴趣爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;C++
        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java
        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;JavaScript&lt;br/&gt;
        &lt;input type=&quot;submit&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<p>服务器获取请求参数，在doGet或doPost中获取都可以，但是当获取到的参数中有中文时，会出现中文乱码问题</p>
<p>get方式：tomcat 8 已经将get方式乱码问题解决了</p>
<p>post方式：会乱码</p>
<p>解决：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></p>
<pre><code class="java">@Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;-------------doGet------------&quot;);

        // 获取请求参数
        String username = req.getParameter(&quot;username&quot;);
        
        //tomcat8以前，解决乱码方法
        //1 先以iso8859-1进行编码
        //2 再以utf-8进行解码
        username = new String(username.getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;);

        String password = req.getParameter(&quot;password&quot;);
        String[] hobby = req.getParameterValues(&quot;hobby&quot;);

        System.out.println(&quot;用户名：&quot; + username);
        System.out.println(&quot;密码：&quot; + password);
        System.out.println(&quot;兴趣爱好：&quot; + Arrays.asList(hobby));
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 设置请求体的字符集为UTF-8，从而解决post请求的中文乱码问题
        // 也要在获取请求参数之前调用才有效
        req.setCharacterEncoding(&quot;UTF-8&quot;);

        System.out.println(&quot;-------------doPost------------&quot;);
        // 获取请求参数
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        String[] hobby = req.getParameterValues(&quot;hobby&quot;);

        System.out.println(&quot;用户名：&quot; + username);
        System.out.println(&quot;密码：&quot; + password);
        System.out.println(&quot;兴趣爱好：&quot; + Arrays.asList(hobby));//[cpp, java, js]
    &#125;
</code></pre>
<h3 id="1-3-请求转发-forward"><a href="#1-3-请求转发-forward" class="headerlink" title="1.3 请求转发(forward)"></a>1.3 请求转发(forward)</h3><ul>
<li>请求转发是指服务器收到请求后，从一个资源跳转到另一个资源的操作叫请求转发。</li>
</ul>
<p><img src="/2020/09/22/Request&Response/image-20200909151152974.png" alt="image-20200909151152974"></p>
<p><strong>方法</strong></p>
<ul>
<li><p>通过request对象获取请求转发器对象：<code>RequestDispatcher getRequestDispatcher(String path)</code></p>
</li>
<li><p>使用RequestDispatcher对象来进行转发：<code>forward(ServletRequest request, ServletResponse response)</code> </p>
</li>
</ul>
<p>代码流程：从Servlet1到Servlet2</p>
<pre><code class="java">public class Servlet1 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 获取请求的参数，查看
        String username = req.getParameter(&quot;username&quot;);
        System.out.println(&quot;在Servlet1（柜台1）中查看参数：&quot; + username);
        // Servlet1 加一些数据，并传递到Servlet2（柜台 2）去查看
        req.setAttribute(&quot;key1&quot;,&quot;柜台1的数据&quot;);//ServletContext也有这个方法，也可以在别的servlet查看

        // 问路：Servlet2（柜台 2）怎么走
        /**
         * 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到IDEA代码的web目录&lt;br/&gt;
         *
         */
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;);//指引到servlet2
        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.baidu.com&quot;);//不能跳出栈，转发不到百度
        //当有文件处于WEB-INF目录下，浏览器直接输入http://localhost:8080/Servlet_war_exploded/WEB-INF/a.html
        //访问不到，但是请求转发可以访问到WEB-INF下的文件
        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/WEB-INF/servlet2&quot;);
        // 走向Sevlet2（柜台 2）
        requestDispatcher.forward(req,resp);//这个req,resp传递到servlet2的request和response
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Servlet2 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        // 获取请求的参数，查看
        String username = req.getParameter(&quot;username&quot;);
        System.out.println(&quot;在Servlet2（柜台2）中查看参数：&quot; + username);

        // 查看 柜台1 是否有数据
        Object key1 = req.getAttribute(&quot;key1&quot;);
        System.out.println(&quot;柜台1是否有数据：&quot; + key1);

        // 处理自己的业务
        System.out.println(&quot;Servlet2 处理自己的业务 &quot;);
    &#125;
&#125;
</code></pre>
<h3 id="1-4-斜杠在web中的含义"><a href="#1-4-斜杠在web中的含义" class="headerlink" title="1.4 /斜杠在web中的含义"></a>1.4 /斜杠在web中的含义</h3><p><strong>在 web 中 / 斜杠 是一种绝对路径。</strong></p>
<ul>
<li>/ 斜杠 如果被浏览器解析，得到的地址是：<a href="http://ip:port/">http://ip:port/</a></li>
</ul>
<pre><code class="html">&lt;a href=&quot;/&quot;&gt;斜杠&lt;/a&gt;&lt;!--点击斜杠超链接，直接到http://localhost:8080/--&gt;
</code></pre>
<ul>
<li>/ 斜杠 如果被服务器解析，得到的地址是：<a href="http://ip:port/工程路径">http://ip:port/工程路径</a> <ul>
<li><url-pattern>/servlet1</url-pattern> 相当于<code>@WebServlet(&quot;/servlet1&quot;)</code>=<code>http://ip:port/工程路径/servlet1</code></li>
<li><code>servletContext.getRealPath(“/”);</code> </li>
<li><code>request.getRequestDispatcher(“/”);</code></li>
<li><strong>特殊情况</strong>： <code>response.sendRediect(“/”);</code> 把斜杠发送给浏览器解析。得到 <a href="http://ip:port/">http://ip:port/</a></li>
</ul>
</li>
</ul>
<h4 id="html中base标签"><a href="#html中base标签" class="headerlink" title="html中base标签"></a>html中base标签</h4><pre><code class="html">&lt;body&gt;
    这是Web下的index.html &lt;br/&gt;
    &lt;a href=&quot;a/b/c.html&quot;&gt;跳转&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;http://localhost:8080/07_servlet/forwardC&quot;&gt;请求转发：a/b/c.html&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;/&quot;&gt;斜杠&lt;/a&gt;
&lt;/body&gt;
</code></pre>
<p>进入到此页面点击按钮，可以直接根据超链接到c.html页面</p>
<pre><code class="html">&lt;body&gt;
    这是a下的b下的c.html页面&lt;br/&gt;
    &lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;
</code></pre>
<p>然后点击c页面的调回首页则可以成功调回首页，因为此时路径为 <a href="http://localhost:8080/Servlet_war_exploded/a/b/c.html">http://localhost:8080/Servlet_war_exploded/a/b/c.html</a> 根据相对路径../../向上跳两级则可以回到首页</p>
<p>如果是请求转发方式跳到c页面，先经过服务器处理转发到c页面</p>
<pre><code class="java">public class ForwardC extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;经过了ForwardC程序&quot;);
        req.getRequestDispatcher(&quot;/a/b/c.html&quot;).forward(req, resp);
    &#125;
&#125;
</code></pre>
<p>此时到达c页面是地址为 <a href="http://localhost:8080/Servlet_war_exploded/forward">http://localhost:8080/Servlet_war_exploded/forward</a>  此时再点击首页根据相对路径则跳不回来</p>
<p><strong>base</strong>标签作用，添加base标签后不论是哪种方式到c页面，c页面的../../只会根据base标签中的绝对路径来跳转</p>
<pre><code class="html">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--base标签设置页面相对路径工作时参照的地址
            href 属性就是参数的地址值
    --&gt;
    &lt;base href=&quot;http://localhost:8080/Servlet_war_exploded/a/b/&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    这是a下的b下的c.html页面&lt;br/&gt;
    &lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="1-1-HttpServletResponse-类"><a href="#1-1-HttpServletResponse-类" class="headerlink" title="1.1 HttpServletResponse 类"></a>1.1 HttpServletResponse 类</h3><ul>
<li><p>作用</p>
<p><code>HttpServletResponse</code> 类和 <code>HttpServletRequest</code> 类一样。每次请求进来，Tomcat 服务器都会创建一个 <code>Response</code> 对象传递给 Servlet 程序去使用。</p>
<p><code>HttpServletRequest</code> 表示请求过来的信息，<code>HttpServletResponse</code> 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 <code>HttpServletResponse</code> 对象来进行设置</p>
</li>
</ul>
<h3 id="1-2-HttpServletResponse-类方法"><a href="#1-2-HttpServletResponse-类方法" class="headerlink" title="1.2 HttpServletResponse 类方法"></a>1.2 HttpServletResponse 类方法</h3><ul>
<li>设置响应头：<code>setHeader(String name, String value)</code> </li>
<li>设置响应体：<ul>
<li>字符输出流：<code>PrintWriter getWriter()</code>  常用于回传字符串（常用）</li>
<li>字节输出流：<code>ServletOutputStream getOutputStream()</code>  常用于下载（传递二进制数据） </li>
<li>两个流同时只能使用一个。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/Request&Response/image-20200909164454444.png" alt="image-20200909164454444"></p>
<p><strong>向客户端回传数据</strong></p>
<p>用字符流需要解决中文乱码问题，服务器默认是iso-8859-1，需要将服务器设置为utf-8，浏览器也为utf-8</p>
<pre><code class="java">public class ResponseIOServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

//        System.out.println( resp.getCharacterEncoding() );//默认ISO-8859-1

//        resp.getWriter();
//        resp.getOutputStream();
//        // 设置服务器字符集为UTF-8
//        resp.setCharacterEncoding(&quot;UTF-8&quot;);
//        // 通过响应头，设置浏览器也使用UTF-8字符集
//        resp.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;);

        // 它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头
        // 此方法一定要在获取流对象之前调用才有效
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
//        要求 ： 往客户端回传 字符串 数据。
        PrintWriter writer = resp.getWriter();
        writer.write(&quot;你好！&quot;);
        
        //字节流方式，没有设置编码格式，设置之后会出现乱码
        //ServletOutputStream outputStream = resp.getOutputStream();
        //输出数据
        //outputStream.write(&quot;你好&quot;.getBytes());
    &#125;
&#125;
</code></pre>
<h3 id="1-3-请求重定向-redirect"><a href="#1-3-请求重定向-redirect" class="headerlink" title="1.3 请求重定向(redirect)"></a>1.3 请求重定向(redirect)</h3><ul>
<li>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。</li>
</ul>
<p><img src="/2020/09/22/Request&Response/image-20200909171328904.png" alt="image-20200909171328904"></p>
<ul>
<li>请求重定向的第一种方案： <ul>
<li>// 设 置 响 应 状 态 码 302， 表 示 重 定 向 ， （ 已 搬 迁 ） <ul>
<li><code>resp.setStatus(302);</code> </li>
</ul>
</li>
<li>// 设 置 响 应 头 ， 说 明 新 的 地 址 在 哪 里 <ul>
<li><code>resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li>请求重定向的第二种方案（推荐使用）：<ul>
<li><code>resp.sendRedirect(&quot;http://localhost:8080&quot;);</code></li>
</ul>
</li>
</ul>
<pre><code class="java">public class Response1 extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(&quot;曾到此一游 Response1 &quot;);

        req.setAttribute(&quot;key1&quot;, &quot;value1&quot;);

        // 设置响应状态码302 ，表示重定向，（已搬迁）
//        resp.setStatus(302);
        // 设置响应头，说明 新的地址在哪里
//        resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080/Servlet_war_exploded/response2&quot;);
//        resp.setHeader(&quot;Location&quot;, &quot;http://www.baidu.com&quot;);//访问工程外的资源

        //简单方式直接重定向
        resp.sendRedirect(&quot;http://localhost:8080&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Response2 extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        System.out.println(req.getAttribute(&quot;key1&quot;));//null 拿不到值，不是同一个请求，不在一个request域
        resp.getWriter().write(&quot;response2&#39;s result!&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP&amp; AspectJ基本使用</title>
    <url>/2020/10/01/Spring%20AOP&amp;%20AspectJ%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Spring-AOP-amp-AspectJ基本使用"><a href="#Spring-AOP-amp-AspectJ基本使用" class="headerlink" title="Spring AOP&amp; AspectJ基本使用"></a>Spring AOP&amp; AspectJ基本使用</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>什么是 AOP </p>
<ul>
<li><p>面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</li>
<li><p>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 </p>
</li>
</ul>
<h3 id="1-2-AOP底层原理"><a href="#1-2-AOP底层原理" class="headerlink" title="1.2 AOP底层原理"></a>1.2 AOP底层原理</h3><p>AOP 底层使用动态代理，动态代理有两种情况 </p>
<p><strong>第一种</strong> 有接口情况，使用 JDK 动态代理， 创建接口实现类代理对象，增强类的方法</p>
<p><strong>第二种</strong> 没有接口情况，使用 CGLIB 动态代理 ，创建子类的代理对象，增强类的方法</p>
<p>![图4](./Spring AOP&amp; AspectJ基本使用/图4.png)</p>
<h3 id="1-3-JDK动态代理"><a href="#1-3-JDK动态代理" class="headerlink" title="1.3 JDK动态代理"></a>1.3 JDK动态代理</h3><p>使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p>
<p>创建接口以及接口实现类</p>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public int add(int a, int b) &#123;
        return a+b;
    &#125;

    @Override
    public String update(String id) &#123;
        return id;
    &#125;
&#125;
</code></pre>
<p>使用Proxy类创建接口的代理对象</p>
<pre><code class="java">public class JDKProxy &#123;
    public static void main(String[] args) &#123;
        //创建接口实现类代理对象
        Class[] interfaces = &#123;UserDao.class&#125;;
        UserDaoImpl userDao = new UserDaoImpl();
        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));
        int result = dao.add(1, 2);
        System.out.println(&quot;result:&quot; + result);
    &#125;

&#125;
//创建代理对象代码
class UserDaoProxy implements InvocationHandler &#123;
    //1 把创建的是谁的代理对象，把谁传递过来
    //有参数构造传递
    private Object obj;
    public UserDaoProxy(Object obj) &#123;
        this.obj = obj;
    &#125;
    //增强的逻辑
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws
            Throwable &#123;
        //方法之前
        System.out.println(&quot;方法之前执行....&quot;+method.getName()+&quot; :传递的参数...&quot;+ Arrays.toString(args));
        //被增强的方法执行
        Object res = method.invoke(obj, args);
        //方法之后
        System.out.println(&quot;方法之后执行....&quot;+obj);
        return res;
    &#125;
&#125;
</code></pre>
<h3 id="1-4-AOP术语"><a href="#1-4-AOP术语" class="headerlink" title="1.4 AOP术语"></a>1.4 AOP术语</h3><ol>
<li>连接点<ul>
<li>类里面哪些方法可以被增强，这些方法称为连接点</li>
</ul>
</li>
<li>切入点<ul>
<li>类里面的某一个方法已经被增强(实际增强的方法)，成此方法为切入点</li>
</ul>
</li>
<li>通知(增强)<ul>
<li>实际增强的逻辑部分称为通知(增强)</li>
<li>通知有多种类型<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
</li>
</ul>
</li>
<li>切面<ul>
<li>切面是一个动作，指把通知应用到切入点的过程</li>
</ul>
</li>
</ol>
<h3 id="1-5-AOP使用过程"><a href="#1-5-AOP使用过程" class="headerlink" title="1.5 AOP使用过程"></a>1.5 AOP使用过程</h3><ol>
<li>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</li>
<li>AspectJ 不是 Spring 组成部分，AspectJ 是独立的 AOP 框架，可以单独使用，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作</li>
<li>基于 AspectJ 实现 AOP 操作<ul>
<li>基于 xml 配置文件实现</li>
<li>基于注解方式实现（使用）</li>
</ul>
</li>
<li>在项目工程里面引入 AOP 相关依赖</li>
</ol>
<p>![相关依赖](./Spring AOP&amp; AspectJ基本使用/相关依赖.jpg)</p>
<ol start="5">
<li>切入点表达式<ol>
<li>切入点表达式作用：知道对哪个类里面的哪个方法进行增强 </li>
<li>语法结构： execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a> ) <ul>
<li>举例 1：对 com.review.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) </li>
<li>举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) </li>
<li>举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.<em>.</em> (..))</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>使用注解的方式对user对象中的add方法增强</li>
<li>第一步spring配置文件：加入context和aop命名空间，一个开启注解，一个生产代理对象</li>
</ul>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;


    &lt;!--开启注解扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.review.spring5&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--开启Aspect 生成代理对象--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>第二步：创建User类，加入add方法，添加注解</li>
</ul>
<pre><code class="java">//被增强的类
@Component
public class User &#123;
    public void add()&#123;
        System.out.println(&quot;add.....&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>第三步：创建增强类，通过UserProxy来增强User，在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</li>
</ul>
<pre><code class="java">//增强的类
@Component
@Aspect//生成代理对象
public class UserProxy &#123;
    //前置通知
    //@Before 注解表示作为前置通知
    @Before(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void before() &#123;
        System.out.println(&quot;before.........&quot;);
    &#125;
    //后置通知（返回通知）
    @AfterReturning(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void afterReturning() &#123;
        System.out.println(&quot;afterReturning.........&quot;);
    &#125;
    //最终通知
    @After(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void after() &#123;
        System.out.println(&quot;after.........&quot;);
    &#125;
    //异常通知
    @AfterThrowing(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void afterThrowing() &#123;
        System.out.println(&quot;afterThrowing.........&quot;);
    &#125;
    //环绕通知
    @Around(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void around(ProceedingJoinPoint proceedingJoinPoint) throws
            Throwable &#123;
        System.out.println(&quot;环绕之前.........&quot;);
        //被增强的方法执行
        proceedingJoinPoint.proceed();
        System.out.println(&quot;环绕之后.........&quot;);
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">@Test
    public void test1()&#123;
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        User user = context.getBean(&quot;user&quot;, User.class);
        user.add();
    &#125;
//结果
环绕之前.........
before.........
add.....
环绕之后.........
after.........
afterReturning.........
</code></pre>
<ul>
<li>相同切入点的抽取</li>
</ul>
<pre><code class="java">@Component
@Aspect//生成代理对象
public class UserProxy &#123;
    //相同切入点抽取
    @Pointcut(value = &quot;execution(* com.review.spring5.bean.User.add(..))&quot;)
    public void pointDemo()&#123;

    &#125;
    //前置通知
    //@Before 注解表示作为前置通知
    @Before(value = &quot;pointDemo()&quot;)
    public void before() &#123;
        System.out.println(&quot;before.........&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>有多个增强类对同一个方法进行增强，设置增强类优先级 <ul>
<li>在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</li>
</ul>
</li>
</ul>
<pre><code class="java">@Component
@Aspect
@Order(1)
public class PersonProxy&#123;
    
&#125;
</code></pre>
<h3 id="1-6-全注解开发"><a href="#1-6-全注解开发" class="headerlink" title="1.6 全注解开发"></a>1.6 全注解开发</h3><ol>
<li>@Configuration注解表示将当前类设置为配置类，@ComponentScan开启注解扫描，@EnableAspectJAutoProxy开启aspect生成代理对象</li>
</ol>
<pre><code class="java">（1）创建配置类，不需要创建 xml 配置文件
@Configuration
@ComponentScan(basePackages = &#123;&quot;com.review&quot;&#125;)
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class ConfigAop &#123;
&#125;
</code></pre>
<ol start="2">
<li>编写测试类，替代了xml文件所以用的<code>AnnotationConfigApplicationContext</code></li>
</ol>
<pre><code class="java"> @Test
    public void testService2() &#123;
        //加载配置类
        ApplicationContext context = new AnnotationConfigApplicationContext(ConfigAop.class);
        User user = context.getBean(&quot;user&quot;, User.class);
        user.add();
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务管理</title>
    <url>/2020/10/02/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>事务是数据库操作最基本单元，逻辑上 一组操作，要么都成功，如果有一个失败所有操作都失败</p>
<p>典型场景：银行转账 </p>
<p>事务四个特性（ACID）</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h3 id="1-2-事务操作环境"><a href="#1-2-事务操作环境" class="headerlink" title="1.2 事务操作环境"></a>1.2 事务操作环境</h3><p>建立数据库表，搭建spring配置文件</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 组件注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;
          destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- JdbcTemplate对象 --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;!--注入dataSource--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>创建dao层与数据库交互</p>
<pre><code class="java">@Repository
public class UserDaoImpl implements UserDao &#123;
    //注入JDBCTemplate
    @Autowired
    private JdbcTemplate jdbcTemplate;
    //lucy 转账 100 给 mary
    //少钱
    @Override
    public void reduceMoney() &#123;
        String sql = &quot;update t_account set money=money-? where username=?&quot;;
        jdbcTemplate.update(sql,100,&quot;lucy&quot;);
    &#125;
    //多钱
    @Override
    public void addMoney() &#123;
        String sql = &quot;update t_account set money=money+? where username=?&quot;;
        jdbcTemplate.update(sql,100,&quot;mary&quot;);
    &#125;
&#125;
</code></pre>
<p>创建service层</p>
<pre><code class="java">@Service
public class UserService &#123;
    //注入Dao
    @Autowired
    private UserDao userDao;

    //转账的方法
    public void accountMoney() &#123;
        //lucy 少 100
        userDao.reduceMoney();
        //mary 多 100
        userDao.addMoney();
    &#125;
&#125;
</code></pre>
<p>测试代码，</p>
<pre><code class="java">@Test
    public void test1()&#123;
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.accountMoney();
    &#125;
</code></pre>
<p>运行成功，查看数据库</p>
<h3 id="1-3-事务操作过程"><a href="#1-3-事务操作过程" class="headerlink" title="1.3 事务操作过程"></a>1.3 事务操作过程</h3><p>第一步：开启事务</p>
<p>第二步：进行业务操作</p>
<p>第三步：没有发生异常，提交事务</p>
<p>第四步：出现异常，回滚事务</p>
<p><strong>我们一般将事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</strong></p>
<p>在 Spring 进行事务管理操作有两种方式：<strong>编程式事务管理</strong>和<strong>声明式事务管理</strong>（使用）</p>
<p>声明式事务管理 </p>
<ul>
<li>基于注解方式（使用）</li>
<li>基于 xml 配置文件方式</li>
</ul>
<p>在 Spring 进行声明式事务管理，底层使用 AOP 原理</p>
<p>Spring 事务管理 API </p>
<p>提供一个接口<code>PlatformTransactionManager</code>，代表事务管理器，这个接口针对不同的框架提供不同的实现类</p>
<p>myBatis框架和jdbcTemplate使用DateSourceTransactionManager</p>
<p><img src="/2020/10/02/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/%E5%9B%BE1.jpg" alt="图1"></p>
<p><strong>第一步</strong>：在配置文件中配置事务管理器</p>
<pre><code class="xml">&lt;!--创建事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<p><strong>第二步</strong>：在 spring 配置文件，开启事务注解(通过事务管理器开启)，要先设置tx的命名空间</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!-- 组件注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;
          destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- JdbcTemplate对象 --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;!--注入dataSource--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--创建事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--开启事务注解--&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>第三步</strong>：在 service 类上面（或者 service 类里面方法上面）添加事务注解 </p>
<ul>
<li>@Transactional，这个注解添加到类上面，也可以添加方法上面</li>
<li>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</li>
<li>如果把这个注解添加方法上面，为这个方法添加事务</li>
</ul>
<pre><code class="java">@Service
@Transactional
public class UserService &#123;
    //注入Dao
    @Autowired
    private UserDao userDao;

    //转账的方法
    public void accountMoney() &#123;
        //lucy 少 100
        userDao.reduceMoney();
        //mary 多 100
        userDao.addMoney();
    &#125;
&#125;
</code></pre>
<h3 id="1-4-Transactional的参数"><a href="#1-4-Transactional的参数" class="headerlink" title="1.4 @Transactional的参数"></a>1.4 @Transactional的参数</h3><p>在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<ul>
<li><p>propagation：事务传播行为，一共有七种，默认值为<strong>REQUIRED</strong></p>
<p><img src="/2020/10/02/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.bmp" alt="事务传播行为"></p>
</li>
</ul>
<p><img src="/2020/10/02/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/%E4%BA%8B%E5%8A%A1.jpg" alt="事务"></p>
<pre><code class="java">@Service
@Transactional(propagation = Propagation.REQUIRED)
public class UserService &#123;
    //注入Dao
    @Autowired
    private UserDao userDao;

    //转账的方法
    public void accountMoney() &#123;
        //lucy 少 100
        userDao.reduceMoney();
        //mary 多 100
        userDao.addMoney();
    &#125;
&#125;
</code></pre>
<ul>
<li>ioslation：事务隔离级别，可以查看<a href="https://wyc1228.github.io/2020/09/21/JDBC%20%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8F%8ADBUtils/">JDBC事务</a>这篇博文，有详细介绍<ul>
<li>事务有隔离性，多事务操作之间不会产生影响。不考虑隔离性会产生产生三个读问题：脏读、不可重复读、虚（幻）读 </li>
<li><strong>脏读</strong>：一个未提交事务读取到另一个未提交事务的数据</li>
<li><strong>不可重复读</strong>：一个未提交事务读取到另一提交事务修改数据</li>
<li><strong>虚读</strong>：一个未提交事务读取到另一提交事务添加数据</li>
<li><strong>解决</strong>：通过设置事务隔离级别，解决读问题</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/02/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/%E9%9A%94%E7%A6%BB.png" alt="隔离"></p>
<pre><code class="java">@Service
@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)
public class UserService &#123;
    //注入Dao
    @Autowired
    private UserDao userDao;

    //转账的方法
    public void accountMoney() &#123;
        //lucy 少 100
        userDao.reduceMoney();
        //mary 多 100
        userDao.addMoney();
    &#125;
&#125;
</code></pre>
<ul>
<li>timeout：超时时间 <ul>
<li>事务需要在一定时间内进行提交，如果不提交进行回滚</li>
<li>默认值是 -1 ，设置时间以秒单位进行计算</li>
</ul>
</li>
<li>readOnly：是否只读 <ul>
<li>读：查询操作，写：添加修改删除操作 </li>
<li>readOnly 默认值 false，表示可以查询，可以添加修改删除操作</li>
<li>设置 readOnly 值是 true，设置成 true 之后，只能查询</li>
</ul>
</li>
<li>rollbackFor：回滚 <ul>
<li>设置出现哪些异常进行事务回滚 </li>
</ul>
</li>
<li>noRollbackFor：不回滚 <ul>
<li>设置出现哪些异常不进行事务回滚</li>
</ul>
</li>
</ul>
<h3 id="1-5-xml声明事务管理"><a href="#1-5-xml声明事务管理" class="headerlink" title="1.5 xml声明事务管理"></a>1.5 xml声明事务管理</h3><p>在 spring 配置文件中进行配置 </p>
<ul>
<li>第一步 配置事务管理器 </li>
<li>第二步 配置通知 </li>
<li>第三步 配置切入点和切面</li>
</ul>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- 组件注解扫描 --&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;
          destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- JdbcTemplate对象 --&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;!--注入dataSource--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--1 创建事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--开启事务注解，此方式为注解方式开启事务--&gt;
    &lt;!--&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;--&gt;

    &lt;!--2 配置通知--&gt;
    &lt;tx:advice id=&quot;txadvice&quot;&gt;
        &lt;!--配置事务参数--&gt;
        &lt;tx:attributes&gt;
            &lt;!--指定哪种规则的方法上面添加事务--&gt;
            &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;!--3 配置切入点和切面--&gt;
    &lt;aop:config&gt;
        &lt;!--配置切入点--&gt;
        &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.review.spring5.service.UserService.*(..))&quot;/&gt;
        &lt;!--配置切面--&gt;
        &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="1-6-完全注解方式声明事务管理"><a href="#1-6-完全注解方式声明事务管理" class="headerlink" title="1.6 完全注解方式声明事务管理"></a>1.6 完全注解方式声明事务管理</h3><pre><code class="java">@Configuration //配置类
@ComponentScan(basePackages = &quot;com.review&quot;) //组件注解扫描
@EnableTransactionManagement //开启事务
public class TxConfig &#123;
    //创建数据库连接池
    @Bean
    public DruidDataSource getDruidDataSource() &#123;
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        return dataSource;
    &#125;
    //创建 JdbcTemplate 对象
    @Bean
    public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123;
        //到 ioc 容器中根据类型找到 dataSource
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //注入 dataSource
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    &#125;
    //创建事务管理器
    @Bean
    public DataSourceTransactionManager
    getDataSourceTransactionManager(DataSource dataSource) &#123;
        DataSourceTransactionManager transactionManager = new
                DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>XML基本使用</title>
    <url>/2020/09/17/XML/</url>
    <content><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><code>xml</code>：Extensible Markup Language 可扩展标记语言</li>
<li>作用：<ul>
<li>用来保存数据，而且这些数据具有自我描述性 </li>
<li>它还可以做为项目或者模块的配置文件 </li>
<li>还可以做为网络传输数据的格式（现在 JSON 为主）</li>
</ul>
</li>
</ul>
<h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><ul>
<li>基本要求：xml语法严格，不像html语法松散<ul>
<li>xml文档的后缀名 .xml</li>
<li>xml<strong>第一行必须定义为文档声明</strong></li>
<li>xml文档中<strong>有且仅有一个根标签</strong></li>
<li><strong>属性值必须使用引号</strong>(单双都可)引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ul>
</li>
</ul>
<h4 id="xml组成"><a href="#xml组成" class="headerlink" title="xml组成"></a>xml组成</h4><ul>
<li><p>文档声明：格式：<?xml 属性列表 ?></p>
<ul>
<li>属性列表： <ol>
<li><code>version</code>：版本号，必须的属性</li>
<li><code>encoding</code>：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 </li>
<li><code>standalone</code>：是否独立取值： yes：不依赖其他文件 no：依赖其他文件</li>
</ol>
</li>
</ul>
</li>
<li><p>指令(了解)：</p>
<ul>
<li>结合css的<?xml-stylesheet type="text/css" href="a.css" ?></li>
</ul>
</li>
<li><p>标签：标签名称自定义的</p>
<ul>
<li>规则： 名称可以包含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li>
<li>名称不能包含空格</li>
<li>xml 中的元素（标签）也 分成 单标签和双标签： </li>
</ul>
</li>
<li><p>属性：id属性值唯一</p>
</li>
<li><p>文本：CDATA区：在该区域中的数据会被原样展示 格式： <!--[CDATA[ 这里可以把你输入的字符原样显示，不会解析 xml ]]--></p>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;&lt;!--文档声明--&gt;
&lt;!--&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;./a.css&quot; ?&gt;指令--&gt;
&lt;users&gt;&lt;!--标签自定义--&gt;
    &lt;user id=&quot;1&quot;&gt;&lt;!--id属性，id值唯一--&gt;
        &lt;name test=&quot;test01&quot;&gt;
            &lt;xing&gt;zhang&lt;/xing&gt;
            &lt;ming&gt;san&lt;/ming&gt;
            &lt;!--zhangsan--&gt;
        &lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
        &lt;gender&gt;male&lt;/gender&gt;
        &lt;code&gt;
            &lt;!--if(a &amp;lt; b &amp;amp;&amp;amp; a &amp;lt; c)&#123;&#125;--&gt;
            &lt;![CDATA[
            if(a&lt;b &amp;&amp; a&gt;c)&#123;&#125;
            ]]&gt;&lt;!--里面的内容不会解析成xml--&gt;
        &lt;/code&gt;
    &lt;/user&gt;
    &lt;user id=&quot;3&quot; name=&quot;wagwu&quot;/&gt;&lt;!--单标签--&gt;
    &lt;user id=&quot;2&quot;&gt;
        &lt;name&gt;lisi&lt;/name&gt;
        &lt;age&gt;21&lt;/age&gt;
        &lt;gender&gt;female&lt;/gender&gt;
    &lt;/user&gt;
&lt;/users&gt;
</code></pre>
<h3 id="1-3-解析XML"><a href="#1-3-解析XML" class="headerlink" title="1.3 解析XML"></a>1.3 解析XML</h3><ul>
<li><p>操作xml文档，将文档中的数据读取到内存中</p>
<ul>
<li>xml文档解析(读取)：将文档中的数据读取到内存中</li>
<li>xml文档解析(写入)：将内存中的数据保存到xml文档中。持久化的存储</li>
</ul>
</li>
<li><p>xml常见的解析器：</p>
<ul>
<li>DOM4J：一款非常优秀的解析器</li>
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。PULL：Android操作系统内置的解析器，sax方式的。</li>
</ul>
</li>
</ul>
<h4 id="dom4j解析"><a href="#dom4j解析" class="headerlink" title="dom4j解析"></a>dom4j解析</h4><ul>
<li><p>由于 dom4j 它不是 sun 公司的技术，而属于第三方公司的技术，我们需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。</p>
</li>
<li><p>dom4j解析步骤</p>
<ul>
<li>第一步： 先加载 xml 文件创建 Document 对象 </li>
<li>第二步：通过 Document 对象拿到根元素对象 </li>
<li>第三步：通过根元素.elelemts(标签名); 可以返回一个集合，这个集合里放着。所有你指定的标签名的元素对象 </li>
<li>第四步：找到你想要修改、删除的子元素，进行相应在的操作 </li>
<li>第五步，保存到硬盘上</li>
</ul>
</li>
<li><p>需要解析的xml文件</p>
</li>
</ul>
<pre><code class="xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;books&gt;
      &lt;book sn=&quot;SN12341232&quot;&gt;
          &lt;name&gt;辟邪剑谱&lt;/name&gt;
          &lt;price&gt;9.9&lt;/price&gt;
          &lt;author&gt;班主任&lt;/author&gt;
      &lt;/book&gt;
      &lt;book sn=&quot;SN12341231&quot;&gt;
          &lt;name&gt;葵花宝典&lt;/name&gt;
          &lt;price&gt;99.99&lt;/price&gt;
          &lt;author&gt;班长&lt;/author&gt;
      &lt;/book&gt;
  &lt;/books&gt;
</code></pre>
<ul>
<li>解析的是book，需要先创建book类对应xml中的内容</li>
</ul>
<pre><code class="java">    public class Book &#123;
        private String sn;
        private String name;
        private BigDecimal price;
        private String author;
        //constructor
        //略
        //getter and setter 方法
        //略
        //toString() 方法
        //略
    &#125;
</code></pre>
<ul>
<li>然后解析xml内容</li>
</ul>
<pre><code class="java">public class Dom4jTest &#123;
    @Test
    public void test1() throws Exception &#123;
        
        // 创建一个SaxReader输入流，去读取 xml配置文件，生成Document对象
        SAXReader saxReader = new SAXReader();

        Document document = saxReader.read(&quot;src/books.xml&quot;);

        System.out.println(document);
        //结果,生成document对象
        //org.dom4j.tree.DefaultDocument@5bcab519 [Document: name src/books.xml]
    &#125;

&#125;
</code></pre>
<ul>
<li>转换为book对象</li>
</ul>
<pre><code class="java">//读取books.xml文件生成book类
    @Test
    public void test2() throws DocumentException &#123;
        //1. 读取books.xml文件
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(&quot;src/books.xml&quot;);
        //2. 通过文档对象获取根元素
        Element rootElement = document.getRootElement();
//        System.out.println(rootElement);
        //org.dom4j.tree.DefaultElement@5bcab519 [Element: &lt;books attributes: []/&gt;]
        //3. 通过根元素books获取book标签对象
        //element()和elements()都是通过标签名查找子元素
        List&lt;Element&gt; book = rootElement.elements(&quot;book&quot;);
        for (Element o : book) &#123;
//            System.out.println(o);//每一个book标签对象
            Element name = o.element(&quot;name&quot;);//name标签对象
            //getText()获取标签中的文本内容
            String nametext = name.getText();
            System.out.println(nametext);
            //elementText()方法一次性获得标签内容
            String pricetext = o.elementText(&quot;price&quot;);
            String authortext = o.elementText(&quot;author&quot;);
            System.out.println(pricetext);

            //获取属性 attributeValue():获取属性值方法
            String sn = o.attributeValue(&quot;sn&quot;);
            System.out.println(sn);

            //转成book对象
            System.out.println(new Book(sn,nametext, BigDecimal.valueOf(Double.parseDouble(pricetext)),authortext));
        &#125;
        //org.dom4j.tree.DefaultElement@4cf777e8 [Element: &lt;book attributes: [org.dom4j.tree.DefaultAttribute@2f686d1f [Attribute: name sn value &quot;SN12341232&quot;]]/&gt;]
        //org.dom4j.tree.DefaultElement@3fee9989 [Element: &lt;book attributes: [org.dom4j.tree.DefaultAttribute@73ad2d6 [Attribute: name sn value &quot;SN12341231&quot;]]/&gt;]

    &#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>linux组管理</title>
    <url>/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="linux组管理"><a href="#linux组管理" class="headerlink" title="linux组管理"></a>linux组管理</h2><p>基本介绍：</p>
<ul>
<li>在linux中，每个用户必须属于一个组，不能独立在组外。</li>
<li>在linux中每个文件都有所有者，所在组，和其他组</li>
<li>一般谁创建了改文件，改文件的所有者就是谁，改文件的所在组就是该用户的所在组，出去该用户所在的组，称为其他组</li>
</ul>
<p>查看文件的所有者：ls -ahl</p>
<p>案例：创建一个组police，在创建一个用户tom，将tom加入到这个组，在使用tom创建一个文件</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011170453271.png" alt="image-20201011170453271"></p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011170854559.png" alt="image-20201011170854559"></p>
<p>修改文件所有者</p>
<ul>
<li><p>chown 用户名 文件名</p>
</li>
<li><p>chown newowner:newgroup file 改变文件的所有者和所有组</p>
</li>
<li><p>chown -R 用户名 目录名 如果是目录，则使其下所有子文件或目录递归生效</p>
</li>
<li><p>使用root创建一个文件apple.txt，然后将其所有者修改为tom，第一列为所有者，第二列为所在组</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011171228494.png" alt="image-20201011171228494"></p>
</li>
</ul>
<p>查看文件所在组</p>
<ul>
<li><p>当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组</p>
</li>
<li><p>查看文件所在组：ls -ahl</p>
</li>
<li><p>修改<strong>文件所在组</strong>：chgrp 组名 文件名</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011171931762.png" alt="image-20201011171931762"></p>
</li>
</ul>
<p>其他组：</p>
<ul>
<li>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</li>
</ul>
<p>修改<strong>用户所在组</strong>：</p>
<ul>
<li><p>usermod -g 组名 用户名</p>
</li>
<li><p>usermod -d 目录名 用户名 ：改变该用户登录的初始目录</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011093656038.png" alt="image-20201011093656038"></p>
</li>
</ul>
<h2 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h2><p>ls -l中显示的内容如下：</p>
<p>drwxr-xr-x. 2 root root：drwxr-xr-x【0-9位说明】</p>
<ul>
<li>0：d，表示文件的类型（d：目录，-：普通文件，l：软连接，c：字符设备[键盘，鼠标]，b：块文件）</li>
<li>1-3：rwx，表示文件所有者权限rwx   —User</li>
<li>4-6：r-x，表示文件所在组的用户拥有的权限，-代表没有权限，r-x：表示只有r和x的权限  —Group</li>
<li>7-9：r-x，表示文件其他组的用户拥有的权限  —Other</li>
</ul>
<p>rwx：可用数字表示为: r=4,w=2,x=1 因此rwx=4+2+1=7 </p>
<ul>
<li> [ r ]代表可读(read): 可以读取,查看</li>
<li> [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是 对该文件所在的目录有写权限，才能删除该文件</li>
<li>[ x ]代表可执行(execute):可以被执行</li>
</ul>
<p>表示不同用户能对文件干什么</p>
<ul>
<li>第一组rwx : 文件拥有者的权限是读、写和执行 </li>
<li>第二组r-x : 与文件拥有者同一组的用户对此文件的权限是读、执行但不能写</li>
<li>第三组r-x: 不与文件拥有者同组的其他用户对这个文件的权限是读、执行但不能写</li>
</ul>
<p>修改权限：</p>
<ul>
<li>通过chmod指令，可以修改文件或者目录的权限。</li>
</ul>
<p>第一种修改权限方式</p>
<ul>
<li>u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和) </li>
<li>chmod u=rwx,g=rx,o=x 文件目录名 </li>
<li>chmod o+w 文件目录名 //给other增加一个w权限</li>
<li>chmod a-x 文件目录名//给all减去一个x权限</li>
</ul>
<p>案例：</p>
<ul>
<li> 给test文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</li>
<li>给test文件的所有者除去执行的权限，增加组写的权限 </li>
<li>给abc文件的所有用户添加读的权限</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011204420867.png" alt="image-20201011204420867"></p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011204855871.png" alt="image-20201011204855871"></p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011205001906.png" alt="image-20201011205001906"></p>
<p>第二种方式，通过数字变更权限</p>
<ul>
<li>r=4 w=2 x=1 rwx=4+2+1=7 </li>
<li>chmod u=rwx,g=rx,o=x 文件目录名 相当于 chmod 751 文件目录名</li>
</ul>
<p>案例：将 a.txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现</p>
<ul>
<li><p>rwx=4+2+1，r-x=4+1，r-x=4+1</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011205822422.png" alt="image-20201011205822422"></p>
</li>
</ul>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>概述</p>
<ul>
<li><p>任务调度：是指系统在某个时间执行挺稳定的命令或程序</p>
</li>
<li><p>任务调度分类</p>
<ul>
<li>系统工作：有些工作需要周而复始的执行，如病毒扫描</li>
<li>个别用户工作：固定时间对数据库备份</li>
</ul>
</li>
<li><p>语法 ：crontab [选项]</p>
</li>
<li><p>常用选项</p>
<table>
<thead>
<tr>
<th>-e</th>
<th>编辑crontab定时任务</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>查询crontab任务</td>
</tr>
<tr>
<td>-r</td>
<td>删除当前用户所有的crontab任务</td>
</tr>
</tbody></table>
</li>
<li><p>service crond restart [重启任务调度]</p>
</li>
</ul>
<p>案例：设置任务调度文件，是指每分钟执行一次</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011220523450.png" alt="image-20201011220523450"></p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011221616512.png" alt="image-20201011221616512"></p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201011221804492.png" alt="image-20201011221804492"></p>
<ul>
<li><p>5个占位符说明</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
</li>
<li><p>特殊符号说明</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一 次的意思。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天 的8点0分，12点0分，16点0分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周 六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔 10分钟就执行一遍命令</td>
</tr>
</tbody></table>
</li>
<li><p>特定时间执行任务案例</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * * 命令</td>
<td>在22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1 命令</td>
<td>每周1 的17点0分执行命令</td>
</tr>
<tr>
<td>0 5 1,15 * * 命令</td>
<td>每月1号和15号的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>40 4 * * 1-5 命令</td>
<td>每周一到周五的凌晨4点40分执行命令</td>
</tr>
<tr>
<td>*/10 4 * * * 命令</td>
<td>每天的凌晨4点，每隔10分钟执行一次命令</td>
</tr>
<tr>
<td>0 0 1,15 * 1 命令</td>
<td>每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和 几号最好不要同时出现，因为他们定义的都是天。非常容易让管 理员混乱。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="磁盘分区，挂载"><a href="#磁盘分区，挂载" class="headerlink" title="磁盘分区，挂载"></a>磁盘分区，挂载</h2><p>分区的两种方式</p>
<p>mbr分区：</p>
<ul>
<li>最多支持四个主分区</li>
<li>系统只能安装在主分区 </li>
<li>扩展分区要占一个主分区 </li>
<li>MBR最大只支持2TB，但拥有最好的兼容性</li>
</ul>
<p>gpt分区: </p>
<ul>
<li>支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）</li>
<li>最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ） </li>
<li>windows7 64位以后支持gtp</li>
</ul>
<p>linux分区：</p>
<ul>
<li>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独 立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</li>
<li>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目 录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一 个目录下获得。</li>
</ul>
<p>linux硬盘说明：</p>
<ul>
<li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 </li>
<li>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“</del>”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就 是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为 第二个IDE硬盘上的第二个主分区或扩展分区。</li>
<li>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余 则和IDE硬盘的表示方法一样。</li>
</ul>
<p>lsblk命令查看分区挂载情况</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012090034652.png" alt="image-20201012090034652"></p>
<p>磁盘相关命令</p>
<ul>
<li>查询系统整体磁盘使用情况：df -h</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012090755617.png" alt="image-20201012090755617"></p>
<ul>
<li>查询指定目录的磁盘占用情况：du -h /目录<ul>
<li>-h：带有计量单位</li>
<li>-s：指定目录占用大小汇总</li>
<li>-a：含文件</li>
<li>–max-depth=1 子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012091154311.png" alt="image-20201012091154311"></p>
<ul>
<li>统计/home文件夹下文件的个数，”^-“：表示以-开头的文件，wc统计指令</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012091559210.png" alt="image-20201012091559210"></p>
<ul>
<li>统计/home文件夹下目录的个数，”^d”：表示以-开头的文件，wc统计指令</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012091725141.png" alt="image-20201012091725141"></p>
<ul>
<li>统计/home文件夹下文件的个数，包括子文件夹里的，-lR：R表示递归统计子目录的，linux是区分大小写的，不能写r，大写的R表示递归，r表示逆序</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012091952665.png" alt="image-20201012091952665"></p>
<ul>
<li>统计/home文件夹下目录的个数，包括子文件夹里的，</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012092130731.png" alt="image-20201012092130731"></p>
<ul>
<li><p>以树状结构显示目录结构</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012092526166.png" alt="image-20201012092526166"></p>
</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>基本介绍</p>
<ul>
<li>在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一 个ID号。</li>
<li>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例 如www服务器。</li>
<li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目 前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法 看到的进程，通常使用后台方式执行。</li>
<li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到 关机才才结束。</li>
</ul>
<p>显示系统执行的进程：ps指令，ps -aux</p>
<ul>
<li>ps -a：显示当前终端的所有进程信息</li>
<li>ps -u：以用户的格式显示进程信息</li>
<li>ps -x：显示后台进程运行的参数</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012100415532.png" alt="image-20201012100415532"></p>
<p>第一行进程指令说明：</p>
<ul>
<li>System V展示风格 </li>
<li>USER：用户名称 </li>
<li>PID：进程号 </li>
<li>%CPU：进程占用CPU的百分比 </li>
<li>%MEM：进程占用物理内存的百分比</li>
<li>VSZ：进程占用的虚拟内存大小（单位：KB） </li>
<li>RSS：进程占用的物理内存大小（单位：KB）</li>
<li>TT：终端名称,缩写 .</li>
<li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通 优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 </li>
<li>STARTED：进程的启动时间 </li>
<li>TIME：CPU时间，即进程使用CPU的总时间</li>
<li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li>
</ul>
<p>全格式显示当前所有进程，查看进程的父进程，ps -ef，PPID为父进程</p>
<ul>
<li><p>ps -e：显示所有进程(也显示父进程)</p>
</li>
<li><p>ps -f：全格式</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012101247970.png" alt="image-20201012101247970"></p>
</li>
</ul>
<p>终止进程kill和killall</p>
<ul>
<li>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该 进程。使用kill命令来完成此项任务。</li>
<li>kill [选项] 进程号（功能描述：通过进程号杀死进程） ，-9 :表示强迫进程立即停止</li>
<li>killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</li>
</ul>
<p>查看进程树pstree</p>
<ul>
<li><p>pstree [选项] ,可以直观的来查看进程信息，-p：显示进程的PID，-u：显示进程的所属用户</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012101926636.png" alt="image-20201012101926636"></p>
</li>
</ul>
<p>服务(Service)管理</p>
<ul>
<li><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，在Linux中非常重要。</p>
</li>
<li><p>service管理指令： </p>
<ul>
<li>service 服务名 [start | stop | restart | reload | status] </li>
<li>在CentOS7.0后 不再使用service ,而是 systemctl</li>
</ul>
</li>
<li><p>查看当前防火墙状况</p>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012102229010.png" alt="image-20201012102229010"></p>
</li>
</ul>
<p>Linux系统有7种运行级别(runlevel)：常用的是级别3和5 </p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态(没有NFS)，不支持网络</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<p>chkconfig指令</p>
<ul>
<li>通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</li>
<li>查看服务 chkconfig –list|grep xxx </li>
<li> chkconfig 服务名 –list </li>
<li>chkconfig –level 5 服务名 on/off </li>
</ul>
<h2 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h2><p>rpm包的管理</p>
<ul>
<li>一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工 具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的 标志，但理念是通用的。 </li>
<li>Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标 准了。</li>
</ul>
<p>rpm包的简单查询指令：</p>
<ul>
<li>查询已安装的rpm列表 ：rpm -qa|grep xx</li>
</ul>
<p><img src="/2020/10/11/linux%E7%BB%84%E7%AE%A1%E7%90%86/image-20201012113537748.png" alt="image-20201012113537748"></p>
<ul>
<li>卸载rpm包：rpm -e rpm包的名称</li>
<li>安装rpm包：rpm -ivh rpm包全路径名称<ul>
<li>i=install 安装 </li>
<li>v=verbose 提示</li>
<li>h=hash 进度条</li>
</ul>
</li>
</ul>
<p>yum包管理</p>
<ul>
<li>Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定 的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并 且一次安装所有依赖的软件包。</li>
</ul>
<p>yum的基本指令</p>
<ul>
<li>查询yum服务器是否有需要安装的软件 yum list|grep xx软件列表</li>
<li>安装指定的yum包 yum install xxx 下载安装</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件的上传与下载</title>
    <url>/2020/09/26/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="文件的上传与下载"><a href="#文件的上传与下载" class="headerlink" title="文件的上传与下载"></a>文件的上传与下载</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>比如：QQ 头像，就使用了上传。 邮箱中也有附件的上传和下载功能。 </p>
<h3 id="1-2-文件上传操作步骤"><a href="#1-2-文件上传操作步骤" class="headerlink" title="1.2 文件上传操作步骤"></a>1.2 文件上传操作步骤</h3><ol>
<li>要有一个 form 标签，method=post 请求 ,post请求没有长度限制，可以传照片等文件</li>
<li>form标签的 <code>encType</code> 属性值必须为 multipart/form-data 值 </li>
<li>在form标签中使用 input type=file 添加上传的文件 </li>
<li>编写服务器代码（Servlet 程序）接收，处理上传的数据。</li>
</ol>
<blockquote>
<p>encType=multipart/form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器</p>
</blockquote>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt;
        头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot; &gt; &lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-3Http协议内容"><a href="#1-3Http协议内容" class="headerlink" title="1.3Http协议内容"></a>1.3Http协议内容</h3><p><img src="./%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/http%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9.jpg" alt="Http协议内容"></p>
<h3 id="1-4-servlet的处理"><a href="#1-4-servlet的处理" class="headerlink" title="1.4 servlet的处理"></a>1.4 servlet的处理</h3><p>第一步，就是需要导入两个 jar 包：</p>
<p>commons-fileupload-1.2.1.jar 和 commons-io-1.4.jar</p>
<p>commons-fileupload.jar 需要依赖 commons-io.jar 这个包</p>
<p>commons-fileupload.jar 和 commons-io.jar 包中，<strong>常用的类</strong></p>
<p><code>ServletFileUpload</code> 类，用于解析上传的数据。 </p>
<p><code>FileItem</code> 类，表示每一个表单项。</p>
<p><code>boolean ServletFileUpload.isMultipartContent(HttpServletRequest request)</code>; 判断当前上传的数据格式是否是多段的格式。</p>
<p><code>public  List&lt;FileItem&gt;  parseRequest(HttpServletRequestrequest)</code> 解析上传的数据</p>
<p><code>boolean FileItem.isFormField()</code> 判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 true 表示普通类型的表单项 </p>
<p>false 表示上传的文件类型</p>
<p><code>String FileItem.getFieldName()</code> 获取表单项的 name 属性值</p>
<p><code>String FileItem.getString()</code> 获取当前表单项的值。</p>
<p><code>String FileItem.getName();</code> 获取上传的文件名</p>
<p><code>void FileItem.write( file );</code> 将上传的文件写到参数 file 所指向抽硬盘位置 。</p>
<pre><code class="java">public class UploadServlet extends HttpServlet &#123;
    /**
     * 用来处理上传的数据
     */
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        //1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）
        if (ServletFileUpload.isMultipartContent(req)) &#123;
//           创建FileItemFactory工厂实现类
            FileItemFactory fileItemFactory = new DiskFileItemFactory();
            // 创建用于解析上传数据的工具类ServletFileUpload类
            ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
            try &#123;
                // 解析上传的数据，得到每一个表单项FileItem
                List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);
                // 循环判断，每一个表单项，是普通类型，还是上传的文件
                for (FileItem fileItem : list) &#123;

                    if (fileItem.isFormField()) &#123;
                        // 普通表单项

                        System.out.println(&quot;表单项的name属性值：&quot; + fileItem.getFieldName());
                        // 参数UTF-8.解决乱码问题
                        System.out.println(&quot;表单项的value属性值：&quot; + fileItem.getString(&quot;UTF-8&quot;));

                    &#125; else &#123;
                        // 上传的文件
                        System.out.println(&quot;表单项的name属性值：&quot; + fileItem.getFieldName());
                        System.out.println(&quot;上传的文件名：&quot; + fileItem.getName());

                        fileItem.write(new File(&quot;e:\\&quot; + fileItem.getName()));
                    &#125;
                &#125;
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

    &#125;

&#125;
</code></pre>
<h3 id="1-5-文件的下载"><a href="#1-5-文件的下载" class="headerlink" title="1.5 文件的下载"></a>1.5 文件的下载</h3><p><strong>下载的常用 API 说明：</strong></p>
<ul>
<li><p><code>response.getOutputStream();</code> </p>
</li>
<li><p><code>servletContext.getResourceAsStream();</code> </p>
</li>
<li><p><code>servletContext.getMimeType();</code> </p>
</li>
<li><p><code>response.setContentType();</code></p>
</li>
<li><p><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName=1.jpg&quot;);</code> </p>
</li>
</ul>
<p><code>response.setHeader</code>设置这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。fileName=后面， 表示下载的文件名。</p>
<p>完成上面的两个步骤，下载文件是没问题了。但是如果我们要下载的文件是中文名的话。你会发现，下载无法正确显示出正确的中文名。</p>
<p>原因是在响应头中，不能包含有中文字符，只能包含 ASCII 码。</p>
<p><strong>步骤：</strong></p>
<ol>
<li> 获取要下载的文件名</li>
<li>读取要下载的文件内容 (通过ServletContext对象可以读取)</li>
<li>把下载的文件内容回传给客户端</li>
<li>在回传前，通过响应头告诉客户端返回的数据类型</li>
<li>还要告诉客户端收到的数据是用于下载使用（还是使用响应头）</li>
</ol>
<pre><code class="java">public class Download extends HttpServlet &#123;


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
//        1、获取要下载的文件名
        String downloadFileName = &quot;2.jpg&quot;;
//        2、读取要下载的文件内容 (通过ServletContext对象可以读取)
        ServletContext servletContext = getServletContext();
        // 获取要下载的文件类型
        String mimeType = servletContext.getMimeType(&quot;/file/&quot; + downloadFileName);
        System.out.println(&quot;下载的文件类型：&quot; + mimeType);
//        4、在回传前，通过响应头告诉客户端返回的数据类型
        resp.setContentType(mimeType);
//        5、还要告诉客户端收到的数据是用于下载使用（还是使用响应头）
        // Content-Disposition响应头，表示收到的数据怎么处理
        // attachment表示附件，表示下载使用
        // filename= 表示指定下载的文件名
        // url编码是把汉字转换成为%xx%xx的格式
//        if (req.getHeader(&quot;User-Agent&quot;).contains(&quot;Firefox&quot;)) &#123;
//            // 如果是火狐浏览器使用Base64编码
//            resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename==?UTF-8?B?&quot; + new BASE64Encoder().encode(&quot;中国.jpg&quot;.getBytes(&quot;UTF-8&quot;)) + &quot;?=&quot;);
//        &#125; else &#123;
            // 如果不是火狐，是IE或谷歌，使用URL编码操作
            resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(&quot;中国.jpg&quot;, &quot;UTF-8&quot;));
//        &#125;
        /**
         * /斜杠被服务器解析表示地址为http://ip:prot/工程名/  映射 到代码的Web目录
         */
        InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/file/&quot; + downloadFileName);
        // 获取响应的输出流
        OutputStream outputStream = resp.getOutputStream();
        //        3、把下载的文件内容回传给客户端
        // 读取输入流中全部的数据，复制给输出流，输出给客户端
        IOUtils.copy(resourceAsStream, outputStream);
    &#125;
&#125;
</code></pre>
<h3 id="1-3-附件中文乱码"><a href="#1-3-附件中文乱码" class="headerlink" title="1.3 附件中文乱码"></a>1.3 附件中文乱码</h3><p>附件中文名乱码问题解决方案：URLEncoder 解决 IE 和谷歌浏览器的 附件中文名问题。</p>
<p>如果客户端浏览器是IE浏览器或者是谷歌浏览器。我们需要使用 URLEncoder 类先对中文名进行UTF-8 的编码操作。 </p>
<p>因为IE浏览器和谷歌浏览器收到含有编码后的字符串后会以 UTF-8 字符集进行解码显示。</p>
<p>把中文名进行 UTF-8 编码操作。 </p>
<pre><code class="java">String str = &quot;attachment; fileName=&quot; + URLEncoder.encode(&quot;中文.jpg&quot;, &quot;UTF-8&quot;);
</code></pre>
<p>然后把编码后的字符串设置到响应头中 </p>
<pre><code class="java">response.setHeader(&quot;Content-Disposition&quot;, str);
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后重新部署恢复 Hexo</title>
    <url>/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>以下方法只适用于没有删除hexo blog文件夹，因为重装系统后，Hexo 相关依赖插件/软件和在C盘的缓存资料都会被删除，以至于Hexo的相关命令都无法运行。所以，在重装系统后，都要重新部署Hexo。但是重新部署并不难，只需要几个步骤就行。</p>
<h2 id="重装系统后重新部署恢复-Hexo"><a href="#重装系统后重新部署恢复-Hexo" class="headerlink" title="重装系统后重新部署恢复 Hexo"></a>重装系统后重新部署恢复 Hexo</h2><h3 id="安装Git-和Node"><a href="#安装Git-和Node" class="headerlink" title="安装Git 和Node"></a>安装Git 和Node</h3><pre><code>git for windows: https://git-scm.com/
Node.js: https://nodejs.org/en/
</code></pre>
<h3 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h3><p>配置git个人信息和生成ssh密钥<br>打开git bash，输入</p>
<pre><code>git config --global user.name &quot;xxxxx&quot;
git config --global user.email &quot;xxxxxx@xx.com&quot;
ssh-keygen -t rsa -C &quot;xxxxxx@xx.com&quot;
</code></pre>
<h3 id="设置Github的ssh密钥"><a href="#设置Github的ssh密钥" class="headerlink" title="设置Github的ssh密钥"></a>设置Github的ssh密钥</h3><p>当上面的运行完成后，会在 <code>C:\Users\主用户</code>里出现<code>.ssh</code>文件夹，里面有id_rsa和id_rsa.pub两个文件，复制id_rsa.pub的内容。</p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017110653206.png" alt="image-20211017110653206"></p>
<p>打开 Github 网页，依次是 <code>右上角Settings - SSH and GPG keys - New SSH key</code> 把复制的内容粘贴到 <code>Key</code>栏，然后保存。</p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017103702994.png" alt="image-20211017103702994"></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>git bash 上 输入 <code>npm install hexo-cli -g</code></p>
<h3 id="删掉原blog文件夹部分文件"><a href="#删掉原blog文件夹部分文件" class="headerlink" title="删掉原blog文件夹部分文件"></a>删掉原blog文件夹部分文件</h3><p>打开你原有的 blog文件夹，只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。</p>
<h3 id="安装依赖文件"><a href="#安装依赖文件" class="headerlink" title="安装依赖文件"></a>安装依赖文件</h3><p>git bash 上 输入 <code>npm install</code></p>
<h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h3><p>git bash 上 输入 <code>npm install hexo-deployer-git --save</code></p>
<p>最后 运行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 看看是否成功。</p>
<h3 id="本次部署我遇到的问题："><a href="#本次部署我遇到的问题：" class="headerlink" title="本次部署我遇到的问题："></a>本次部署我遇到的问题：</h3><h4 id="1-yaml-safeLoad已经弃用，用yaml-load代替"><a href="#1-yaml-safeLoad已经弃用，用yaml-load代替" class="headerlink" title="1. yaml.safeLoad已经弃用，用yaml.load代替"></a>1. yaml.safeLoad已经弃用，用yaml.load代替</h4><pre><code>Function yaml.safeLoad is removed in js-yaml 4. Use yaml.load instead, which is now safe by default
</code></pre>
<p>解决方式：在next主题的vendors.js文件中修改 yaml.safeLoad</p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017104603019.png" alt="image-20211017104603019"></p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017104729045.png" alt="image-20211017104729045"></p>
<h4 id="2-npm-版本过低"><a href="#2-npm-版本过低" class="headerlink" title="2. npm 版本过低"></a>2. npm 版本过低</h4><p>修改config文件，将true改为false</p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017105311585.png" alt="image-20211017105311585"></p>
<p><img src="/2021/07/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E7%9A%84%E9%83%A8%E7%BD%B2/image-20211017105358951.png" alt="image-20211017105358951"></p>
<h2 id="Hexo常用操作"><a href="#Hexo常用操作" class="headerlink" title="Hexo常用操作"></a>Hexo常用操作</h2><h3 id="新建博客文件"><a href="#新建博客文件" class="headerlink" title="新建博客文件"></a>新建博客文件</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><pre><code class="bash">$ hexo server
</code></pre>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre><code class="bash">$ hexo generate
</code></pre>
<h3 id="上传到GitHub"><a href="#上传到GitHub" class="headerlink" title="上传到GitHub"></a>上传到GitHub</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<h3 id="上传的步骤一般是"><a href="#上传的步骤一般是" class="headerlink" title="上传的步骤一般是"></a>上传的步骤一般是</h3><pre><code>hexo clean
hexo g
hexo d
</code></pre>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本使用</title>
    <url>/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Git基本使用"><a href="#Git基本使用" class="headerlink" title="Git基本使用"></a>Git基本使用</h1><p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210325201127712.png" alt="image-20210325201127712"></p>
<h2 id="1、版本控制"><a href="#1、版本控制" class="headerlink" title="1、版本控制"></a>1、版本控制</h2><p>版本控制工具应该具备的功能</p>
<ul>
<li>协同修改<ul>
<li>多人并行不悖的修改服务器端的同一个文件</li>
</ul>
</li>
<li>数据备份<ul>
<li>不仅保存目录和文件的当前状态，还能保存每一个提交过的历史状态</li>
</ul>
</li>
<li>版本管理<ul>
<li>在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率，Git采用了文件系统快照的方式</li>
</ul>
</li>
<li>权限控制<ul>
<li>对团队中参与开发的人员进行权限控制</li>
<li>对团队外开发者贡献的代码进行审核–Git独有</li>
</ul>
</li>
<li>历史记录<ul>
<li>查看修改人，修改时间，修改内容，日志信息</li>
<li>将本地文件恢复到某一个历史状态</li>
</ul>
</li>
<li>分支管理<ul>
<li>允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率</li>
</ul>
</li>
</ul>
<p>版本控制工具分类</p>
<ul>
<li>集中式版本控制工具：CVS、<strong>SVN</strong>、VSS·····</li>
<li>分布式版本控制工具：<strong>Git</strong>、Mercurial、Bazaar·····</li>
</ul>
<p><strong>分布式版本控制工具 比 集中式版本控制工具 首要的优势是 能够避免单点故障</strong></p>
<h2 id="2、Git的优势"><a href="#2、Git的优势" class="headerlink" title="2、Git的优势"></a>2、Git的优势</h2><ul>
<li>大部分操作在本地完成，不需要联网</li>
<li>完整性保证</li>
<li>尽可能添加数据而不是删除或修改数据</li>
<li>分支操作非常快捷流畅</li>
<li>与Linux命令全面兼容</li>
</ul>
<h2 id="3、Git结构"><a href="#3、Git结构" class="headerlink" title="3、Git结构"></a>3、Git结构</h2><p>Git分为工作区，暂存区、本地库</p>
<p>工作区用来写代码，暂存区用来临时存储、本地库存储历史版本</p>
<p>在工作区写完代码通过git add命令临时存储到暂存区，然后git commit提交到本地库</p>
<h2 id="4、Git和代码托管中心"><a href="#4、Git和代码托管中心" class="headerlink" title="4、Git和代码托管中心"></a>4、Git和代码托管中心</h2><p>代码托管中心任务：维护远程库</p>
<p>局域网环境下代码托管中心有：GitLab服务器</p>
<p>外网环境下代码托管中心有：码云，github</p>
<h2 id="5、-本地的本地库和代码托管中心的远程库"><a href="#5、-本地的本地库和代码托管中心的远程库" class="headerlink" title="5、 本地的本地库和代码托管中心的远程库"></a>5、 本地的本地库和代码托管中心的远程库</h2><ul>
<li>团队内部协作</li>
<li>跨团队协作</li>
</ul>
<h2 id="6、Git命令行操作"><a href="#6、Git命令行操作" class="headerlink" title="6、Git命令行操作"></a>6、Git命令行操作</h2><h3 id="6-1-本地库初始化"><a href="#6-1-本地库初始化" class="headerlink" title="6.1 本地库初始化"></a>6.1 本地库初始化</h3><p>新建一个文件夹，在此文件夹中打开git bash，输入初始化命令git init</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310175741833.png" alt="image-20210310175741833"></p>
<p>注意：.git隐藏目录下存放的是本地库相关的子目录和文件，不要删除，也不要修改</p>
<h3 id="6-2-设置签名"><a href="#6-2-设置签名" class="headerlink" title="6.2 设置签名"></a>6.2 设置签名</h3><p>形式</p>
<ul>
<li>用户名：wyc</li>
<li>Email地址：<a href="mailto:&#x77;&#x61;&#110;&#103;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;">&#x77;&#x61;&#110;&#103;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a></li>
</ul>
<p>作用：区分不同开发人员的身份</p>
<p>辨析：登录远程库(代码托管中心)的账号，密码和这个设置的签名没有任何关系</p>
<p>命令：</p>
<ul>
<li>项目级别/仓库级别：仅在当前本地库范围内有效<ul>
<li>git config user.name wyc_pro</li>
<li>git config user.email <a href="mailto:&#x77;&#x61;&#x6e;&#103;&#95;&#x70;&#114;&#x6f;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;">&#x77;&#x61;&#x6e;&#103;&#95;&#x70;&#114;&#x6f;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></li>
<li>信息保存位置：.git/config</li>
</ul>
</li>
<li>系统用户级别：登陆当前操作系统的用户范围<ul>
<li>git config –global user.name wyc_glb</li>
<li>git config –globle user.email <a href="mailto:&#119;&#97;&#110;&#103;&#x5f;&#x67;&#108;&#x62;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;">&#119;&#97;&#110;&#103;&#x5f;&#x67;&#108;&#x62;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></li>
<li>信息保存位置：家目录下的gitconfig隐藏文件，~/.gitconfig文件</li>
</ul>
</li>
<li>级别优先级：就近原则，项目级别优先于系统用户级别，二者都有，采用项目级别</li>
<li>二者都没有，不允许这种操作，两种级别最少要设置一个</li>
<li><strong>实际开发中，设置系统用户级别就够了</strong></li>
</ul>
<p>设置项目级别</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310182252278.png" alt="image-20210310182252278"></p>
<p>设置系统用户级别</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310182827338.png" alt="image-20210310182827338"></p>
<h3 id="6-3-基本操作"><a href="#6-3-基本操作" class="headerlink" title="6.3 基本操作"></a>6.3 基本操作</h3><h4 id="6-3-1-状态查看"><a href="#6-3-1-状态查看" class="headerlink" title="6.3.1 状态查看"></a>6.3.1 状态查看</h4><ul>
<li>git status：查看工作区，暂存区状态<ul>
<li>On branch master：在master分区下</li>
<li>No commits yet：本地库没有东西</li>
<li>nothing to commit：暂存区也没有东西</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310190645261.png" alt="image-20210310190645261"></p>
<ul>
<li><p>在创建了一个文件之后再git status，还未放入暂存区</p>
<ul>
<li>Untracked files：表示未被追踪的文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310191427441.png" alt="image-20210310191427441"></p>
</li>
<li><p>将创建的文件放入暂存区</p>
<ul>
<li>放入暂存区命令：git add 文件名</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310192108061.png" alt="image-20210310192108061"></p>
</li>
<li><p>将加入暂存区的文件撤回来，只是将暂存区的文件删除，并不会动工作区文件</p>
<ul>
<li>命令：git rm –cached 文件名</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310192511965.png" alt="image-20210310192511965"></p>
</li>
<li><p>将加入暂存区的文件提交到本地库</p>
<ul>
<li>提交命令：git commit 文件名</li>
<li>快捷方式：git commit -m ”备注的信息“ 文件名</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310192844251.png" alt="image-20210310192844251"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310193453379.png" alt="image-20210310193453379"></p>
</li>
<li><p>修改文件之后，再status</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310193818373.png" alt="image-20210310193818373"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310194428905.png" alt="image-20210310194428905"></p>
</li>
</ul>
<h4 id="6-3-2-查看历史记录"><a href="#6-3-2-查看历史记录" class="headerlink" title="6.3.2 查看历史记录"></a>6.3.2 查看历史记录</h4><ul>
<li><p>命令：git log</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310195202706.png" alt="image-20210310195202706"></p>
</li>
<li><p>以一行的方式显示：git log –pretty=oneline</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310200729683.png" alt="image-20210310200729683"></p>
</li>
<li><p>显示一部分hash值的命令：git log –oneline</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310200850194.png" alt="image-20210310200850194"></p>
</li>
<li><p>显示回到历史版本需要移动几步的命令：git reflog</p>
<ul>
<li>HEAD@{1}：表示移动到此版本需要移动一步</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310201035540.png" alt="image-20210310201035540"></p>
</li>
</ul>
<h4 id="6-3-3-前进后退-修改历史版本"><a href="#6-3-3-前进后退-修改历史版本" class="headerlink" title="6.3.3 前进后退(修改历史版本)"></a>6.3.3 前进后退(修改历史版本)</h4><ul>
<li><p>基于索引值操作【推荐】，reset既可以前进又可以后退，加哪个索引值就跳到哪个版本</p>
<ul>
<li>git reset –hard 索引值</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310203223644.png" alt="image-20210310203223644"></p>
</li>
<li><p>使用^符号：只能后退，一个^表示后退一步，n个后退n步</p>
<ul>
<li>往后退一步命令：git reset –hard HEAD^</li>
<li>往后退两步命令：git reset –hard HEAD^^</li>
</ul>
</li>
<li><p>使用~符号：只能后退</p>
<ul>
<li>往后退n步命令：git reset –hard HEAD~n</li>
</ul>
</li>
<li><p>reset命令的三个参数对比</p>
<ul>
<li>git reset –hard：在本地库移动HEAD指针，重置暂存区，重置工作区</li>
<li>git reset –soft：仅仅在本地库移动HEAD指针</li>
<li>git reset –mixed：在本地库移动HEAD指针，重置暂存区</li>
</ul>
</li>
</ul>
<h4 id="6-3-4-删除文件"><a href="#6-3-4-删除文件" class="headerlink" title="6.3.4 删除文件"></a>6.3.4 删除文件</h4><ul>
<li><p>将aaa.txt添加到本地库中再删除文件</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310211651287.png" alt="image-20210310211651287"></p>
</li>
<li><p>再查询历史记录，发现指向delete aaa.txt这条记录，回退到上一条new aaa.txt则能重新找回aaa.txt</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310212031041.png" alt="image-20210310212031041"></p>
</li>
<li><p>当删除文件之后提交到暂存区，未提交到本地库中，该如何恢复</p>
<ul>
<li>命令 git reset –hard HEAD</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310213128406.png" alt="image-20210310213128406"></p>
</li>
<li><p>删除的文件并找回</p>
<ul>
<li>前提：删除前，这个文件存在时的状态提交到了本地库</li>
<li>操作：用git reset –hard [指针位置]，<ul>
<li>删除操作已经提交到本地库：指针位置找历史存在的记录</li>
<li>删除操作尚未提交到本地库：指针位置使用HEAD</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-5-比较文件差异"><a href="#6-3-5-比较文件差异" class="headerlink" title="6.3.5 比较文件差异"></a>6.3.5 比较文件差异</h4><ul>
<li><p>修改apple.txt文件之后比较与原apple.txt之间的差异(添加到暂存区之后就没有区别)</p>
<ul>
<li>命令：git diff 文件名<ul>
<li>将工作区中的文件和暂存区的文件进行比较</li>
</ul>
</li>
<li>git diff [本地库中历史版本] 文件名<ul>
<li>将工作区中的文件和本地库历史记录比较</li>
</ul>
</li>
<li>不带文件名比较多个文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310213934720.png" alt="image-20210310213934720"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310214225619.png" alt="image-20210310214225619"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210310214700454.png" alt="image-20210310214700454"></p>
</li>
</ul>
<h2 id="7、分支管理"><a href="#7、分支管理" class="headerlink" title="7、分支管理"></a>7、分支管理</h2><p>什么是分支？</p>
<ul>
<li>在版本控制过程中，使用多条线同时推进多个任务</li>
</ul>
<p>分支的好处</p>
<ul>
<li>同时并行推进多个功能的开发，提高开发效率</li>
<li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可</li>
</ul>
<p>命令</p>
<ul>
<li><p>查看所有分支：git branch -v</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311085810087.png" alt="image-20210311085810087"></p>
</li>
<li><p>创建一个hot_fix分支：git branch hot_fix</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311085930059.png" alt="image-20210311085930059"></p>
</li>
<li><p>切换分支：git checkout hot_fix</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311090112619.png" alt="image-20210311090112619"></p>
</li>
<li><p>在hot_fix分支修改文件，在提交到暂存区和本地库，此时查看分支状态，发现hot_fix版本往前推进一步</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311090654244.png" alt="image-20210311090654244"></p>
</li>
<li><p>合并分支：</p>
<ul>
<li>第一步：切换到接受修改的分支上(被合并的)</li>
<li>第二步：执行merge命令</li>
<li>例如，hot_fix分支的修改合并到master上，先切换到master</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311091352130.png" alt="image-20210311091352130"></p>
</li>
<li><p>解决冲突：当两个分支同时修改同一个文件的同一处，而内容又不一致，则当合并后应该遵循哪个修改的，这就会导致冲突</p>
<ul>
<li>两个分支都修改good.txt文件第一行，全都提交到本地库，则会发现两个分支的所在版本不同，此时合并，修改内容相同则冲突</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311092603821.png" alt="image-20210311092603821"></p>
<ul>
<li>在hot_fix分支下合并master分支，显示合并失败，此时后面分支为hot_fix|MERGING，需要手动合并</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311093044343.png" alt="image-20210311093044343"></p>
<ul>
<li>打开修改过后的文件，good.txt</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311093835348.png" alt="image-20210311093835348"></p>
<ul>
<li>删除特殊符号，修改文件至满意为止</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311094154222.png" alt="image-20210311094154222"></p>
<ul>
<li>然后git add将good.txt标记为已解决，使用get commit结束合并</li>
<li>注意：<strong>此时git commit命令后面不能跟文件名</strong></li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311094717222.png" alt="image-20210311094717222"></p>
</li>
</ul>
<h2 id="8、GitHub操作"><a href="#8、GitHub操作" class="headerlink" title="8、GitHub操作"></a>8、GitHub操作</h2><h3 id="8-1-创建远程库"><a href="#8-1-创建远程库" class="headerlink" title="8.1 创建远程库"></a>8.1 创建远程库</h3><ul>
<li>登录Github，创建远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311123102997.png" alt="image-20210311123102997"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311125657555.png" alt="image-20210311125657555"></p>
<h3 id="8-2-在本地创建远程库别名-推送-克隆-拉取"><a href="#8-2-在本地创建远程库别名-推送-克隆-拉取" class="headerlink" title="8.2 在本地创建远程库别名/推送/克隆/拉取"></a>8.2 在本地创建远程库别名/推送/克隆/拉取</h3><ul>
<li>远程库地址</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311131514656.png" alt="image-20210311131514656"></p>
<ul>
<li>在本地库给远程库地址起别名，以后用别名代替地址比较方便<ul>
<li>命令：git remote add 别名 地址</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311131821124.png" alt="image-20210311131821124"></p>
<ul>
<li><p>移除远程库别名</p>
<ul>
<li>命令：git remote remove 别名</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210321092115267.png" alt="image-20210321092115267"></p>
</li>
<li><p>推送：git push 别名 分支名，需要输入github账户和密码</p>
<ul>
<li>此时，已经将本地库中的文件推送到远程库中了</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311134007431.png" alt="image-20210311134007431"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311134500378.png" alt="image-20210311134500378"></p>
<ul>
<li>克隆：git clone 远程地址<ul>
<li>完整的把远程库下载到本地</li>
<li>创建origin远程地址别名</li>
<li>初始化本地库</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311135324348.png" alt="image-20210311135324348"></p>
<p><strong>注意：</strong>现在test00本地库是上传到HaloTest00账号的远程库，而在test01本地库中克隆了test00远程库，此时在test01本地库中修改文件，然后再上传到远程库，因为上传到远程库需要输入账号密码，而继续上传到HaloTest00账号的远程库没有问题，但是如果使用别的账号上传则会报错，因为需要添加团队成员</p>
<ul>
<li>此时，test01修改文件，提交到本地库没有问题</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311141341193.png" alt="image-20210311141341193"></p>
<ul>
<li>此时使用HaloTest01的账号密码将本地库推送到HaloTest00的远程库，发现失败，因为HaloTest01未加如HaloTest00团队</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311142208811.png" alt="image-20210311142208811"></p>
<ul>
<li>将HaloTest01加入到HaloTest00团队，在邮件中同意邀请就可以了</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311142423063.png" alt="image-20210311142423063"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311142457060.png" alt="image-20210311142457060"></p>
<ul>
<li>此时HaloTest01加入团队，使用HaloTest01账号推送到远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311145154629.png" alt="image-20210311145154629"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311145216836.png" alt="image-20210311145216836"></p>
<ul>
<li>HaloTest01修改文件提交到远程库之后HaloTest00拉取远程库</li>
<li>使用git fetch origin master抓取之后，发现工作区的文件内容还是未变</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311150058764.png" alt="image-20210311150058764"></p>
<ul>
<li>通过git checkout origin/master 命令可以查看下载下来的远程库中文件内容</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311150422810.png" alt="image-20210311150422810"></p>
<ul>
<li>整个抓取pull操作，分为fetch和merge两步，fetch先下载到本地库(此时未修改工作区文件)看看有没有什么错误，然后merge再合并过来<ul>
<li>git fetch [远程地址别名] [远程分支名]</li>
<li>git merge [远程地址别名/远程分支名]</li>
</ul>
</li>
<li>也可以直接使用pull来操作<ul>
<li>git pull origin master</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311150625229.png" alt="image-20210311150625229"></p>
<h3 id="8-3-解决冲突"><a href="#8-3-解决冲突" class="headerlink" title="8.3 解决冲突"></a>8.3 解决冲突</h3><p>要点：</p>
<ul>
<li>如果不是基于GitHub远程库的最新版所做的修改，不能推送，必须拉取</li>
<li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可</li>
</ul>
<p>操作：</p>
<ul>
<li>首先HostTest00修改文件上传到远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154240563.png" alt="image-20210311154240563"></p>
<ul>
<li>此时HaloTest01中用的还是老版本</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154400871.png" alt="image-20210311154400871"></p>
<ul>
<li>然后HaloTest01在此基础上修改文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154453020.png" alt="image-20210311154453020"></p>
<ul>
<li>然后提交到本地库中，准备上传到远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154709216.png" alt="image-20210311154709216"></p>
<ul>
<li>上传到远程库，使用HaloTest01账号，因为是团队成员，结果发现上传失败，因为修改冲突</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154909449.png" alt="image-20210311154909449"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311154925259.png" alt="image-20210311154925259"></p>
<ul>
<li>上传不上去，此时提醒你必须先拿到远程库中的最新文件，此时发现进入解决冲突模式</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311155522145.png" alt="image-20210311155522145"></p>
<ul>
<li>然后将文件修改至满意为止</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311155642149.png" alt="image-20210311155642149"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311155725646.png" alt="image-20210311155725646"></p>
<ul>
<li>之后上传到本地库，解决冲突</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311155901863.png" alt="image-20210311155901863"></p>
<ul>
<li>之后可以再次上传到远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311160102612.png" alt="image-20210311160102612"></p>
<h3 id="8-4-跨团队协作"><a href="#8-4-跨团队协作" class="headerlink" title="8.4 跨团队协作"></a>8.4 跨团队协作</h3><ul>
<li>HaloTest02这个团队想要和HaloTest00团队(包含队员HaloTest01)合作</li>
<li>HaloTest02需要<strong>fork</strong> HaloTest00的远程库项目</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311161713867.png" alt="image-20210311161713867"></p>
<ul>
<li>fork完成之后</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311162304960.png" alt="image-20210311162304960"></p>
<ul>
<li>此时创建HaloTest02的文件夹，从HaloTest02的远程库中clone文件下来</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311163624275.png" alt="image-20210311163624275"></p>
<ul>
<li>克隆下来，本地库已经初始化好了，修改文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311163749120.png" alt="image-20210311163749120"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311163900876.png" alt="image-20210311163900876"></p>
<ul>
<li>然后进行上传到远程库操作，使用HaloTest02的账号密码</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311165129555.png" alt="image-20210311165129555"></p>
<ul>
<li>此时HaloTest02对文件操作完成</li>
<li>然后向HaloTest00执行pull request操作</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311165249153.png" alt="image-20210311165249153"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311171259987.png" alt="image-20210311171259987"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311171343873.png" alt="image-20210311171343873"></p>
<ul>
<li>然后进入HaloTest00中</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311171555506.png" alt="image-20210311171555506"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311171620559.png" alt="image-20210311171620559"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210311171709518.png" alt="image-20210311171709518"></p>
<h2 id="9、IDEA中Git的使用"><a href="#9、IDEA中Git的使用" class="headerlink" title="9、IDEA中Git的使用"></a>9、IDEA中Git的使用</h2><ul>
<li>IDEA中配置Git路径，GitHub账号密码</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312095827811.png" alt="image-20210312095827811"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312095854898.png" alt="image-20210312095854898"></p>
<h3 id="9-1-IDEA创建本地库"><a href="#9-1-IDEA创建本地库" class="headerlink" title="9.1 IDEA创建本地库"></a>9.1 IDEA创建本地库</h3><p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312100720764.png" alt="image-20210312100720764"></p>
<ul>
<li>选择本地库文件夹，点击OK，发现此文件夹下出现.git文件夹，因此，git_practice文件夹成为为本地库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312100838303.png" alt="image-20210312100838303"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312100959848.png" alt="image-20210312100959848"></p>
<ul>
<li>称为本地库之后，发现文件变红，表示未添加到暂存区，同时上方工具栏也会出现Git常用的操作</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312101626156.png" alt="image-20210312101626156"></p>
<ul>
<li>并且此时设置中也会显示git_practice文件夹被Git管理</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312101829265.png" alt="image-20210312101829265"></p>
<ul>
<li>此时创建新文件会显示是否要将此文件添加到暂存区，选择取消，以后手动添加</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312102049358.png" alt="image-20210312102049358"></p>
<ul>
<li>此时我们自己创建的文件以后需要放入远程库，但是IDEA自动生成的文件却不需要放入暂存区，以免不同版本IDEA会发生冲突，所以我们需要忽略这些IDEA自动生成的文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312122046312.png" alt="image-20210312122046312"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312122522170.png" alt="image-20210312122522170"></p>
<ul>
<li>忽略之后iml文件颜色变了</li>
</ul>
<h3 id="9-2-add到暂存区-commit到本地库"><a href="#9-2-add到暂存区-commit到本地库" class="headerlink" title="9.2 add到暂存区/commit到本地库"></a>9.2 add到暂存区/commit到本地库</h3><ul>
<li>添加到暂存区</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312123039232.png" alt="image-20210312123039232"></p>
<ul>
<li>添加到暂存区之后颜色改变，.gitignore也提交到暂存区</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312125859750.png" alt="image-20210312125859750"></p>
<ul>
<li>commit到本地库，两种方式</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312125936293.png" alt="image-20210312125936293"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312130005269.png" alt="image-20210312130005269"></p>
<ul>
<li>之后直接commit就可以</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312130117103.png" alt="image-20210312130117103"></p>
<ul>
<li>提交到本地库之后颜色再次变化</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312130208515.png" alt="image-20210312130208515"></p>
<h3 id="9-3-切换版本"><a href="#9-3-切换版本" class="headerlink" title="9.3 切换版本"></a>9.3 切换版本</h3><ul>
<li>修改之后直接提交，一共四个版本</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312131908494.png" alt="image-20210312131908494"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312132107242.png" alt="image-20210312132107242"></p>
<ul>
<li>查看历史版本，出现此界面</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312132140491.png" alt="image-20210312132140491"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312132218540.png" alt="image-20210312132218540"></p>
<ul>
<li>选择你要切换回的历史版本，右键复制版本号</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312133011520.png" alt="image-20210312133011520"></p>
<ul>
<li>然后reset HEAD</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312133105246.png" alt="image-20210312133105246"></p>
<ul>
<li>填入历史版本号</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312133352626.png" alt="image-20210312133352626"></p>
<ul>
<li>之后就回退到版本1</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312133503950.png" alt="image-20210312133503950"></p>
<ul>
<li>回退之后就不能再回到最新的版本3了，如果想回到版本3，需要用命令行形式</li>
</ul>
<h3 id="9-4-创建分支与合并分支"><a href="#9-4-创建分支与合并分支" class="headerlink" title="9.4 创建分支与合并分支"></a>9.4 创建分支与合并分支</h3><ul>
<li>创建分支</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312134051283.png" alt="image-20210312134051283"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312134215373.png" alt="image-20210312134215373"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312134249145.png" alt="image-20210312134249145"></p>
<p>到此，hot_fix分支创建完成，</p>
<ul>
<li>查看所处分支，与切换分支</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312134445235.png" alt="image-20210312134445235"></p>
<ul>
<li>合并分支，先在hot_fix分支上修改，然后commit</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135007817.png" alt="image-20210312135007817"></p>
<ul>
<li>切换回master分支，合并hot_fix分支内容</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135129350.png" alt="image-20210312135129350"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135220815.png" alt="image-20210312135220815"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135242532.png" alt="image-20210312135242532"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135447196.png" alt="image-20210312135447196"></p>
<ul>
<li>分支合并完成</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312135515823.png" alt="image-20210312135515823"></p>
<h3 id="9-5-解决冲突"><a href="#9-5-解决冲突" class="headerlink" title="9.5 解决冲突"></a>9.5 解决冲突</h3><ul>
<li>分支与主干在同一个地方添加代码，然后再合并就会出现冲突</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140213605.png" alt="image-20210312140213605"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140327963.png" alt="image-20210312140327963"></p>
<ul>
<li>切换到master分支，合并hot_fix分支内容</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140517852.png" alt="image-20210312140517852"></p>
<ul>
<li>此时出现冲突问题，点击merge</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140804201.png" alt="image-20210312140804201"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140910593.png" alt="image-20210312140910593"></p>
<ul>
<li>移过来之后或者自定义的结果，然后点击apply</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312140938569.png" alt="image-20210312140938569"></p>
<ul>
<li>此时冲突解决，并自动commit了</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141029875.png" alt="image-20210312141029875"></p>
<h3 id="9-6-本地库上传到远程库-GitHub"><a href="#9-6-本地库上传到远程库-GitHub" class="headerlink" title="9.6 本地库上传到远程库(GitHub)"></a>9.6 本地库上传到远程库(GitHub)</h3><ul>
<li>在GitHub上创建一个远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141429686.png" alt="image-20210312141429686"></p>
<ul>
<li>复制地址</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141550593.png" alt="image-20210312141550593"></p>
<ul>
<li>本地库push到远程库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141634291.png" alt="image-20210312141634291"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141805020.png" alt="image-20210312141805020"></p>
<ul>
<li>点击push即可提交</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312141914508.png" alt="image-20210312141914508"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312142713879.png" alt="image-20210312142713879"></p>
<h3 id="9-7-更新本地库"><a href="#9-7-更新本地库" class="headerlink" title="9.7 更新本地库"></a>9.7 更新本地库</h3><ul>
<li>当远程库有修改时，更新本地库</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312143456553.png" alt="image-20210312143456553"></p>
<ul>
<li>此时远程库有改动，本地库此时先push到远程库会失败，会被push rejected，拒绝</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312143757449.png" alt="image-20210312143757449"></p>
<p>此时需要将远程库的文件merge到本地库，再上传到远程库，点击merge，此时本地库就会同步远程库</p>
<ul>
<li>第二种方式直接将远程库的文件拉取下来</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312144812008.png" alt="image-20210312144812008"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312144835299.png" alt="image-20210312144835299"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312144916382.png" alt="image-20210312144916382"></p>
<h3 id="9-8-克隆GitHub项目"><a href="#9-8-克隆GitHub项目" class="headerlink" title="9.8 克隆GitHub项目"></a>9.8 克隆GitHub项目</h3><ul>
<li>打开github项目，复制地址</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312145135815.png" alt="image-20210312145135815"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312145228649.png" alt="image-20210312145228649"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312145343400.png" alt="image-20210312145343400"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312145830275.png" alt="image-20210312145830275"></p>
<ul>
<li>复制下来的文件</li>
</ul>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210312150522107.png" alt="image-20210312150522107"></p>
<h2 id="10、SSH密匙方式"><a href="#10、SSH密匙方式" class="headerlink" title="10、SSH密匙方式"></a>10、SSH密匙方式</h2><p>首先生成密匙，输入此命令</p>
<p>ssh-keygen -t rsa -C “github邮箱”</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210320185255337.png" alt="image-20210320185255337"></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210320185323129.png" alt="image-20210320185323129"></p>
<p>此时，密匙已经生成到c/Users/王迎春/.ssh/id_rsa.pub文件中</p>
<p>此时复制id_rsa.pub文件的内容，在github中添加key</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210320190404837.png" alt="image-20210320190404837"></p>
<p>检查测试连接，执行命令，显示success则成功</p>
<p>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;</a></p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210320185950523.png" alt="image-20210320185950523"></p>
<p>之后就可以直接使用ssh密匙来clone和push项目，不用输入密码</p>
<p><img src="/2020/10/15/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20210321093019644.png" alt="image-20210321093019644"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML&amp;CSS简单入门</title>
    <url>/2020/09/12/HTML&amp;CSS/</url>
    <content><![CDATA[<h2 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>html:Hyper Text Markup Language 超文本标记语言</p>
<h4 id="1-2-书写规范"><a href="#1-2-书写规范" class="headerlink" title="1.2 书写规范"></a>1.2 书写规范</h4><pre><code class="html">&lt;html&gt; 表示整个 html 页面的开始 
    &lt;head&gt; 头信息 
        &lt;title&gt;标题&lt;/title&gt; 标题 
    &lt;/head&gt; 
    &lt;body&gt; body 是页面的主体内容 
        页面主体内容 
    &lt;/body&gt;
&lt;/html&gt; 表示整个 html 页面的结束
</code></pre>
<h4 id="1-3-HTMl标签语法"><a href="#1-3-HTMl标签语法" class="headerlink" title="1.3 HTMl标签语法"></a>1.3 HTMl标签语法</h4><pre><code class="html">&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;0-标签语法.html&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;!-- ①标签不能交叉嵌套 --&gt;
    正确：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/span&gt;&lt;/div&gt;
    错误：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/div&gt;&lt;/span&gt;
    &lt;hr /&gt;

    &lt;!-- ②标签必须正确关闭(闭合) --&gt;
    &lt;!-- i.有文本内容的标签： --&gt;
    正确：&lt;div&gt;早安，尚硅谷&lt;/div&gt;
    错误：&lt;div&gt;早安，尚硅谷
    &lt;hr /&gt;
    
    &lt;!-- ii.没有文本内容的标签： --&gt;
    正确：&lt;br /&gt;1
    错误：&lt;br &gt;2
    &lt;hr /&gt;
    
    &lt;!-- ③属性必须有值，属性值必须加引号 --&gt;
    正确：&lt;font color=&quot;blue&quot;&gt;早安，尚硅谷&lt;/font&gt;
    错误：&lt;font color=blue&gt;早安，尚硅谷&lt;/font&gt;
    错误：&lt;font color&gt;早安，尚硅谷&lt;/font&gt;
    &lt;hr /&gt;
        
    &lt;!-- ④注释不能嵌套 --&gt;
    正确：&lt;!-- 注释内容 --&gt; &lt;br/&gt;
    错误：&lt;!-- 注释内容 &lt;!-- 注释内容 --&gt;--&gt;
    &lt;hr /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="1-4-font标签"><a href="#1-4-font标签" class="headerlink" title="1.4 font标签"></a>1.4 font标签</h4><pre><code class="html">&lt;body&gt;
    &lt;!-- 字体标签
     需求1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。

     font标签是字体标签,它可以用来修改文本的字体,颜色,大小(尺寸)
         color属性修改颜色
         face属性修改字体
         size属性修改文本大小
     --&gt;
    &lt;font color=&quot;red&quot; face=&quot;宋体&quot; size=&quot;7&quot;&gt;我是字体标签&lt;/font&gt;
&lt;/body&gt;
</code></pre>
<h4 id="1-5-特殊字符"><a href="#1-5-特殊字符" class="headerlink" title="1.5 特殊字符"></a>1.5 特殊字符</h4><pre><code class="html">&lt;body&gt;
    &lt;!-- 特殊字符
    需求1：把 &lt;br&gt; 换行标签 变成文本 转换成字符显示在页面上

    常用的特殊字符:
        &lt;    ===&gt;&gt;&gt;&gt;        &amp;lt;
        &gt;   ===&gt;&gt;&gt;&gt;        &amp;gt;
      空格    ===&gt;&gt;&gt;&gt;        &amp;nbsp;

     --&gt;
    我是&amp;lt;br&amp;gt;标签&lt;br/&gt;
    Hello&amp;nbsp;&amp;nbsp;html
&lt;/body&gt;
</code></pre>
<h4 id="1-6-标题标签"><a href="#1-6-标题标签" class="headerlink" title="1.6 标题标签"></a>1.6 标题标签</h4><pre><code class="html">&lt;body&gt;
    &lt;!-- 标题标签
     需求1：演示标题1到 标题6的

         h1 - h6 都是标题标签
         h1 最大
         h6 最小
            align 属性是对齐属性
                left        左对齐(默认)
                center        剧中
                right        右对齐
     --&gt;
    &lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt;
    &lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt;
    &lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt;
    &lt;h4&gt;标题4&lt;/h4&gt;
    &lt;h5&gt;标题5&lt;/h5&gt;
    &lt;h6&gt;标题6&lt;/h6&gt;
    &lt;h7&gt;标题7&lt;/h7&gt;
&lt;/body&gt;
</code></pre>
<h4 id="1-7-超链接"><a href="#1-7-超链接" class="headerlink" title="1.7 超链接"></a>1.7 超链接</h4><pre><code class="html">&lt;body&gt;
    &lt;!-- a标签是 超链接
             href属性设置连接的地址
             target属性设置哪个目标进行跳转
                 _self        表示当前页面(默认值)
                 _blank        表示打开新页面来进行跳转
     --&gt;
    &lt;a href=&quot;http://localhost:8080&quot;&gt;百度&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_self&quot;&gt;百度_self&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot;&gt;百度_blank&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;
</code></pre>
<h4 id="1-8-img标签"><a href="#1-8-img标签" class="headerlink" title="1.8 img标签"></a>1.8 img标签</h4><pre><code class="html">&lt;body&gt;
    &lt;!--需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性

        img标签是图片标签,用来显示图片
            src属性可以设置图片的路径
            width属性设置图片的宽度
            height属性设置图片的高度
            border属性设置图片边框大小
            alt属性设置当指定路径找不到图片时,用来代替显示的文本内容

        在JavaSE中路径也分为相对路径和绝对路径.
            相对路径:从工程名开始算

            绝对路径:盘符:/目录/文件名

        在web中路径分为相对路径和绝对路径两种
            相对路径:
                .           表示当前文件所在的目录
                ..          表示当前文件所在的上一级目录
                文件名      表示当前文件所在目录的文件,相当于 ./文件名            ./ 可以省略

            绝对路径:
                正确格式是:  http://ip:port/工程名/资源路径

                错误格式是:  盘符:/目录/文件名
    --&gt;
    &lt;img src=&quot;../img/1.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; border=&quot;1&quot; alt=&quot;美女找不到&quot;/&gt;
    &lt;img src=&quot;../../2.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; alt=&quot;找不到&quot;/&gt;
    &lt;img src=&quot;../imgs/3.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;
    &lt;img src=&quot;../imgs/4.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;
    &lt;img src=&quot;../imgs/5.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;
    &lt;img src=&quot;../imgs/6.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;
&lt;/body&gt;
</code></pre>
<h4 id="1-9-表格标签"><a href="#1-9-表格标签" class="headerlink" title="1.9 表格标签"></a>1.9 表格标签</h4><pre><code class="html">&lt;body&gt;
&lt;!--
    需求1：做一个 带表头的 ，三行，三列的表格，并显示边框
    需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。

        table 标签是表格标签
            border 设置表格标签
            width 设置表格宽度
            height 设置表格高度
            align 设置表格相对于页面的对齐方式
            cellspacing 设置单元格间距

        tr     是行标签
        th    是表头标签
        td  是单元格标签
            align 设置单元格文本对齐方式

        b 是加粗标签
        th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本
    --&gt;
&lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;300&quot; height=&quot;300&quot; cellspacing=&quot;0&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;1.1&lt;/th&gt;
        &lt;td&gt;1.2&lt;/td&gt;
        &lt;td&gt;1.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td&gt;2.1&lt;/td&gt;
        &lt;td&gt;2.2&lt;/td&gt;
        &lt;td&gt;2.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;3.1&lt;/td&gt;
        &lt;td&gt;3.2&lt;/td&gt;
        &lt;td&gt;3.3&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
    &lt;!--    表格跨行跨列：
            新建一个五行，五列的表格，
            第一行，第一列的单元格要跨两列，
            第二行第一列的单元格跨两行，
            第四行第四列的单元格跨两行两列。

            colspan 属性设置跨列
            rowspan 属性设置跨行
            --&gt;
    &lt;table width=&quot;500&quot; height=&quot;500&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt;
            &lt;tr&gt;
                &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt;
                &lt;td&gt;1.3&lt;/td&gt;
                &lt;td&gt;1.4&lt;/td&gt;
                &lt;td&gt;1.5&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td rowspan=&quot;2&quot;&gt;2.1&lt;/td&gt;
                &lt;td&gt;2.2&lt;/td&gt;
                &lt;td&gt;2.3&lt;/td&gt;
                &lt;td&gt;2.4&lt;/td&gt;
                &lt;td&gt;2.5&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;3.2&lt;/td&gt;
                &lt;td&gt;3.3&lt;/td&gt;
                &lt;td&gt;3.4&lt;/td&gt;
                &lt;td&gt;3.5&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;4.1&lt;/td&gt;
                &lt;td&gt;4.2&lt;/td&gt;
                &lt;td&gt;4.3&lt;/td&gt;
                &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;4.4&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;5.1&lt;/td&gt;
                &lt;td&gt;5.2&lt;/td&gt;
                &lt;td&gt;5.3&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
&lt;/body&gt;
</code></pre>
<h4 id="2-0-iframe标签"><a href="#2-0-iframe标签" class="headerlink" title="2.0 iframe标签"></a>2.0 iframe标签</h4><pre><code class="html">&lt;body&gt;
    我是一个单独的完整的页面&lt;br/&gt;&lt;br/&gt;
    &lt;!--ifarme标签可以在页面上开辟一个小区域显示一个单独的页面
            ifarme和a标签组合使用的步骤:
                1 在iframe标签中使用name属性定义一个名称
                2 在a标签的target属性上设置iframe的name的属性值
    --&gt;
    &lt;iframe src=&quot;3.标题标签.html&quot; width=&quot;500&quot; height=&quot;400&quot; name=&quot;abc&quot;&gt;&lt;/iframe&gt;
    &lt;br/&gt;

    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;0-标签语法.html&quot; target=&quot;abc&quot;&gt;0-标签语法.html&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;1.font标签.html&quot; target=&quot;abc&quot;&gt;1.font标签.html&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;2.特殊字符.html&quot; target=&quot;abc&quot;&gt;2.特殊字符.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>
<h4 id="2-1-列表标签"><a href="#2-1-列表标签" class="headerlink" title="2.1 列表标签"></a>2.1 列表标签</h4><pre><code class="html">&lt;body&gt;
    &lt;!--需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来
        ul 是无序列表
            type属性可以修改列表项前面的符号
        li  是列表项
    --&gt;
    &lt;ul type=&quot;none&quot;&gt;
        &lt;li&gt;赵四&lt;/li&gt;
        &lt;li&gt;刘能&lt;/li&gt;
        &lt;li&gt;小沈阳&lt;/li&gt;
        &lt;li&gt;宋小宝&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>
<h4 id="2-2-form标签-重要"><a href="#2-2-form标签-重要" class="headerlink" title="2.2 form标签(重要)"></a>2.2 form标签(重要)</h4><pre><code class="html">&lt;body&gt;
&lt;!--需求1:创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉列表）。
隐藏域，自我评价（多行文本域）。重置，提交。--&gt;
    &lt;!--
        form标签就是表单
            input type=text     是文件输入框  value设置默认显示内容
            input type=password 是密码输入框  value设置默认显示内容
            input type=radio    是单选框    name属性可以对其进行分组   checked=&quot;checked&quot;表示默认选中
            input type=checkbox 是复选框   checked=&quot;checked&quot;表示默认选中
            input type=reset    是重置按钮      value属性修改按钮上的文本
            input type=submit   是提交按钮      value属性修改按钮上的文本
            input type=button   是按钮          value属性修改按钮上的文本
            input type=file     是文件上传域
            input type=hidden   是隐藏域    当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）
            select 标签是下拉列表框
            option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中

            textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值）
                rows 属性设置可以显示几行的高度
                cols 属性设置每行可以显示几个字符宽度
    --&gt;
    &lt;form&gt;
        &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt;
        &lt;table align=&quot;center&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt; 用户名称：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt; 用户密码：&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;确认密码：&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;性别：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男
                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;  /&gt;女
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt; 兴趣爱好：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;Java
                    &lt;input type=&quot;checkbox&quot; /&gt;JavaScript
                    &lt;input type=&quot;checkbox&quot; /&gt;C++
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;国籍：&lt;/td&gt;
                &lt;td&gt;
                    &lt;select&gt;
                        &lt;option&gt;--请选择国籍--&lt;/option&gt;
                        &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt;
                        &lt;option&gt;美国&lt;/option&gt;
                        &lt;option&gt;小日本&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;自我评价：&lt;/td&gt;
                &lt;td&gt;&lt;textarea rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;默认值&quot;/&gt;&lt;/td&gt;
                &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot;/&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<h4 id="2-3-form表单提交注意事项"><a href="#2-3-form表单提交注意事项" class="headerlink" title="2.3 form表单提交注意事项"></a>2.3 form表单提交注意事项</h4><pre><code class="html">&lt;body&gt;
    &lt;!--
        form标签是表单标签
            action属性设置提交的服务器地址
            method属性设置提交的方式GET(默认值)或POST

        表单提交的时候，数据没有发送给服务器的三种情况：
            1、表单项没有name属性值
            2、单选、复选（下拉列表中的option标签）都需要添加value属性，以便发送给服务器
            3、表单项不在提交的form标签中

        GET请求的特点是：
            1、浏览器地址栏中的地址是：action属性[+?+请求参数]
                请求参数的格式是：name=value&amp;name=value
            2、不安全
            3、它有数据长度的限制

        POST请求的特点是：
            1、浏览器地址栏中只有action属性值
            2、相对于GET请求要安全
            3、理论上没有数据长度的限制


            http://localhost:8080/?action=login&amp;username=%E9%BB%98%E8%AE%A4%E5%80%BC&amp;password=abc&amp;sex=girl&amp;hobby=java&amp;country=cn&amp;desc=%E6%88%91%E6%89%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%80%BC
    --&gt;
    &lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;hidden&quot; value=&quot;login&quot; /&gt;
        &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt;
        &lt;table align=&quot;center&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt; 用户名称：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt; 用户密码：&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;性别：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot;/&gt;男
                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; value=&quot;girl&quot; /&gt;女
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt; 兴趣爱好：&lt;/td&gt;
                &lt;td&gt;
                    &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;java&quot;/&gt;Java
                    &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;js&quot;/&gt;JavaScript
                    &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;cpp&quot;/&gt;C++
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;国籍：&lt;/td&gt;
                &lt;td&gt;
                    &lt;select name=&quot;country&quot;&gt;
                        &lt;option value=&quot;none&quot;&gt;--请选择国籍--&lt;/option&gt;
                        &lt;option value=&quot;cn&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt;
                        &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt;
                        &lt;option value=&quot;jp&quot;&gt;小日本&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;自我评价：&lt;/td&gt;
                &lt;td&gt;&lt;textarea name=&quot;desc&quot; rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt;
            &lt;/tr&gt;
             &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt;
                &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot;/&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<h4 id="2-4-其他标签"><a href="#2-4-其他标签" class="headerlink" title="2.4 其他标签"></a>2.4 其他标签</h4><pre><code class="html">&lt;body&gt;
        &lt;!--需求1：div、span、p标签的演示
            div标签       默认独占一行
            span标签      它的长度是封装数据的长度
            p段落标签     默认会在段落的上方或下方各空出一行来（如果已有就不再空）
        --&gt;
    &lt;div&gt;div标签1&lt;/div&gt;
    &lt;div&gt;div标签2&lt;/div&gt;
    &lt;span&gt;span标签1&lt;/span&gt;
    &lt;span&gt;span标签2&lt;/span&gt;
    &lt;p&gt;p段落标签1&lt;/p&gt;
    &lt;p&gt;p段落标签2&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><ul>
<li>CSS 是「层叠样式表单」。是用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。</li>
</ul>
<h4 id="1-2-语法规则"><a href="#1-2-语法规则" class="headerlink" title="1.2 语法规则"></a>1.2 语法规则</h4><p><img src="/2020/09/12/HTML&CSS/image-20200906143015187.png" alt="image-20200906143015187"></p>
<ul>
<li>选择器：浏览器根据“选择器”决定受 CSS 样式影响的 HTML 元素（标签）。</li>
<li> 属性 (property) 是你要改变的样式名，并且每个属性都有一个值。属性和值被冒号分开，并由花括号包围，这样就组成了一个完的样式声明（declaration），例如：p{color:blue}</li>
<li>多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明的最后可以不加分号(但尽量在每条声明的末尾都加上分号)</li>
</ul>
<h4 id="1-3-CSS与HTML结合方式"><a href="#1-3-CSS与HTML结合方式" class="headerlink" title="1.3 CSS与HTML结合方式"></a>1.3 CSS与HTML结合方式</h4><pre><code class="html">&lt;!--方式一--&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。--&gt;
    &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签1&lt;/div&gt;
    &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签2&lt;/div&gt;
    &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签1&lt;/span&gt;
    &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签2&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!--方式二--&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--style标签专门用来定义css样式代码--&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        /* 需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。*/
        div&#123;
            border: 1px solid red;
        &#125;
        span&#123;
            border: 1px solid red;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;div标签1&lt;/div&gt;
    &lt;div&gt;div标签2&lt;/div&gt;

    &lt;span&gt;span标签1&lt;/span&gt;
    &lt;span&gt;span标签2&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!--方式三--&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--link标签专门用来引入css样式代码--&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;/&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;div标签1&lt;/div&gt;
    &lt;div&gt;div标签2&lt;/div&gt;

    &lt;span&gt;span标签1&lt;/span&gt;
    &lt;span&gt;span标签2&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="1-4-CSS选择器"><a href="#1-4-CSS选择器" class="headerlink" title="1.4 CSS选择器"></a>1.4 CSS选择器</h4><ul>
<li>标签选择器 格式：标签名{ 属性：值; }</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
    div&#123;
        border: 1px solid yellow;
        color: blue;
        font-size: 30px;
    &#125;
    span&#123;
        border: 5px dashed  blue;
        color: yellow;
        font-size: 20px;
    &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>id选择器 格式：#id名{ 属性：值; }</li>
</ul>
<pre><code class="html">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ID选择器&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;

        #id001&#123;
            color: blue;
            font-size: 30px;
            border: 1px yellow solid;
        &#125;

        #id002&#123;
            color: red;
            font-size: 20px;
            border: 5px blue dotted ;
        &#125;

    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;        
    &lt;!--
    需求1：分别定义两个 div 标签，
    第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色，
    字体大小30个像素。边框为1像素黄色实线。
    
    第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。
    边框为5像素蓝色点线。
     --&gt;
    
    &lt;div id=&quot;id002&quot;&gt;div标签1&lt;/div&gt;
    &lt;div id=&quot;id001&quot;&gt;div标签2&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>类选择器 格式：.class属性名{ 属性：值; }</li>
</ul>
<pre><code class="html">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;class类型选择器&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .class01&#123;
            color: blue;
            font-size: 30px;
            border: 1px solid yellow;
        &#125;

        .class02&#123;
            color: grey;
            font-size: 26px;
            border: 1px solid red;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--
        需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。
        需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。
     --&gt;

    &lt;div class=&quot;class02&quot;&gt;div标签class01&lt;/div&gt;
    &lt;div class=&quot;class02&quot;&gt;div标签&lt;/div&gt;
    &lt;span class=&quot;class02&quot;&gt;span标签class01&lt;/span&gt;
    &lt;span&gt;span标签2&lt;/span&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li><p>扩展选择器：</p>
<ol>
<li>选择所有元素：语法：* { }</li>
<li>并集选择器：选择器1,选择器2{}</li>
<li>子选择器：筛选选择器1元素下的选择器2元素  语法：  选择器1 选择器2{}</li>
<li>父选择器：筛选选择器2的父元素选择器1  语法：  选择器1 &gt; 选择器2{}</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素 语法：  元素名称[属性名=”属性值”]{}</li>
<li>伪类选择器：选择一些元素具有的状态 语法： 元素:状态{}<br>如： <a> 状态：link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态</a></li>
</ol>
</li>
</ul>
<h4 id="1-5常用样式"><a href="#1-5常用样式" class="headerlink" title="1.5常用样式"></a>1.5常用样式</h4><ol>
<li>字体、文本<br> font-size：字体大小<br> color：文本颜色<br> text-align：对其方式<br> line-height：行高 </li>
<li>背景<br> background：</li>
<li>边框<br> border：设置边框，符合属性</li>
<li>尺寸<br> width：宽度<br> height：高度</li>
<li>盒子模型：控制布局<br> margin：外边距<br> padding：内边距<br> 默认情况下内边距会影响整个盒子的大小<br> box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小<br>float：浮动left right</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery基本使用</title>
    <url>/2020/09/14/JQuery/</url>
    <content><![CDATA[<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li>什么是 jQuery? jQuery，顾名思义，也就是 JavaScript 和查询（Query），它就是辅助 JavaScript 开发的 js 类库。</li>
<li>jQuery 核心思想！！！ 它的核心思想是 write less,do more(写得更少,做得更多)，所以它实现了很多浏览器的兼容问题。</li>
<li>jQuery 流行程度 jQuery 现在已经成为最流行的 JavaScript 库，在世界前 10000 个访问最多的网站中，有超过 55%在使用 jQuery。</li>
<li>jQuery 好处！！！ jQuery 是免费、开源的，jQuery 的语法设计可以使开发更加便捷，例如操作文档对象、选择 DOM 元素、 制作动画效果、事件处理、使用 Ajax 以及其他功能</li>
</ul>
<h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2 快速入门"></a>1.2 快速入门</h3><ol>
<li><p>下载JQuery</p>
<ul>
<li>目前jQuery有三个大版本：<ul>
<li><p>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，<br>功能不再新增。因此一般项目来说，使用1.x版本就可以了，<br>最终版本：1.12.4 (2016年5月20日)</p>
</li>
<li><p>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，<br>功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，<br>最终版本：2.2.4 (2016年5月20日)</p>
</li>
<li><p>3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，<br>一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。<br>目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p>
</li>
</ul>
</li>
<li>jquery-xxx.js 与 jquery-xxx.min.js区别：<pre><code> - jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些
 - jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快
</code></pre>
</li>
</ul>
</li>
<li><p>导入JQuery的js文件：导入min.js文件</p>
</li>
<li><p>使用</p>
</li>
</ol>
<pre><code class="javascript">    &lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // window.onload = function () &#123;
        //     var btnObj = document.getElementById(&quot;btnId&quot;);
        //     // alert(btnObj);//[object HTMLButtonElement]   ====&gt;&gt;&gt;  dom对象
        //     btnObj.onclick = function () &#123;
        //         alert(&quot;js 原生的单击事件&quot;);
        //     &#125;
        // &#125;
        //使用$()代替window.onload,表示页面加载完成之后，相当于window.onload = function () &#123;&#125;
        $(function()&#123;
            //使用选择器获取按钮对象，随后绑定单击响应函数
            $(&quot;#btnId&quot;).click(function()&#123;
                //弹出Hello
                alert(&#39;Hello&#39;);
            &#125;);
        &#125;);
    
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;
    &lt;/body&gt;
</code></pre>
<blockquote>
<p>$ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数</p>
</blockquote>
<h3 id="1-3-JQuery对象和DOM对象"><a href="#1-3-JQuery对象和DOM对象" class="headerlink" title="1.3 JQuery对象和DOM对象"></a>1.3 JQuery对象和DOM对象</h3><ul>
<li><p>Dom对象 </p>
<ul>
<li>通过 getElementById()查询出来的标签对象是 Dom 对象 </li>
<li>通过 getElementsByName()查询出来的标签对象是 Dom 对象 </li>
<li>通过 getElementsByTagName()查询出来的标签对象是 Dom 对象 </li>
<li>通过 createElement() 方法创建的对象，是 Dom 对象</li>
<li>DOM 对象 Alert 出来的效果是：[object HTML标 签 名 Element]</li>
</ul>
</li>
<li><p>jQuery对象 </p>
<ul>
<li>通过 JQuery 提供的 API 创建的对象，是 JQuery 对象 </li>
<li>通过 JQuery 包装的 Dom 对象，也是 JQuery 对象 </li>
<li>通过 JQuery 提供的 API 查询到的对象，是 JQuery 对象</li>
<li>jQuery 对象 Alert 出来的效果是：[object Object]</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>jQuery 对象不能使用 DOM 对象的属性和方法</li>
<li>DOM 对象也不能使用 jQuery 对象的属性和方法</li>
</ul>
</li>
<li><p>联系</p>
<ul>
<li>jQuery 对象是 dom 对象的数组 +jQuery 提供的一系列功能函数。</li>
</ul>
</li>
<li><p>转换</p>
<ul>
<li>dom对象转化为 jQuery 对象（重点） 1、先有 DOM 对象  2、$(DOM 对象 ) 就可以转换成为 jQuery 对象</li>
<li>jQuery 对象转为 dom 对象（重点） 1、先有 jQuery 对象  2、jQuery 对象[下标]或get(下标)取出相应的 DOM 对象</li>
</ul>
</li>
</ul>
<pre><code class="JavaScript">&lt;div id=&quot;div1&quot;&gt;
    div1...
&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;
    div2...
&lt;/div&gt;
&lt;script&gt;
    //js方式获取名称叫div的所有html元素对象
    var divs = document.getElementsByTagName(&quot;div&quot;);
    alert(divs.length);//2
    //对divs中所有div让其标签内容变为aaa，js方式
    for(var i=0;i&lt;divs.length;i++)&#123;
        divs[i].innerHTML=&quot;aaa&quot;;
        //转换为jq对象
        $(divs[i]).html(&quot;ccc&quot;);
    &#125;
    //通过JQuery方式获取名称叫div的所有html元素对象
    var $divs = $(&quot;div&quot;);
    alert($divs.length);//2
    //对divs中所有div让其标签内容变为bbb，jq方式
    $divs.html(&quot;bbb&quot;);//操作更加方便
    //js方式，JQuery转为js，只需要在JQuery对象后加索引[],或者用get方法
    $divs[0].innerHTML=&quot;ddd&quot;;
    $divs.get(1).innerHTML=&quot;eee&quot;;
    /*
    JQuery对象与JS对象方法是不通用的
    两者相互转换
    jq--&gt;js:jq对象[索引] 或者 jq对象.get(索引)
    js--&gt;jq:$(js对象)
     */
&lt;/script&gt;
</code></pre>
<h3 id="1-4-选择器"><a href="#1-4-选择器" class="headerlink" title="1.4 选择器"></a>1.4 选择器</h3><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ul>
<li><p>标签选择器（元素选择器）</p>
<ul>
<li>语法： $(“html标签名”) 获得所有匹配标签名称的元素</li>
</ul>
</li>
<li><p>id选择器 </p>
<ul>
<li>语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</li>
</ul>
</li>
<li><p>类选择器</p>
<ul>
<li>语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</li>
</ul>
</li>
<li><p>并集选择器：</p>
<ul>
<li>语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</li>
</ul>
</li>
<li><p>全局选择器</p>
<ul>
<li>语法：$(“*”)获得所有的元素</li>
</ul>
</li>
</ul>
<pre><code class="JavaScript">$(function () &#123;
//1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot;
$(&quot;#btn1&quot;).click(function () &#123;
// css() 方法 可以设置和获取样式
$(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;);
&#125;);

//2.选择 class 为 mini 的所有元素
$(&quot;#btn2&quot;).click(function () &#123;
$(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;);
&#125;);

//3.选择 元素名是 div 的所有元素
$(&quot;#btn3&quot;).click(function () &#123;
$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;);
&#125;);

//4.选择所有的元素
$(&quot;#btn4&quot;).click(function () &#123;
$(&quot;*&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;);
&#125;);

//5.选择所有的 span 元素和id为two的元素
$(&quot;#btn5&quot;).click(function () &#123;
$(&quot;span,#two&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;);
&#125;);

&#125;);
</code></pre>
<h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h4><ul>
<li><p>后代选择器</p>
<ul>
<li>语法： $(“A B “) 选择A元素内部的所有B元素        </li>
</ul>
</li>
<li><p>子选择器</p>
<ul>
<li>语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</li>
</ul>
</li>
</ul>
<pre><code class="JavaScript">$(document).ready(function()&#123;
                //1.选择 body 内的所有 div 元素
                $(&quot;#btn1&quot;).click(function()&#123;
                    $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //2.在 body 内, 选择div子元素  
                $(&quot;#btn2&quot;).click(function()&#123;
                    $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //3.选择 id 为 one 的下一个 div 元素 
                $(&quot;#btn3&quot;).click(function()&#123;
                    $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //4.选择 id 为 two 的元素后面的所有 div 兄弟元素
                $(&quot;#btn4&quot;).click(function()&#123;
                    $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);
            &#125;);
</code></pre>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul>
<li><p>属性名称选择器 </p>
<ul>
<li>语法： $(“A[属性名]”) 包含指定属性的选择器</li>
</ul>
</li>
<li><p>属性选择器</p>
<ul>
<li>语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</li>
</ul>
</li>
<li><p>复合属性选择器</p>
<ul>
<li>语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</li>
</ul>
</li>
</ul>
<pre><code class="javascript">$(function() &#123;
        //1.选取含有 属性title 的div元素
        $(&quot;#btn1&quot;).click(function() &#123;
            $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //2.选取 属性title值等于&#39;test&#39;的div元素
        $(&quot;#btn2&quot;).click(function() &#123;
            $(&quot;div[title=&#39;test&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //3.选取 属性title值不等于&#39;test&#39;的div元素(*没有属性title的也将被选中)
        $(&quot;#btn3&quot;).click(function() &#123;
            $(&quot;div[title!=&#39;test&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //4.选取 属性title值 以&#39;te&#39;开始 的div元素
        $(&quot;#btn4&quot;).click(function() &#123;
            $(&quot;div[title^=&#39;te&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //5.选取 属性title值 以&#39;est&#39;结束 的div元素
        $(&quot;#btn5&quot;).click(function() &#123;
            $(&quot;div[title$=&#39;est&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //6.选取 属性title值 含有&#39;es&#39;的div元素
        $(&quot;#btn6&quot;).click(function() &#123;
            $(&quot;div[title*=&#39;es&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        
        //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#39;es&#39;的 div 元素
        $(&quot;#btn7&quot;).click(function() &#123;
            $(&quot;div[id][title*=&#39;es&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
        //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素
        $(&quot;#btn8&quot;).click(function() &#123;
            $(&quot;div[title][title!=&#39;test&#39;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
        &#125;);
    &#125;);
&lt;/script&gt;
</code></pre>
<h4 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h4><ul>
<li><p>首元素选择器 </p>
<ul>
<li>语法： :first 获得选择的元素中的第一个元素</li>
</ul>
</li>
<li><p>尾元素选择器 </p>
<ul>
<li>语法： :last 获得选择的元素中的最后一个元素</li>
</ul>
</li>
<li><p>非元素选择器</p>
<ul>
<li>语法： :not(selector) 不包括指定内容的元素</li>
</ul>
</li>
<li><p>偶数选择器</p>
<ul>
<li>语法： :even 偶数，从 0 开始计数</li>
</ul>
</li>
<li><p>奇数选择器</p>
<ul>
<li>语法： :odd 奇数，从 0 开始计数</li>
</ul>
</li>
<li><p>等于索引选择器</p>
<ul>
<li>语法： :eq(index) 指定索引元素</li>
</ul>
</li>
<li><p>大于索引选择器 </p>
<ul>
<li>语法： :gt(index) 大于指定索引元素</li>
</ul>
</li>
<li><p>小于索引选择器 </p>
<ul>
<li>语法： :lt(index) 小于指定索引元素</li>
</ul>
</li>
<li><p>标题选择器</p>
<ul>
<li>语法： :header 获得标题（h1~h6）元素，固定写法</li>
</ul>
</li>
</ul>
<pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;
            $(document).ready(function()&#123;
                function anmateIt()&#123;
                    $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt);
                &#125;
                anmateIt();
            &#125;);
            
            $(document).ready(function()&#123;
                //1.选择第一个 div 元素  
                $(&quot;#btn1&quot;).click(function()&#123;
                    $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //2.选择最后一个 div 元素
                $(&quot;#btn2&quot;).click(function()&#123;
                    $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //3.选择class不为 one 的所有 div 元素
                $(&quot;#btn3&quot;).click(function()&#123;
                    $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //4.选择索引值为偶数的 div 元素
                $(&quot;#btn4&quot;).click(function()&#123;
                    $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //5.选择索引值为奇数的 div 元素
                $(&quot;#btn5&quot;).click(function()&#123;
                    $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //6.选择索引值为大于 3 的 div 元素
                $(&quot;#btn6&quot;).click(function()&#123;
                    $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //7.选择索引值为等于 3 的 div 元素
                $(&quot;#btn7&quot;).click(function()&#123;
                    $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //8.选择索引值为小于 3 的 div 元素
                $(&quot;#btn8&quot;).click(function()&#123;
                    $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //9.选择所有的标题元素
                $(&quot;#btn9&quot;).click(function()&#123;
                    $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //10.选择当前正在执行动画的所有元素
                $(&quot;#btn10&quot;).click(function()&#123;
                    $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);
                //11.选择没有执行动画的最后一个div
                $(&quot;#btn11&quot;).click(function()&#123;
                    $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);
            &#125;);
        &lt;/script&gt;
</code></pre>
<h4 id="表单过滤选择器"><a href="#表单过滤选择器" class="headerlink" title="表单过滤选择器"></a>表单过滤选择器</h4><ul>
<li><p>可用元素选择器 </p>
<ul>
<li>语法： :enabled 获得可用元素</li>
</ul>
</li>
<li><p>不可用元素选择器 </p>
<ul>
<li>语法： :disabled 获得不可用元素</li>
</ul>
</li>
<li><p>选中选择器 </p>
<ul>
<li>语法： :checked 获得单选/复选框选中的元素</li>
</ul>
</li>
<li><p>选中选择器 </p>
<ul>
<li>语法： :selected 获得下拉框选中的元素</li>
</ul>
</li>
</ul>
<pre><code class="JavaScript">$(function()&#123;                            
        /**
        :input         
        :text         
        :password     
        :radio         
        :checkbox     
        :submit     
        :image         
        :reset         
        :button     
        :file         
        :hidden             
        表单对象的属性
        :enabled         
        :disabled         
        :checked         
        :selected         
        */                    
                //1.对表单内 可用input 赋值操作
                $(&quot;#btn1&quot;).click(function()&#123;
                    // val()可以操作表单项的value属性值
                    // 它可以设置和获取
                    $(&quot;:text:enabled&quot;).val(&quot;我是万能的程序员&quot;);
                &#125;);
                //2.对表单内 不可用input 赋值操作
                $(&quot;#btn2&quot;).click(function()&#123;
                    $(&quot;:text:disabled&quot;).val(&quot;管你可用不可用，反正我是万能的程序员&quot;);
                &#125;);
                //3.获取多选框选中的个数  使用size()方法获取选取到的元素集合的元素个数
                $(&quot;#btn3&quot;).click(function()&#123;
                    alert( $(&quot;:checkbox:checked&quot;).length );
                &#125;);
                //4.获取多选框，每个选中的value值
                $(&quot;#btn4&quot;).click(function()&#123;
                    // 获取全部选中的复选框标签对象
                    var $checkboies = $(&quot;:checkbox:checked&quot;);
                    // 老式遍历
                    // for (var i = 0; i &lt; $checkboies.length; i++)&#123;
                    //     alert( $checkboies[i].value );
                    // &#125;
                    // each方法是jQuery对象提供用来遍历元素的方法
                    // 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象
                    $checkboies.each(function () &#123;
                        alert( this.value );
                    &#125;);
                &#125;);
                //5.获取下拉框选中的内容  
                $(&quot;#btn5&quot;).click(function()&#123;
                    // 获取选中的option标签对象
                    var $options = $(&quot;select option:selected&quot;);
                    // 遍历，获取option标签中的文本内容
                    $options.each(function () &#123;
                        // 在each遍历的function函数中，有一个this对象。这个this对象是当前正在遍历到的dom对象
                        alert(this.innerHTML);
                    &#125;);
                &#125;);
            &#125;)    
        &lt;/script&gt;
</code></pre>
<h4 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h4><p>:contains(text) 匹配包含给定文本的元素 </p>
<p>:empty 匹配所有不包含子元素或者文本的空元素 </p>
<p>:parent 匹配含有子元素或者文本的元素 </p>
<p>:has(selector) 匹配含有选择器所匹配的元素的元素</p>
<pre><code class="JavaScript">$(document).ready(function()&#123;
                //1.选择 含有文本 &#39;di&#39; 的 div 元素
                $(&quot;#btn1&quot;).click(function()&#123;
                    $(&quot;div:contains(&#39;di&#39;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //2.选择不包含子元素(或者文本元素) 的 div 空元素
                $(&quot;#btn2&quot;).click(function()&#123;
                    $(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);
                //3.选择含有 class 为 mini 元素的 div 元素
                $(&quot;#btn3&quot;).click(function()&#123;
                    $(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);

                //4.选择含有子元素(或者文本元素)的div元素
                $(&quot;#btn4&quot;).click(function()&#123;
                    $(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);
                &#125;);
            &#125;);
</code></pre>
<h4 id="元素筛选的方法"><a href="#元素筛选的方法" class="headerlink" title="元素筛选的方法"></a>元素筛选的方法</h4><pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;
            $(document).ready(function()&#123;
                function anmateIt()&#123;
                    $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt);
                &#125;
                anmateIt();        
    /**                    
    过滤
    eq(index|-index)             
    first()                     
    last()                         
    hasClass(class)             
    filter(expr|obj|ele|fn)     
    is(expr|obj|ele|fn)1.6*     
    has(expr|ele)                 
    not(expr|ele|fn)             
    slice(start,[end])             
    查找
    children([expr])             
    closest(expr,[con]|obj|ele)1.6*   
    find(expr|obj|ele)                 
    next([expr])                     
    nextall([expr])                 
    nextUntil([exp|ele][,fil])1.6*     
    parent([expr])                     
    parents([expr])                 
    parentsUntil([exp|ele][,fil])1.6*  
    prev([expr])                     
    prevall([expr])                 
    prevUntil([exp|ele][,fil])1.6*     
    siblings([expr])                 
    串联
    add(expr|ele|html|obj[,con])     
    */
                
                //(1)eq()  选择索引值为等于 3 的 div 元素
                $(&quot;#btn1&quot;).click(function()&#123;
                    $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(2)first()选择第一个 div 元素
                 $(&quot;#btn2&quot;).click(function()&#123;
                     //first()   选取第一个元素
                    $(&quot;div&quot;).first().css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(3)last()选择最后一个 div 元素
                $(&quot;#btn3&quot;).click(function()&#123;
                    //last()  选取最后一个元素
                    $(&quot;div&quot;).last().css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(4)filter()在div中选择索引为偶数的
                $(&quot;#btn4&quot;).click(function()&#123;
                    //filter()  过滤   传入的是选择器字符串
                    $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                 //(5)is()判断#one是否为:empty或:parent
                //is用来检测jq对象是否符合指定的选择器
                $(&quot;#btn5&quot;).click(function()&#123;
                    alert( $(&quot;#one&quot;).is(&quot;:empty&quot;) );
                &#125;);
                
                //(6)has()选择div中包含.mini的
                $(&quot;#btn6&quot;).click(function()&#123;
                    //has(selector)  选择器字符串    是否包含selector
                    $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(7)not()选择div中class不为one的
                $(&quot;#btn7&quot;).click(function()&#123;
                    //not(selector)  选择不是selector的元素
                    $(&quot;div&quot;).not(&#39;.one&#39;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(8)children()在body中选择所有class为one的div子元素
                $(&quot;#btn8&quot;).click(function()&#123;
                    //children()  选出所有的子元素
                    $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);    
                //(9)find()在body中选择所有class为mini的div元素
                $(&quot;#btn9&quot;).click(function()&#123;
                    //find()  选出所有的后代元素
                    $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(10)next() #one的下一个div
                $(&quot;#btn10&quot;).click(function()&#123;
                    //next()  选择下一个兄弟元素
                    $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(11)nextAll() #one后面所有的span元素
                $(&quot;#btn11&quot;).click(function()&#123;
                    //nextAll()   选出后面所有的元素
                    $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(12)nextUntil() #one和span之间的元素
                $(&quot;#btn12&quot;).click(function()&#123;
                    //
                    $(&quot;#one&quot;).nextUntil(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;)
                &#125;);
                //(13)parent() .mini的父元素
                $(&quot;#btn13&quot;).click(function()&#123;
                    $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;,&quot;#bfa&quot;);
                &#125;);
                //(14)prev() #two的上一个div
                $(&quot;#btn14&quot;).click(function()&#123;
                    //prev()  
                    $(&quot;#two&quot;).prev(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;)
                &#125;);
                //(15)prevAll() span前面所有的div
                $(&quot;#btn15&quot;).click(function()&#123;
                    //prevAll()   选出前面所有的元素
                    $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;)
                &#125;);
                //(16)prevUntil() span向前直到#one的元素
                $(&quot;#btn16&quot;).click(function()&#123;
                    //prevUntil(exp)   找到之前所有的兄弟元素直到找到exp停止
                    $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;)
                &#125;);
                //(17)siblings() #two的所有兄弟元素
                $(&quot;#btn17&quot;).click(function()&#123;
                    //siblings()    找到所有的兄弟元素，包括前面的和后面的
                    $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;,&quot;#bfa&quot;)
                &#125;);    
                //(18)add()选择所有的 span 元素和id为two的元素
                $(&quot;#btn18&quot;).click(function()&#123;    
                    //   $(&quot;span,#two,.mini,#one&quot;)
                    $(&quot;span&quot;).add(&quot;#two&quot;).add(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;);    
                &#125;);
            &#125;);            
        &lt;/script&gt;
</code></pre>
<h3 id="1-5-JQuery方法"><a href="#1-5-JQuery方法" class="headerlink" title="1.5 JQuery方法"></a>1.5 JQuery方法</h3><p>内容操作</p>
<ol>
<li><code>html()</code> 它可以设置和获取起始标签和结束标签中的内容。 跟 dom 属性 innerHTML 一样。 </li>
<li><code>text()</code> 它可以设置和获取起始标签和结束标签中的文本。 跟 dom 属性 innerText 一样。 </li>
<li><code>val()</code> 它可以设置和获取表单项的 value 属性值。 跟 dom 属性 value 一样</li>
</ol>
<pre><code class="JavaScript">$(function () &#123;
                // 获取myinput 的value值
                alert($(&quot;#myinput&quot;).val());
                //设置
                $(&quot;#myinput&quot;).val(&quot;李四&quot;);
                // 获取mydiv的标签体内容
                alert($(&quot;#mydiv&quot;).html());
                //设置
                $(&quot;#mydiv&quot;).html(&quot;&lt;p&gt;aaa&lt;/p&gt;&quot;);
                // 获取mydiv文本内容
                alert($(&quot;#mydiv&quot;).text());
                //设置
                $(&quot;#mydiv&quot;).text(&quot;bbb&quot;)
            &#125;)
</code></pre>
<p>属性操作</p>
<ol>
<li><p>通用属性操作</p>
<ul>
<li><p><code>attr()</code>: 获取/设置元素的属性</p>
</li>
<li><p><code>removeAttr()</code>:删除属性</p>
</li>
<li><p><code>prop()</code>:获取/设置元素的属性</p>
</li>
<li><p><code>removeProp()</code>:删除属性</p>
</li>
<li><p>attr和prop区别？</p>
<ul>
<li>如果操作的是元素的固有属性，则建议使用prop</li>
<li>如果操作的是元素自定义的属性，则建议使用attr</li>
</ul>
<pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;
       $(function () &#123;
           //获取北京节点的name属性值
           alert($(&quot;#bj&quot;).attr(&quot;name&quot;));
           //设置北京节点的name属性的值为dabeijing
           $(&quot;#bj&quot;).attr(&quot;name&quot;,&quot;dabeijing&quot;);
           //新增北京节点的discription属性 属性值是didu
           $(&quot;#bj&quot;).attr(&quot;discription&quot;,&quot;didu&quot;);
           //删除北京节点的name属性并检验name属性是否存在
           $(&quot;#bj&quot;).removeAttr(&quot;name&quot;);
           //获得hobby的的选中状态
           alert($(&quot;#hobby&quot;).prop(&quot;checked&quot;));
       &#125;)

   &lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>对class属性操作</p>
<ul>
<li><p><code>addClass()</code>:添加class属性值</p>
</li>
<li><p><code>emoveClass()</code>:删除class属性值</p>
</li>
<li><p><code>toggleClass()</code>:切换class属性</p>
</li>
<li><p><code>toggleClass(&quot;one&quot;)</code>: 判断如果元素对象上存在class=”one”，则将属性值one删除掉。  如果元素对象上不存在class=”one”，则添加</p>
</li>
<li><p><code>css()</code>:设置css</p>
</li>
</ul>
<pre><code class="JavaScript">$(function () &#123;
            //&lt;input type=&quot;button&quot; value=&quot;采用属性增加样式(改变id=one的样式)&quot;  id=&quot;b1&quot;/&gt;
            $(&quot;#b1&quot;).click(function () &#123;
                $(&quot;#one&quot;).prop(&quot;class&quot;,&quot;second&quot;);
            &#125;);
            //&lt;input type=&quot;button&quot; value=&quot; addClass&quot;  id=&quot;b2&quot;/&gt;
            $(&quot;#b2&quot;).click(function () &#123;
                $(&quot;#one&quot;).addClass(&quot;second&quot;);
            &#125;);
            //&lt;input type=&quot;button&quot; value=&quot;removeClass&quot;  id=&quot;b3&quot;/&gt;
            $(&quot;#b3&quot;).click(function () &#123;
                $(&quot;#one&quot;).removeClass(&quot;second&quot;);
            &#125;);
            //&lt;input type=&quot;button&quot; value=&quot; 切换样式&quot;  id=&quot;b4&quot;/&gt;
            $(&quot;#b4&quot;).click(function () &#123;
                $(&quot;#one&quot;).toggleClass(&quot;second&quot;);
            &#125;);
            //&lt;input type=&quot;button&quot; value=&quot; 通过css()获得id为one背景颜色&quot;  id=&quot;b5&quot;/&gt;
            $(&quot;#b5&quot;).click(function () &#123;
                var background = $(&quot;#one&quot;).css(&quot;backgroundColor&quot;);
                alert(background)
            &#125;);
            //&lt;input type=&quot;button&quot; value=&quot; 通过css()设置id为one背景颜色为绿色&quot;  id=&quot;b6&quot;/&gt;
            $(&quot;#b5&quot;).click(function () &#123;
                $(&quot;#one&quot;).css(&quot;backgroundColor&quot;,&quot;green&quot;);
            &#125;);
        &#125;)
</code></pre>
</li>
<li><p>CRUD操作:</p>
<ul>
<li><p><code>append()</code>:父元素将子元素追加到末尾</p>
<ul>
<li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li>
</ul>
</li>
<li><p><code>prepend()</code>:父元素将子元素追加到开头</p>
<ul>
<li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li>
</ul>
</li>
<li><p><code>appendTo()</code>:</p>
<ul>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li>
</ul>
</li>
<li><p><code>prependTo()</code>：</p>
<ul>
<li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li>
</ul>
</li>
<li><p><code>after()</code>:添加元素到元素后边</p>
<ul>
<li>对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p><code>before()</code>:添加元素到元素前边</p>
<ul>
<li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p><code>insertAfter()</code></p>
<ul>
<li>对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p><code>insertBefore()</code></p>
<ul>
<li>对象1.insertBefore(对象2)： 将对象1添加到对象2前边。对象1和对象2是兄弟关系</li>
</ul>
</li>
<li><p><code>remove()</code>:移除元素</p>
<ul>
<li>对象.remove():将对象删除掉</li>
</ul>
</li>
<li><p><code>empty()</code>:清空元素的所有后代元素。</p>
<ul>
<li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</li>
</ul>
<pre><code class="JavaScript">$(function () &#123;
           // &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的后面&quot;  id=&quot;b1&quot;/&gt;
           $(&quot;#b1&quot;).click(function () &#123;
               $(&quot;#fk&quot;).appendTo($(&quot;#city&quot;));
           &#125;);
           // &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的最前面&quot;  id=&quot;b2&quot;/&gt;
           $(&quot;#b2&quot;).click(function () &#123;
               $(&quot;#fk&quot;).prependTo($(&quot;#city&quot;));
           &#125;);
           // &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津后面&quot;  id=&quot;b3&quot;/&gt;
           $(&quot;#b3&quot;).click(function () &#123;
               $(&quot;#fk&quot;).insertAfter($(&quot;#tj&quot;));
           &#125;);
           // &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津前面&quot;  id=&quot;b4&quot;/&gt;
           $(&quot;#b4&quot;).click(function () &#123;
               $(&quot;#fk&quot;).insertBefore($(&quot;#tj&quot;));
           &#125;);
           // &lt;input type=&quot;button&quot; value=&quot;删除&lt;li id=&#39;bj&#39; name=&#39;beijing&#39;&gt;北京&lt;/li&gt;&quot;  id=&quot;b1&quot;/&gt;
          $(&quot;#b1&quot;).click(function () &#123;
              $(&quot;#bj&quot;).remove();
          &#125;)
          // &lt;input type=&quot;button&quot; value=&quot;删除city所有的li节点   清空元素中的所有后代节点(不包含属性节点)&quot;  id=&quot;b2&quot;/&gt;
          $(&quot;#b2&quot;).click(function () &#123;
              $(&quot;#city&quot;).empty();
          &#125;)
       &#125;)
</code></pre>
<h3 id="1-6-JQuery动画"><a href="#1-6-JQuery动画" class="headerlink" title="1.6 JQuery动画"></a>1.6 JQuery动画</h3></li>
</ul>
</li>
<li><p>默认显示和隐藏方式</p>
</li>
</ol>
<ul>
<li><p>show([speed,[easing],[fn]])</p>
<ul>
<li>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</li>
<li>easing：用来指定切换效果，默认是”swing”，可用参数”linear”<ul>
<li>swing：动画执行时效果是 先慢，中间快，最后又慢</li>
<li>linear：动画执行时速度是匀速的</li>
<li>fn：在动画完成时执行的函数，每个元素执行一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>hide([speed,[easing],[fn]])</p>
</li>
<li><p>toggle([speed],[easing],[fn])</p>
</li>
</ul>
<ol start="2">
<li>滑动显示和隐藏方式</li>
</ol>
<ul>
<li>slideDown([speed],[easing],[fn])</li>
<li>slideUp([speed,[easing],[fn]])</li>
<li>slideToggle([speed],[easing],[fn])</li>
</ul>
<ol start="3">
<li>淡入淡出显示和隐藏方式</li>
</ol>
<ul>
<li>fadeIn([speed],[easing],[fn])</li>
<li>fadeOut([speed],[easing],[fn])</li>
<li>fadeToggle([speed,[easing],[fn]])</li>
</ul>
<pre><code class="javascript">&lt;script&gt;
        //隐藏
        function hideFn()&#123;
            $(&quot;div&quot;).hide(&quot;slow&quot;,&quot;swing&quot;,function () &#123;
                alert(&quot;隐藏&quot;)
            &#125;);
        &#125;
        //显示
        function showFn()&#123;
            $(&quot;div&quot;).show();
        &#125;;
        //显示和隐藏
        function toggleFn()&#123;
            $(&quot;div&quot;).toggle();
        &#125;;
    &lt;/script&gt;
</code></pre>
<h3 id="1-7-JQuery事件"><a href="#1-7-JQuery事件" class="headerlink" title="1.7 JQuery事件"></a>1.7 JQuery事件</h3><p><code>$(function()&#123;&#125;)</code>; 和 <code>window.onload=function()&#123;&#125;</code> 的区别？<br>他们分别是在什么时候触发？ </p>
<p>1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 </p>
<p>2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载完成。</p>
<p>window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉</p>
<p>$(function)可以定义多次的。</p>
<ul>
<li><code>click()</code> 它可以绑定单击事件，以及触发单击事件 </li>
<li><code>mouseover()</code> 鼠标移入事件 </li>
<li><code>mouseout()</code> 鼠标移出事件 </li>
<li><code>bind()</code> 可以给元素一次性绑定一个或多个事件。 </li>
<li><code>one()</code> 使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次。 </li>
<li><code>unbind()</code> 跟 bind 方法相反的操作，解除事件的绑定 </li>
<li><code>live()</code> 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出 来的也有效</li>
</ul>
<p><strong>事件的冒泡</strong></p>
<p>事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去响应。</p>
<p>如何阻止事件冒泡： 在子元素事件函数体内，returnfalse; 可以阻止事件的冒泡传递。</p>
<pre><code class="JavaScript">            $(function()&#123;
                //*1.通常绑定事件的方式
                //给元素绑定事件  
                //jquery对象.事件方法(回调函数()&#123; 触发事件执行的代码 &#125;).事件方法(回调函数()&#123; 触发事件执行的代码 &#125;).事件方法(回调函数()&#123; 触发事件执行的代码 &#125;)
                //绑定事件可以链式操作
                $(&quot;.head&quot;).click(function()&#123;
                    $(&quot;.content&quot;).toggle();
                &#125;).mouseover(function()&#123;
                    $(&quot;.content&quot;).toggle();
                &#125;); 
                
                //*2.jQuery提供的绑定方式：bind(type,[data],fn)函数把元素和事件绑定起来
                //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法
                //bind(事件字符串,回调函数),后来添加的元素不会绑定事件
                //使用bind()绑定多个事件   type可以接受多个事件类型，使用空格分割多个事件
                 $(&quot;.head&quot;).bind(&quot;click mouseover&quot;,function()&#123;
                    $(&quot;.content&quot;).toggle();
                &#125;); 
            
                
                //3.one()只绑定一次,绑定的事件只会发生一次one(type,[data],fn)函数把元素和事件绑定起来
                //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法
                 $(&quot;.head&quot;).one(&quot;click mouseover&quot;,function()&#123;
                    $(&quot;.content&quot;).toggle();
                &#125;); 

                //4.live方法会为现在及以后添加的元素都绑定上相应的事件
                $(&quot;.head&quot;).live(&quot;click&quot;,function()&#123;
                    $(&quot;.content&quot;).toggle();
                &#125;);
                $(&quot;#name&quot;).focus();//让文本输入框获得焦点
                $(&quot;#panel&quot;).before(&quot;&lt;h5 class=&#39;head&#39;&gt;什么是jQuery?&lt;/h5&gt;&quot;);
                //点击第一个button，将#bj上的mouseenter事件移除
                //unbind()可以移除指定的事件，只需要传一个事件名作为参数
                //unbind(type,[data|fn]])
                //type事件类型  当传入type的时候会解除type事件
                //如果没有传入type值，会移除所有事件
                $(&quot;button:eq(0)&quot;).click(function()&#123;
                    $(&quot;li&quot;).unbind(&quot;click mouseenter&quot;);
                &#125;);
            &#125;);
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis基本使用</title>
    <url>/2020/10/03/MyBatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MyBatis基本使用"><a href="#MyBatis基本使用" class="headerlink" title="MyBatis基本使用"></a>MyBatis基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的<strong>持久层框架</strong>。</p>
</li>
<li><p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
</li>
<li><p>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</p>
</li>
<li><p>MyBatis网址： <a href="https://github.com/mybatis/mybatis-3/">https://github.com/mybatis/mybatis-3/</a></p>
</li>
</ul>
<h3 id="1-2-MyBatis的入门程序"><a href="#1-2-MyBatis的入门程序" class="headerlink" title="1.2 MyBatis的入门程序"></a>1.2 MyBatis的入门程序</h3><p>前提：有sql数据库测试表，有<strong>对应的javaBean</strong></p>
<p><strong>首先</strong>：导入MyBatis的jar包：<code>mybatis-3.4.1.jar</code>，数据库的连接jar包<code>mysql-connector-java-5.1.37-bin.jar</code>，然后根据官方文档</p>
<p><strong>第一步</strong>：创建MyBatis全局配置文件<code>mybatis-config.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
 PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 配置 mybatis 的环境 --&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!-- 配置 mysql 的环境 --&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;!-- 配置 事务类型 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;
    &lt;mappers&gt;
        &lt;!--单个映射，必须写全AccountDao.xml--&gt;
        &lt;!--&lt;mapper resource=&quot;com/review/dao/EmployeeMapper.xml&quot;&gt;&lt;/mapper&gt;--&gt;
        &lt;!--批量注册--&gt;
        &lt;package name=&quot;com.review.dao&quot;/&gt;
        &lt;!--单个映射，但是引入的是接口名，要保证映射文件与接口名一致--&gt;
        &lt;!--&lt;mapper class=&quot;com.review.dao.AccountDao&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>第二步</strong>：创建SQL映射文件<code>EmployeeMapper.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.review.mybatis.EmployeeMapper&quot;&gt;
&lt;!-- 
namespace:名称空间;指定为接口全类名名称
id：唯一标识
resultType：返回值类型
#&#123;id&#125;：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 --&gt;
    &lt;select id=&quot;selectEmp&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>第三步</strong>：编写测试代码</p>
<pre><code class="java">/**
     * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息
     * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。
     * 3、将sql映射文件注册在全局配置文件中
     * 4、写代码：
     *         1）、根据全局配置文件得到SqlSessionFactory；
     *         2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查
     *             一个sqlSession就是代表和数据库的一次会话，用完关闭
     *         3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。
     *
     * @throws IOException
     */
    @Test
    public void test() throws IOException &#123;
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream);

        //获取一个SQLSession实例,能直接执行已经映射的sql语句
        SqlSession openSession = sqlSessionFactory.openSession();
        try &#123;
            //传入的参数，第一个为唯一标识符，第二个为需要的参数
            //唯一标识符是Mapper映射文件需要执行的sql语句的配置文件的id，单独传入id也可，为了防止id重复最好使用namespace+id，这样就能保证是唯一标识符
            //namespace命名空间在Employee中设置为com.review.mybatis.EmployeeMapper，select的id为selectEmp
            Employee employee = openSession.selectOne(&quot;com.review.mybatis.EmployeeMapper.selectEmp&quot;, 1);
            System.out.println(employee);
        &#125;finally &#123;
            openSession.close();
        &#125;
    &#125;
</code></pre>
<p>至此，一个简单的MyBatis入门程序结束</p>
<h3 id="1-3MyBatis的接口式编程"><a href="#1-3MyBatis的接口式编程" class="headerlink" title="1.3MyBatis的接口式编程"></a>1.3MyBatis的接口式编程</h3><p>将入门程序转换为接口式编程</p>
<p><strong>首先</strong>，创建一个Dao接口，接口名称为<code>EmployeeMapper</code></p>
<pre><code class="java">import com.review.mybatis.bean.Employee;

public interface EmployeeMapper &#123;
    public Employee getEmpById(Integer id);
&#125;
</code></pre>
<p>MyBatis提供了一个功能：接口与配置文件动态绑定，</p>
<p>之前EmployeeMapper配置文件的namespace可以随意写，现在指定为接口的全类名，此时MyBatis就知道此接口和配置文件绑定</p>
<p>然后此接口中有一个方法根据Id查询员工，而配置文件中select标签的功能也是按照Id查询员工，所以可以将select的id值和接口的方法名绑定</p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
&lt;!-- 
namespace:名称空间;指定为接口全类名名称
id：唯一标识
resultType：返回值类型
#&#123;id&#125;：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 --&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">/**
 * 1、接口式编程
 *     原生：        Dao        ====&gt;  DaoImpl
 *     mybatis：    Mapper    ====&gt;  xxMapper.xml
 *
 * 2、SqlSession代表和数据库的一次会话；用完必须关闭；
 * 3、SqlSession和connection一样她都是非线程安全。每次使用都应该去获取新的对象。
 * 4、mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。
 *         （将接口和xml进行绑定）
 *         EmployeeMapper empMapper =    sqlSession.getMapper(EmployeeMapper.class);
 * 5、两个重要的配置文件：
 *         mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等...系统运行环境信息
 *         sql映射文件：保存了每一个sql语句的映射信息：
 *                     将sql抽取出来。
 *
 */
//前三步为固定代码，可以抽取为一个方法
public SqlSessionFactory getSqlSessionFactory() throws IOException &#123;
        //1.读取配置文件
        InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        //2.创建 SqlSessionFactory 的构建者对象
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        //3.使用构建者创建工厂对象 SqlSessionFactory
        SqlSessionFactory factory = builder.build(in);
        //4.返回工厂对象 SqlSessionFactory
        return factory;
    &#125;

    @Test
    public void test01() throws IOException &#123;
        // 1、获取sqlSessionFactory对象
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        // 2、使用SqlSessionFactory获取sqlSession对象
        SqlSession openSession = sqlSessionFactory.openSession();
        try &#123;
            // 3、获取接口的实现类对象
            //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            //使用接口的getEmpById查询员工
            Employee employee = mapper.getEmpById(1);
            //打印mapper接口的实现类,可以看出proxy是代理对象
            System.out.println(mapper.getClass());//class com.sun.proxy.$Proxy8
            System.out.println(employee);
        &#125; finally &#123;
            openSession.close();
        &#125;

    &#125;
</code></pre>
<p><strong>注意：</strong> </p>
<ol>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的。</li>
<li>SqlSession每次使用完成后需要正确关闭，这个关闭操作是必须的</li>
<li>SqlSession可以直接调用方法的id进行数据库操作，但是我们一般还是推荐使用SqlSession获取到Dao接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作</li>
</ol>
<h3 id="1-4-MyBatis全局配置文件"><a href="#1-4-MyBatis全局配置文件" class="headerlink" title="1.4 MyBatis全局配置文件"></a>1.4 MyBatis全局配置文件</h3><p>每一个属性配置都有顺序，你可以不配置，但是顺序一定要对</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;&lt;!--配置--&gt;
    &lt;properties/&gt;&lt;!--属性--&gt;
    &lt;settings/&gt;&lt;!--设置--&gt;
    &lt;typeAliases/&gt;&lt;!--类型别名--&gt; 
    &lt;typeHandlers/&gt;&lt;!--类型处理器--&gt; 
    &lt;objectFactory/&gt;&lt;!--对象工厂--&gt;  
    &lt;plugins/&gt;&lt;!--插件--&gt; 
    &lt;environments&gt;&lt;!--配置环境--&gt; 
        &lt;environment&gt;&lt;!--环境变量--&gt; 
        &lt;transactionManager/&gt;&lt;!--事务管理器--&gt; 
            &lt;dataSource/&gt;&lt;!--数据源--&gt; 
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;databaseidProvider/&gt;&lt;!--数据库厂商标识--&gt;  
    &lt;mappers/&gt;&lt;!--映射器--&gt; 
&lt;/configuration&gt;
</code></pre>
<h4 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a>properties 属性</h4><ul>
<li>mybatis可以使用properties来引入外部properties配置文件的内容；</li>
<li>resource：引入类路径下的资源</li>
<li>url：引入网络路径或者磁盘路径下的资源</li>
</ul>
<p>创建数据库配置文件<code>dbconfig.properties</code></p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis
jdbc.username=root
jdbc.password=123456
</code></pre>
<p>全局配置文件<code>mybatis-config.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
 PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    
    &lt;properties resource=&quot;dbconfig.properties&quot;&gt;&lt;/properties&gt;
    
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h4><ul>
<li>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 </li>
<li>settings包含很多重要的设置项，setting:用来设置每一个设置项<ul>
<li>name：设置项名</li>
<li>value：设置项取值</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/03/MyBatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/setting%E8%AE%BE%E7%BD%AE.jpg" alt="Setting设置"></p>
<pre><code class="xml">&lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
</code></pre>
<p><code>mapUnderscoreToCamelCase</code>此参数若设置为false，则表示若数据库某一项的值为last_name，而对应的javaBean的参数为lastName，则在查询时查询不到数据库last_name的值，因为javaBean的lastName字段与数据的last_name没有对应，设置为true则可以互相对应</p>
<h4 id="typeAliases别名处理器"><a href="#typeAliases别名处理器" class="headerlink" title="typeAliases别名处理器"></a>typeAliases别名处理器</h4><p>typeAliases：别名处理器：可以为我们的java类型起别名，别名不区分大小写</p>
<pre><code class="xml">&lt;typeAliases&gt;
        &lt;!-- 1、typeAlias:为某个java类型起别名
                type:指定要起别名的类型全类名;默认别名就是类名小写；employee
                alias:指定新的别名
         --&gt;
        &lt;typeAlias type=&quot;com.review.mybatis.bean.Employee&quot; alias=&quot;emp&quot;/&gt;

        &lt;!-- 2、package:为某个包下的所有类批量起别名
                name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写），）
        --&gt;
        &lt;package name=&quot;com.review.mybatis.bean&quot;/&gt;

        &lt;!-- 3、批量起别名的情况下，使用@Alias注解为某个类型指定新的别名 --&gt;
    &lt;/typeAliases&gt;
</code></pre>
<pre><code class="java">import org.apache.ibatis.type.Alias;

@Alias(&quot;emp&quot;)
public class Employee &#123;
    
    private Integer id;
    private String lastName;
    private String email;
    private String gender;
    //getter and setter 略
&#125;
</code></pre>
<p>EmployeeMapper.xml映射文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
&lt;!-- 
namespace:名称空间;
id：唯一标识
resultType：返回值类型，起了别名
#&#123;id&#125;：从传递过来的参数中取出id值
public Employee getEmpById(Integer id);
 --&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;emp&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>注意：</strong>MyBatis已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，我们在起别名的时候千万不要占用已有的别名。</p>
<h4 id="typeHandlers类型处理器"><a href="#typeHandlers类型处理器" class="headerlink" title="typeHandlers类型处理器"></a>typeHandlers类型处理器</h4><ul>
<li>主要功能是处理数据库类型和java中数据类型的对应关系</li>
<li>例如java中String类型与数据库中varchar类型的对应关系</li>
</ul>
<h4 id="plugins插件机制"><a href="#plugins插件机制" class="headerlink" title="plugins插件机制"></a>plugins插件机制</h4><p>拦截SQL语句执行的核心步骤，这个拦截就是利用插件机制进行的，用来拦四大对象中的方法，在这些方法执行前后进行拦截，这个拦截就是动态代理</p>
<ul>
<li>Executor：执行器(update, query, flushStatements, commit, rollback,getTransaction, close, isClosed)</li>
<li>Parameter：参数处理器(getParameterObject, setParameters)</li>
<li>ResultSetHandler：结果集处理器(handleResultSets, handleOutputParameters)</li>
<li>StatementHandler：sql语句处理器(prepare, parameterize, batch, update, query)</li>
</ul>
<h4 id="environments环境"><a href="#environments环境" class="headerlink" title="environments环境"></a>environments环境</h4><ul>
<li>MyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。</li>
<li>每种环境使用一个environment标签进行配置并指 定唯一标识符</li>
<li>可以通过environments标签中的default属性指定 一个环境的标识符来快速的切换环境</li>
</ul>
<pre><code class="xml">&lt;!--
        environments：环境们，mybatis可以配置多种环境 ,default指定使用某种环境。可以达到快速切换环境。
            environment：配置一个具体的环境信息；必须有两个标签；id代表当前环境的唯一标识
                1.transactionManager：事务管理器；
                    type：事务管理器的类型;JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory)
                          自定义事务管理器：实现TransactionFactory接口.type指定为全类名
                2.dataSource：数据源;
                    type:数据源类型;UNPOOLED(UnpooledDataSourceFactory)
                                |POOLED(PooledDataSourceFactory)
                                |JNDI(JndiDataSourceFactory)
                    自定义数据源：实现DataSourceFactory接口，type是全类名
         --&gt;
    &lt;environments default=&quot;dev_mysql&quot;&gt;
        &lt;environment id=&quot;dev_mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;

        &lt;environment id=&quot;dev_oracle&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;orcl.driver&#125;&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;orcl.url&#125;&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;orcl.username&#125;&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;orcl.password&#125;&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
</code></pre>
<h4 id="databaseIdProvider环境"><a href="#databaseIdProvider环境" class="headerlink" title="databaseIdProvider环境"></a>databaseIdProvider环境</h4><p>MyBatis 可以根据不同的数据库厂商执行不同的语句。</p>
<pre><code class="xml">&lt;!-- databaseIdProvider：支持多数据库厂商的；
         type=&quot;DB_VENDOR&quot;：VendorDatabaseIdProvider
             作用就是得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql;
             MySQL，Oracle，SQL Server,xxxx
      --&gt;
    &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;
        &lt;!-- 为不同的数据库厂商起别名 --&gt;
        &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;
        &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt;
        &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;
    &lt;/databaseIdProvider&gt;
</code></pre>
<p>Mapper.xml映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
&lt;!-- 
namespace:名称空间;指定为接口的全类名
id：唯一标识
resultType：返回值类型
#&#123;id&#125;：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 --&gt;
     &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select * from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot; databaseId=&quot;mysql&quot;&gt;
        select * from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot; databaseId=&quot;oracle&quot;&gt;
        select EMPLOYEE_ID id,LAST_NAME    lastName,EMAIL email from employees where EMPLOYEE_ID=#&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>MyBatis匹配规则如下：</p>
<ol>
<li>如果没有配置databaseIdProvider标签，那么databaseId=null</li>
<li>如果配置了databaseIdProvider标签，使用标签配置的name去匹 配数据库信息，匹配上设置databaseId=配置指定的值，否则依旧为 null</li>
<li>如果databaseId不为null，他只会找到配置databaseId的sql语句</li>
<li>MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。</li>
</ol>
<h4 id="mapper映射"><a href="#mapper映射" class="headerlink" title="mapper映射"></a>mapper映射</h4><pre><code class="xml">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;
&lt;!-- mappers：将sql映射注册到全局配置中 --&gt;
&lt;mappers&gt;
   &lt;!--
      mapper:注册一个sql映射
         注册配置文件
         resource：引用类路径下的sql映射文件
            mybatis/mapper/EmployeeMapper.xml
         url：引用网路路径或者磁盘路径下的sql映射文件
            file:///var/mappers/AuthorMapper.xml

         注册接口
         class：引用（注册）接口，
            1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下；
            2、没有sql映射文件，所有的sql都是利用注解写在接口上;
            推荐：
               比较重要的，复杂的Dao接口我们来写sql映射文件
               不重要，简单的Dao接口为了开发快速可以使用注解；
   --&gt;
   &lt;mapper resource=&quot;mybatis/mapper/EmployeeMapper.xml&quot;/&gt;
    
    &lt;!--此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。--&gt;
   &lt;mapper class=&quot;com.review.mybatis.dao.EmployeeMapperAnnotation&quot;/&gt;

   &lt;!-- 批量注册： --&gt;
    &lt;!--此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。--&gt;
   &lt;package name=&quot;com.review.mybatis.dao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>使用class的<mapper class="com.review.mybatis.dao.EmployeeMapperAnnotation">方式，可以不用写配置文件，直接基于注解</mapper></p>
<pre><code class="java">import com.review.mybatis.bean.Employee;
import org.apache.ibatis.annotations.Select;

public interface EmployeeMapperAnnotation &#123;
    
    @Select(&quot;select * from tbl_employee where id=#&#123;id&#125;&quot;)
    public Employee getEmpById(Integer id);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis的SQL映射文件</title>
    <url>/2020/10/04/MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="MyBatis的SQL映射文件"><a href="#MyBatis的SQL映射文件" class="headerlink" title="MyBatis的SQL映射文件"></a>MyBatis的SQL映射文件</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>映射文件指导着MyBatis如何进行数据库增删改查， 有着非常重要的意义；</p>
<p><strong>标签：</strong></p>
<ul>
<li>cache –命名空间的二级缓存配置 </li>
<li>cache-ref – 其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 自定义结果集映射 </li>
<li>parameterMap – 已废弃！老式风格的参数映射</li>
<li><code>sql</code> –抽取可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h3 id="1-2-增删改查语句"><a href="#1-2-增删改查语句" class="headerlink" title="1.2 增删改查语句"></a>1.2 增删改查语句</h3><p>接口文件EmployeeMapper</p>
<pre><code class="java">public interface EmployeeMapper &#123;
    
    public Employee getEmpById(Integer id);

    public void addEmp(Employee employee);
    public void updateEmp(Employee employee);
    public void deleteEmpById(Integer id);

&#125;
</code></pre>
<p>mapper映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.review.mybatis.dao.EmployeeMapper&quot;&gt;
&lt;!-- 
namespace:名称空间;
id：唯一标识
resultType：返回值类型
#&#123;id&#125;：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 --&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;!--
    public void addEmp(Employee employee);
    public void updateEmp(Employee employee);
    public void deleteEmpById(Integer id);
    --&gt;
    &lt;!--parameterType 可以省略  增删改无返回值类型，会自动封装--&gt;
    &lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        insert into tbl_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)
    &lt;/insert&gt;
    &lt;update id=&quot;updateEmp&quot;&gt;
        update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125;
    &lt;/update&gt;
    &lt;delete id=&quot;deleteEmpById&quot;&gt;
        delete from tbl_employee where id=#&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">//前面的几步封装为一个方法，可以直接调用
public SqlSessionFactory getSqlSessionFactory() throws IOException &#123;
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        return new SqlSessionFactoryBuilder().build(inputStream);
    &#125;
/*
    myBatis允许增删改定义以下类型的返回值，可以自动的为我们封装
        Integer，Long，Boolean，void：基本类型和包装类型都可以
    sqlSessionFactory.openSession();获取到的sqlSession不会自动提交数据，需要手动提交
    sqlSessionFactory.openSession(true);自动提交，不用手动commit
     */
    @Test
    public void test03() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            mapper = sqlSession.getMapper(EmployeeMapper.class);
            Employee employee=new Employee(null,&quot;jack&quot;,&quot;jack@163.com&quot;,&quot;1&quot;);
            //添加
//            mapper.addEmp(employee);
            //修改
//            Employee employee=new Employee(2,&quot;jack&quot;,&quot;jack@163.com&quot;,&quot;1&quot;);
//            mapper.updateEmp(employee);
            //删除
            mapper.deleteEmpById(2);
            //手动提交
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-3-获取自增主键的值"><a href="#1-3-获取自增主键的值" class="headerlink" title="1.3 获取自增主键的值"></a>1.3 获取自增主键的值</h3><p>获取自增主键的值：</p>
<ul>
<li>mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGenreatedKeys()；</li>
<li>useGeneratedKeys=”true”；使用自增主键获取主键值策略</li>
<li>keyProperty；指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性</li>
</ul>
<pre><code class="xml">&lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.review.mybatis.bean.Employee&quot;
            useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into tbl_employee(last_name,email,gender)
        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)
    &lt;/insert&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
    public void test03() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            mapper = sqlSession.getMapper(EmployeeMapper.class);
            Employee employee=new Employee(null,&quot;jack&quot;,&quot;jack@163.com&quot;,&quot;1&quot;);
            //添加
            mapper.addEmp(employee);
            //因为主键id值是自增的，我们new的时候是设为null，所以grtId()取不出来主键值，值为null
            //在mapper文件中设置了useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;，则就可以通过getId取出主键值
            System.out.println(employee.getId());
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<h3 id="1-4-获取非自增主键的值-Oracle"><a href="#1-4-获取非自增主键的值-Oracle" class="headerlink" title="1.4 获取非自增主键的值(Oracle)"></a>1.4 获取非自增主键的值(Oracle)</h3><pre><code class="xml">&lt;!-- 
    获取非自增主键的值：
        Oracle不支持自增；Oracle使用序列来模拟自增；
        每次插入的数据的主键是从序列中拿到的值；如何获取到这个值；
     --&gt;
    &lt;insert id=&quot;addEmp&quot; databaseId=&quot;oracle&quot;&gt;
        &lt;!-- 
        keyProperty:查出的主键值封装给javaBean的哪个属性
        order=&quot;BEFORE&quot;:当前sql在插入sql之前运行
               AFTER：当前sql在插入sql之后运行
        resultType:查出的数据的返回值类型
        
        BEFORE运行顺序：
            先运行selectKey查询id的sql；查出id值封装给javaBean的id属性
            在运行插入的sql；就可以取出id属性对应的值
        AFTER运行顺序：
            先运行插入的sql（从序列中取出新值作为id）；
            再运行selectKey查询id的sql；
         --&gt;
        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;Integer&quot;&gt;
            &lt;!-- 编写查询主键的sql语句 --&gt;
            &lt;!-- BEFORE--&gt;
            select EMPLOYEES_SEQ.nextval from dual 
            &lt;!-- AFTER：
             select EMPLOYEES_SEQ.currval from dual --&gt;
        &lt;/selectKey&gt;
        
        &lt;!-- 插入时的主键是从序列中拿到的 --&gt;
        &lt;!-- BEFORE:--&gt;
        insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
        values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&lt;!-- ,jdbcType=NULL --&gt;&#125;) 
        &lt;!-- AFTER：
        insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
        values(employees_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;) --&gt;
    &lt;/insert&gt;
</code></pre>
<h3 id="1-5-参数处理"><a href="#1-5-参数处理" class="headerlink" title="1.5 参数处理"></a>1.5 参数处理</h3><p>单个参数：mybatis不会做特殊处理，</p>
<ul>
<li>#{参数名/任意名}：取出参数值。</li>
</ul>
<p>例如：传入的参数只有一个id，可以写任意名字，可以正常执行</p>
<pre><code class="xml">&lt;select id=&quot;getEmpById&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<p>多个参数：mybatis会做特殊处理。</p>
<ul>
<li>多个参数会被封装成 一个map，#{}就是从map中获取指定的key的值；<ul>
<li>key：param1…paramN,或者 参数的索引也可以</li>
<li>value：传入的参数值</li>
</ul>
</li>
</ul>
<p>例如：传入id和lastName，来查询员工表</p>
<pre><code class="xml">&lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;
&lt;/select&gt;
</code></pre>
<pre><code class="java">//测试代码
@Test
    public void test04() throws IOException &#123;
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1.获取到的sqlSession不会自动提交数据，需要手动提交
        SqlSession sqlSession = sqlSessionFactory.openSession();
        EmployeeMapper mapper;
        try &#123;
            mapper = sqlSession.getMapper(EmployeeMapper.class);
            //查询
            Employee tom = mapper.getEmpByIdAndLastName(1, &quot;tom&quot;);
            System.out.println(tom);
            sqlSession.commit();
        &#125; finally &#123;
            sqlSession.close();
        &#125;
    &#125;
</code></pre>
<p>你会发现运行时出现异常：</p>
<pre><code class="java">org.apache.ibatis.binding.BindingException: Parameter &#39;id&#39; not found. Available parameters are [0, 1, param1, param2]
</code></pre>
<p>此时，根据多个参数会被封装成 一个map，你可以这样设置mapper映射文件，key为param1的值和key为param2的值</p>
<pre><code class="xml">&lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;param1&#125; and last_name=#&#123;param2&#125;
&lt;/select&gt;
</code></pre>
<p>这时，程序正常运行，但是参数写成param不能很好的见名知意，所以推荐使用命名参数</p>
<p><strong>命名参数</strong>：明确指定封装参数时map的key；@Param(“id”)，dao层的方法参数加上parma注解</p>
<pre><code class="java">public Employee getEmpByIdAndLastName(@Param(&quot;id&quot;) Integer id, @Param(&quot;lastName&quot;) String lastName);
</code></pre>
<p>这时多个参数会被封装成 一个map，</p>
<ul>
<li><p>key：使用@Param注解指定的值</p>
</li>
<li><p>value：参数值</p>
</li>
</ul>
<p>#{指定的key}取出对应的参数值</p>
<p>所以，多个参数推荐使用命名参数的方法</p>
<p>POJO：<br>如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；<br>    #{属性名}：取出传入的pojo的属性值    </p>
<p><strong>Map</strong>：<br>如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map<br>    #{key}：取出map中对应的值</p>
<pre><code class="java">public Employee getEmpByMap(Map&lt;String, Object&gt; map);
</code></pre>
<pre><code class="xml">&lt;!-- public Employee getEmpByMap(Map&lt;String, Object&gt; map); --&gt;
     &lt;select id=&quot;getEmpByMap&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
         select * from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;
     &lt;/select&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
    public void test04() throws IOException&#123;
        
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1、获取到的SqlSession不会自动提交数据
        SqlSession openSession = sqlSessionFactory.openSession();
        
        try&#123;
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;id&quot;, 2);
            map.put(&quot;lastName&quot;, &quot;Tom&quot;);
            Employee employee = mapper.getEmpByMap(map);
            
            System.out.println(employee);
            
        &#125;finally&#123;
            openSession.close();
        &#125;
    &#125;
</code></pre>
<p>TO：<br>如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象<br>Page{<br>    int index;<br>    int size;<br>}</p>
<p>特别的取值方式：</p>
<blockquote>
<p>public Employee getEmp(@Param(“id”)Integer id,String lastName);<br>    取值：id==&gt;#{id/param1}   lastName==&gt;#{param2}</p>
</blockquote>
<blockquote>
<p>public Employee getEmp(Integer id,@Param(“e”)Employee emp);<br>    取值：id==&gt;#{param1}    lastName===&gt;#{param2.lastName/e.lastName}</p>
</blockquote>
<blockquote>
<p>public Employee getEmpById(List<Integer> ids);<br>    取值：取出第一个id的值：   #{list[0]}</Integer></p>
</blockquote>
<p><strong>特别注意</strong>：如果是Collection（List、Set）类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中。<br>map中的key：Collection的key为(collection)，如果是List还可以使用这个key(list)，数组的key为(array)</p>
<p><strong>结合源码，mybatis怎么处理参数</strong></p>
<blockquote>
<p>总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时 使用的key；#{key}就可以取出map中的值；</p>
</blockquote>
<p>@Param(“id”)Integer id,@Param(“lastName”)String lastName;</p>
<p><code>ParamNameResolver</code>解析参数封装map的；</p>
<ol>
<li><p>names：{0=id, 1=lastName}；构造器的时候就确定好了</p>
<ul>
<li><p>确定流程：</p>
<ul>
<li>获取每个标了param注解的参数的@Param的值：id，lastName；  赋值给name;</li>
<li>每次解析一个参数给map中保存信息：（key：参数索引，value：name的值）<ul>
<li>name的值：<ul>
<li>标注了param注解：注解的值</li>
<li>没有标注：<ol>
<li>全局配置：useActualParamName（jdk1.8）：name=参数名</li>
<li>name=map.size()；相当于当前元素的索引</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>{0=id, 1=lastName,2=2}</p>
</li>
</ul>
<p>args【1，”Tom”,’hello’】</p>
</li>
</ol>
<pre><code class="java">public Object getNamedParams(Object[] args) &#123;
    final int paramCount = names.size();
    //1、参数为null直接返回
    if (args == null || paramCount == 0) &#123;
      return null;
     
    //2、如果只有一个元素，并且没有Param注解；args[0]：单个参数直接返回
    &#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123;
      return args[names.firstKey()];
      
    //3、多个元素或者有Param标注
    &#125; else &#123;
      final Map&lt;String, Object&gt; param = new ParamMap&lt;Object&gt;();
      int i = 0;
      
      //4、遍历names集合；&#123;0=id, 1=lastName,2=2&#125;
      for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;
      
          //names集合的value作为key;  names集合的key又作为取值的参考args[0]:args【1，&quot;Tom&quot;】:
          //eg:&#123;id=args[0]:1,lastName=args[1]:Tom,2=args[2]&#125;
        param.put(entry.getValue(), args[entry.getKey()]);
        
        
        // add generic param names (param1, param2, ...)param
        //额外的将每一个参数也保存到map中，使用新的key：param1...paramN
        //效果：有Param注解可以#&#123;指定的key&#125;，或者#&#123;param1&#125;
        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);
        // ensure not to overwrite parameter named with @Param
        if (!names.containsValue(genericParamName)) &#123;
          param.put(genericParamName, args[entry.getKey()]);
        &#125;
        i++;
      &#125;
      return param;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="1-6-参数获取-与-的区别"><a href="#1-6-参数获取-与-的区别" class="headerlink" title="1.6 参数获取#{}与${}的区别"></a>1.6 参数获取#{}与${}的区别</h3><p>#{}表示一个占位符号 </p>
<ul>
<li>通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换， #{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类 型值，#{}括号中可以是 value 或其它名称。 </li>
</ul>
<p>${}表示拼接 sql 串 </p>
<ul>
<li>通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， ${}可以接收简 单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。</li>
</ul>
<p>#{}：可以获取map中的值或者pojo对象属性的值；</p>
<p>${}：可以获取map中的值或者pojo对象属性的值；</p>
<p>mapper文件，第一个用$获取，第二个用#获取</p>
<pre><code class="xml">&lt;!-- public Employee getEmpByMap(Map&lt;String, Object&gt; map); --&gt;
     &lt;select id=&quot;getEmpByMap&quot; resultType=&quot;com.review.mybatis.bean.Employee&quot;&gt;
         select * from $&#123;tableName&#125; where id=$&#123;id&#125; and last_name=#&#123;lastName&#125;
     &lt;/select&gt;
</code></pre>
<p>测试方法</p>
<pre><code class="java">@Test
    public void test04() throws IOException&#123;
        
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        //1、获取到的SqlSession不会自动提交数据
        SqlSession openSession = sqlSessionFactory.openSession();
        
        try&#123;
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;id&quot;, 2);
            map.put(&quot;lastName&quot;, &quot;Tom&quot;);
            map.put(&quot;tableName&quot;, &quot;tbl_employee&quot;);
            Employee employee = mapper.getEmpByMap(map);
            
            System.out.println(employee);
            
        &#125;finally&#123;
            openSession.close();
        &#125;
    &#125;
</code></pre>
<p>对应的select语句:<code>Preparing: select * from tbl_employee where id=2 and last_name=?</code></p>
<p>区别：</p>
<ul>
<li>#{}:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入</li>
<li>${}:取出的值直接拼装在sql语句中；会有安全问题；</li>
<li>大多情况下，我们去参数的值都应该去使用#{}；</li>
<li>#将传入的数据当成一个字符串，会对自动传入的数据加一个双引号。</li>
<li>$将传入的数据直接显示在sql语句中。</li>
<li>#方式能够很大程度上防止sql注入，而$无法防止sql的注入</li>
<li>$一般用于传入数据库对象，例如传入表名。</li>
<li>mybatis排序时使用order by动态参数时使用$而不是#</li>
</ul>
<p>原生jdbc不支持占位符的地方我们就可以使用${}进行取值，比如分表、排序。。。；按照年份分表拆分</p>
<blockquote>
<p>select * from ${year}_salary where xxx;<br>select * from tbl_employee order by ${f_name} ${order}    </p>
</blockquote>
<h3 id="1-7-更丰富的用法："><a href="#1-7-更丰富的用法：" class="headerlink" title="1.7 #{}:更丰富的用法："></a>1.7 #{}:更丰富的用法：</h3><ul>
<li><p>规定参数的一些规则：</p>
<ul>
<li>javaType、 jdbcType、 mode（存储过程）、 numericScale、resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；</li>
</ul>
</li>
<li><p>jdbcType通常需要在某种特定的条件下被设置：</p>
<ul>
<li>在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）；</li>
<li>JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;</li>
</ul>
<p>由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；两种办法</p>
<ol>
<li>#{email,jdbcType=NULL};</li>
</ol>
<pre><code class="xml">&lt;insert id=&quot;addEmp&quot; databaseId=&quot;oracle&quot;&gt;
        &lt;!-- 
        keyProperty:查出的主键值封装给javaBean的哪个属性
        order=&quot;BEFORE&quot;:当前sql在插入sql之前运行
               AFTER：当前sql在插入sql之后运行
        resultType:查出的数据的返回值类型
        
        BEFORE运行顺序：
            先运行selectKey查询id的sql；查出id值封装给javaBean的id属性
            在运行插入的sql；就可以取出id属性对应的值
        AFTER运行顺序：
            先运行插入的sql（从序列中取出新值作为id）；
            再运行selectKey查询id的sql；
         --&gt;
        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;Integer&quot;&gt;
            &lt;!-- 编写查询主键的sql语句 --&gt;
            &lt;!-- BEFORE--&gt;
            select EMPLOYEES_SEQ.nextval from dual 
            &lt;!-- AFTER：
             select EMPLOYEES_SEQ.currval from dual --&gt;
        &lt;/selectKey&gt;
        
        &lt;!-- 插入时的主键是从序列中拿到的 --&gt;
        &lt;!-- BEFORE:--&gt;
        insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
        values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;emai,jdbcType=NULL&#125;) 
        &lt;!-- AFTER：
        insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
        values(employees_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;) --&gt;
    &lt;/insert&gt;
</code></pre>
<ol start="2">
<li>jdbcTypeForNull=NULL，修改全局配置<setting name="jdbcTypeForNull" value="NULL">
</setting></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection(反射)</title>
    <url>/2020/09/10/Reflection(%E5%8F%8D%E5%B0%84)/</url>
    <content><![CDATA[<h2 id="Reflection-反射"><a href="#Reflection-反射" class="headerlink" title="Reflection(反射)"></a>Reflection(反射)</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 </p>
<ul>
<li>框架 = 反射 + 注解 + 设计模式。</li>
</ul>
<h3 id="1-2-反射机制提供的功能"><a href="#1-2-反射机制提供的功能" class="headerlink" title="1.2 反射机制提供的功能"></a>1.2 反射机制提供的功能</h3><ol>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ol>
<h3 id="1-3-反射相关的主要API"><a href="#1-3-反射相关的主要API" class="headerlink" title="1.3 反射相关的主要API"></a>1.3 反射相关的主要API</h3><ul>
<li> <code>java.lang.Class</code>:代表一个类</li>
<li><code>java.lang.reflect.Method</code>:代表类的方法</li>
<li><code>java.lang.reflect.Field</code>:代表类的成员变量</li>
<li><code>java.lang.reflect.Constructor</code>:代表类的构造器</li>
</ul>
<h3 id="1-4-详解Class类"><a href="#1-4-详解Class类" class="headerlink" title="1.4 详解Class类"></a>1.4 详解Class类</h3><ul>
<li>先上代码，了解反射的基本实现步骤，通过反射对Person类进行操作</li>
</ul>
<pre><code class="java">    @Test
    public void test2() throws Exception &#123;
        Class&lt;Person&gt; clazz = Person.class;
        //通过反射创建Person类对象
        Constructor cons = clazz.getConstructor(String.class, int.class);
        Object obj = cons.newInstance(&quot;tom&quot;, 12);
        Person p=(Person)obj;
        System.out.println(p.toString());//Person&#123;name=&#39;tom&#39;, age=12&#125;
        //通过反射调用对象指定的属性和指定的方法
        //调用属性
        Field age = clazz.getDeclaredField(&quot;age&quot;);
        age.set(p,2);
        System.out.println(p);//Person&#123;name=&#39;tom&#39;, age=2&#125;
        //调用方法
        Method show = clazz.getDeclaredMethod(&quot;show&quot;);
        show.invoke(p);//show()方法

        //通过反射，可以调用person类的私有属性和方法
        Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class);
        constructor.setAccessible(true);//这一步是调用私有构造器的关键
        Person person = constructor.newInstance(&quot;jerry&quot;);
        System.out.println(person);//Person&#123;name=&#39;jerry&#39;, age=0&#125;
        //调用私有属性
        Field name = clazz.getDeclaredField(&quot;name&quot;);
        name.setAccessible(true);//这一步是调用私有属性的关键
        name.set(person,&quot;zhangsan&quot;);
        System.out.println(person);//Person&#123;name=&#39;zhangsan&#39;, age=0&#125;
        //调用私有方法
        Method showNation = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class);
        showNation.setAccessible(true);
        Object nation = showNation.invoke(person,&quot;中国&quot;);//showNation()方法
        String nat=(String)nation;
        System.out.println(nat);//中国
    &#125;
</code></pre>
<p>首先，根据上述代码，首先要获取一个Class类的实例(clazz)，此实例就是Person.class，Person.class就是运行时类</p>
<ol>
<li>类的加载过程：<br>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。<br>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件<br>加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此<br>运行时类，就作为Class的一个实例。</li>
<li>换句话说，Class的实例就对应着一个运行时类。</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式<br>来获取此运行时类。</li>
</ol>
<p>在Object类中定义了以下的方法，此方法 将被所有子类继承： </p>
<p><code>public final Class getClass()</code><br>以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即： 可以<code>通过对象反射求出类的名称</code>。</p>
<ul>
<li>正常方式 : 引入需要的<code>包类</code>名称 ——&gt; 通过<code>new</code>实例化 ——&gt; 取得实例化对象</li>
<li>反射方式 : 实例化对象 ——&gt; <code>getClass()</code> ——&gt; 得到完整的<code>包类</code>名称</li>
</ul>
<h3 id="1-5-四种获取Class类实例的方式"><a href="#1-5-四种获取Class类实例的方式" class="headerlink" title="1.5 四种获取Class类实例的方式"></a>1.5 四种获取Class类实例的方式</h3><pre><code class="java">    @Test
    public void test3()&#123;
        //方式一：调用运行时类的属性：.class
        Class&lt;Person&gt; clazz1 = Person.class;
        System.out.println(clazz1);//class com.review.reflection.Person,person类本身
        //方式二：通过运行时类的对象,调用getClass()方法
        Person p1=new Person();
        Class&lt;? extends Person&gt; clazz2 = p1.getClass();
        System.out.println(clazz2);//class com.review.reflection.Person,person类本身
        //方式三：调用Class的静态方法.forName(String classPath)
        try &#123;
            Class&lt;?&gt; clazz3 = Class.forName(&quot;com.review.reflection.Person&quot;);
            System.out.println(clazz3);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(clazz1==clazz2);//true
        //上面三种方式获取的都是同一个运行时类，同一个内存地址
        //方式四：使用类的加载器ClassLoader，通过classLoader获取Class类实例
        try &#123;
            ClassLoader classLoader = Person.class.getClassLoader();
            Class&lt;?&gt; clazz4 = classLoader.loadClass(&quot;com.review.reflection.Person&quot;);
            System.out.println(clazz4);//com.review.reflection.Person
            System.out.println(clazz1==clazz4);//true
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        //四种方式获取的运行时类都是一样的，地址相同
    &#125;
</code></pre>
<h3 id="1-6-哪些类型有Class对象"><a href="#1-6-哪些类型有Class对象" class="headerlink" title="1.6 哪些类型有Class对象"></a>1.6 哪些类型有Class对象</h3><ul>
<li>class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 </li>
<li>interface：接口 </li>
<li>[]：数组 </li>
<li>enum：枚举 </li>
<li>annotation：注解@interface </li>
<li>primitive type：基本数据类型 </li>
<li>void</li>
</ul>
<h3 id="1-7-类加载器ClassLoader"><a href="#1-7-类加载器ClassLoader" class="headerlink" title="1.7 类加载器ClassLoader"></a>1.7 类加载器ClassLoader</h3><p>类加载器的作用:把<code>类(class)</code>装载进内存.如下示例</p>
<pre><code>Java源文件(*.java) ——Java编译器——&gt; 字节码文件(*.class) ——类加载器+字节码效验器+解释器——&gt; 操作系统平台
</code></pre>
<p><strong>类加载的过程</strong>：</p>
<p>当程序主动使用某个类时,如果该类还未被<code>加载</code>到内存中,则系统会通知如下三个步骤来对该类进行初始化.</p>
<ol>
<li>类的加载 : 将类的<code>Class</code>文件读入到内存,并为之创建一个<code>java.lang.Class</code>对象,此过程由类加载器完成.</li>
<li>类的链接 : 将类的<code>二进制</code>数据合并到<code>JRE</code>中.</li>
<li>类的初始化 : <code>JVM</code>负责对类进行初始化.</li>
</ol>
<p><code>JVM</code>规范定义了两种类型的类加载器:<code>启动类加载器(bootstrap)</code>和<code>用户自定义加载器(user-defined class loader)</code>，JVM在运行时会产生<code>三个类加载器</code></p>
<ol>
<li>引导类加载器:<code>JVM</code>自带的类加载器,负责Java平台核心库,用来加载核心类库,该加载器无法直接获取.</li>
<li>扩展类加载器:负责<code>jar包</code>或将指定目录下的<code>jar包</code>装入工作库.</li>
<li>系统类加载器:负责<code>java-classpath</code>或<code>java.class.path</code>所指的目录下的类与<code>jar</code>包装入工作.(最常用)</li>
</ol>
<pre><code class="java">    @Test
    public void test1() &#123;
        //对于自定义类，使用系统类加载器加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();//由系统类加载器加载
        System.out.println(classLoader);//AppClassLoader
        //调用系统类加载器的getParent()方法可以获取扩展类加载器
        ClassLoader classLoader1 = classLoader.getParent();//获取扩展类加载器
        System.out.println(classLoader1);//PlatformClassLoader
        //调用扩展类加载器的getParent()方法无法获取引导类加载器
        ClassLoader classLoader2 = classLoader1.getParent();
        System.out.println(classLoader2);//null引导类加载器获取不到，主要加载java核心类库，无法加载自定义类

        ClassLoader classLoader3 = String.class.getClassLoader();
        System.out.println(classLoader3);//null,引导类加载器无法拿到
    &#125;
</code></pre>
<p><strong>应用：使用ClassLoader加载配置文件</strong></p>
<pre><code class="java">    @Test
    public void test2() throws Exception &#123;
        Properties properties=new Properties();
        //此时文件默认在当前的module下
        //读取配置文件1
        /*FileInputStream fis=new FileInputStream(&quot;jdbc.properties&quot;);
        properties.load(fis);*/
        //读取配置文件2，使用classloader
        //文件默认识别在当前module下的src下
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;);
        properties.load(is);

        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        System.out.println(user+&quot;:&quot;+password);
    &#125;
</code></pre>
<h3 id="1-8-newInstance-创建运行时类的对象"><a href="#1-8-newInstance-创建运行时类的对象" class="headerlink" title="1.8 newInstance()创建运行时类的对象"></a>1.8 newInstance()创建运行时类的对象</h3><p><code>newInstance()</code>:调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p>
<p>要想此方法正常的创建运行时类的对象，要求：</p>
<ol>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的访问权限得够。通常，设置为public。</li>
</ol>
<p>在javabean中要求提供一个public的空参构造器。原因：</p>
<ol>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器</li>
</ol>
<pre><code class="java">    @Test
    public void test1() throws Exception &#123;
        Class&lt;Person&gt; clazz = Person.class;
        /*
        newInstance():调用此方法，创建对应的运行时类的对象
         */
        Person person = clazz.newInstance();//java9之后已过时
        System.out.println(person);
        //
        Person person1 = clazz.getDeclaredConstructor().newInstance();//推荐

    &#125;
</code></pre>
<h3 id="1-9-获取运行时类的指定结构"><a href="#1-9-获取运行时类的指定结构" class="headerlink" title="1.9 获取运行时类的指定结构"></a>1.9 获取运行时类的指定结构</h3><ol>
<li><p>获取成员变量们</p>
<ul>
<li><code>Field[] getFields()</code> ：获取所有public修饰的成员变量(属性)</li>
<li><code>Field getField(String name)</code>:获取指定名称的 public修饰的成员变量(属性)</li>
<li><code>Field[] getDeclaredFields()</code>:  获取所有的成员变量(属性)，不考虑修饰符</li>
<li><code>Field getDeclaredField(String name)</code>  :获取指定名称的当前运行时类的属性，不考虑权限</li>
</ul>
</li>
<li><p>获取构造方法们</p>
<ul>
<li><code>Constructor&lt;?&gt;[] getConstructors()</code>  :获取当前运行时Public修饰的构造方法们</li>
<li><code>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</code>  :获取指定参数的构造方法</li>
<li><code>Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</code>  </li>
<li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>  :获取当前运行时构造方法们,不考虑修饰符</li>
</ul>
</li>
<li><p>获取成员方法们(同理加Declared是不考虑修饰符)：</p>
<ul>
<li><code>Method[] getMethods()</code>  </li>
<li><code>Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</code>  </li>
<li><code>Method[] getDeclaredMethods()</code>  </li>
<li><code>Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</code>  </li>
</ul>
</li>
<li><p>获取全类名:<code>String getName()</code>  </p>
</li>
<li><p>成员变量操作：</p>
<ul>
<li>设置值:<code>void set(Object obj, Object value)</code>  </li>
<li>获取值:<code>get(Object obj)</code> </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<ul>
<li>setAccessible(true):暴力反射</li>
</ul>
</li>
<li><p>创建对象：T newInstance(Object… initargs)<br>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p>
</li>
<li><p>Method：方法对象<br>执行方法：<code>Object invoke(Object obj, Object... args)</code><br>获取方法名称：<code>String getName</code>:获取方法名</p>
</li>
</ol>
<h3 id="2-0-反射的应用"><a href="#2-0-反射的应用" class="headerlink" title="2.0 反射的应用"></a>2.0 反射的应用</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><ul>
<li>原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 </li>
</ul>
<h4 id="动态代理介绍"><a href="#动态代理介绍" class="headerlink" title="动态代理介绍"></a>动态代理介绍</h4><ol>
<li><p>概念 动态代理是指客户通过代理类来调用其它对象的方法,并且是在程序运行时根据需要动态创建目标类的代理对象.</p>
</li>
<li><p>使用场合 调试及远程方法调用等.</p>
</li>
<li><p>动态代理相关API</p>
<ul>
<li><p>Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p>
</li>
<li><p>提供用于创建动态代理类和动态代理对象的静态方法 <code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>  </p>
</li>
<li><p>创建 一个动态代理类所对应的Class对象 <code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>  直接创建一个动态代理对象(loader:类加载器，interfaces：被代理类实现的全部接口，h：得到InvocationHandler接 口的实现类实例)</p>
</li>
<li><p><code>InvocationHandler</code>：创建一个实现接口InvocationHandler的类，它必须实现invoke方 法，以完成代理的具体操作。</p>
<pre><code class="java">public Object invoke(Object theProxy, Method method, Object[] params) throws Throwable&#123; 
    try&#123; Object retval = method.invoke(targetObj, params); // Print out the result 
        System.out.println(retval); 
        return retval; 
    &#125;catch (Exception exc)&#123;&#125; 
&#125;//theProxy:代理类对象，method：调用的方法，params：调用方法所传入的参数
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="静态代理示例"><a href="#静态代理示例" class="headerlink" title="静态代理示例"></a>静态代理示例</h4><p>为了与动态代理相比较,静态代理程序示例如下.不难发现: 如果添加不同接口则需要不同的代理类来完成其代理!很繁琐!</p>
<p>代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。<br>每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p>
<pre><code class="java">/*
静态代理举例
 */
interface ClotFactory&#123;
    void produceCloth();
&#125;
//代理类
class ProxyClothFactory implements ClotFactory&#123;

    private ClotFactory factory;//拿被代理类对象进行实例化
    public ProxyClothFactory(ClotFactory factory)&#123;
        this.factory=factory;
    &#125;
    @Override
    public void produceCloth() &#123;
        System.out.println(&quot;代理工厂准备工作&quot;);
        factory.produceCloth();
    &#125;
&#125;
//被代理类
class Factory implements ClotFactory&#123;

    @Override
    public void produceCloth() &#123;
        System.out.println(&quot;生产衣服&quot;);
    &#125;
&#125;
public class StaticProxyTest &#123;
    public static void main(String[] args) &#123;
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(new Factory());
        proxyClothFactory.produceCloth();
    &#125;
&#125;
</code></pre>
<h4 id="动态代理示例"><a href="#动态代理示例" class="headerlink" title="动态代理示例"></a>动态代理示例</h4><p><strong>反射的动态性</strong></p>
<pre><code class="java">/*
动态代理举例
 */
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Human&#123;
    String getBelief();
    void eat(String food);
&#125;

//被代理类
class SupperMan implements Human&#123;

    @Override
    public String getBelief() &#123;
        return &quot;I Belief I can Fly&quot;;
    &#125;

    @Override
    public void eat(String food) &#123;
        System.out.println(&quot;我喜欢吃：&quot;+food);
    &#125;
&#125;

/*
动态创建代理类
问题：如何根据内存中的被代理类，动态的创建一个代理类及其对象

当通过代理类的对象调用方法时，如何动态的区调用被代理类中的同名方法
 */
//代理类生产工厂，用这个类来生成代理类
class ProxyFactory&#123;
    //调用此方法返回一个代理类对象，解决问题一
    public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象
        MyInvocationHandler handler=new MyInvocationHandler();
        handler.bind(obj);
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);
        //java.lang.reflect.Proxy：该类用于动态生成代理类，
        // 只需传入目标接口的类加载器、目标接口以及InvocationHandler便可为目标接口生成代理类及代理对象。

        //newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h):
        // 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例
    &#125;
&#125;
class MyInvocationHandler implements InvocationHandler&#123;

    private Object obj;//需要被代理类对象进行赋值
    public void bind(Object obj)&#123;
        this.obj=obj;
    &#125;
    //当我们通过代理类的对象调用方法A时就睡自动的调用如下方法：invok()
    //将被代理类要执行的方法A的功能声明在invoke中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;

        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //obj:被代理类对象
        Object returnValue = method.invoke(obj, args);
        //上述方法的返回值就作为当前类中的invok方法的返回值
        return returnValue;
    &#125;
&#125;
public class ProxyTest &#123;
    public static void main(String[] args) &#123;
        //proxyInstance:代理类对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(new SupperMan());
        //当通过代理类调用方法时，会自动的调用被代理类方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);
        proxyInstance.eat(&quot;汉堡&quot;);

        System.out.println(&quot;*********&quot;);

        Factory factory = new Factory();
        ClotFactory proxyInstance1 = (ClotFactory) ProxyFactory.getProxyInstance(factory);
        proxyInstance1.produceCloth();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/10/08/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h3><p>基于配置文件+注解的方式整合SSM</p>
<p>版本</p>
<ul>
<li>JDK：12.0.2</li>
<li>MySQL：5.7.28</li>
<li>Spring：5.0.2</li>
<li>mybatis：3.4.5</li>
</ul>
<ol>
<li>首先进行环境搭建，创建数据库表</li>
</ol>
<pre><code class="mysql">CREATE DATABASE ssm;
CREATE TABLE account(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20),
money DOUBLE
);
</code></pre>
<ol start="2">
<li>创建Maven工程</li>
</ol>
<p><img src="/2020/10/08/SSM%E6%95%B4%E5%90%88/image-20200926174451484.png" alt="image-20200926174451484"></p>
<ol start="3">
<li>导入坐标</li>
</ol>
<pre><code class="xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;12.0.2&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;12.0.2&lt;/maven.compiler.target&gt;
    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
    &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
    &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
    &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;
    &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;

    &lt;!-- spring --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
      &lt;version&gt;1.6.8&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;


    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;jstl&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- log start --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log end --&gt;
      
    &lt;!-- mybatis--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
      &lt;version&gt;1.3.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mysql数据库 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- c3p0数据库连接池，配合JDBCTemplate操作CRUD--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;c3p0&lt;/groupId&gt;
      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
      &lt;version&gt;0.9.1.2&lt;/version&gt;
      &lt;type&gt;jar&lt;/type&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<p>到此，所有关于SSM需要的依赖都引入了</p>
<h3 id="1-2-Spring配置"><a href="#1-2-Spring配置" class="headerlink" title="1.2 Spring配置"></a>1.2 Spring配置</h3><p>创建service，dao，controller，domain，test包</p>
<p><img src="/2020/10/08/SSM%E6%95%B4%E5%90%88/image-20200926183935071.png" alt="image-20200926183935071"></p>
<p>创建Spring配置文件,applicationContext.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot; &gt;
        &lt;!--配置哪些注解不扫描--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;/context:component-scan&gt;

&lt;/beans&gt;
</code></pre>
<p>编写各个类，测试Spring不需要用到controller层</p>
<pre><code>/**
 * 帐户：controller层
 */
public class AccountController &#123;

&#125;
</code></pre>
<p>实体类domain</p>
<pre><code class="java">/**
 * 帐户，根据数据库中的表创建
 */
public class Account&#123;
    private Integer id;
    private String name;
    private Double money;
    //setter和getter方法
    //toString方法
&#125;
</code></pre>
<p>dao层</p>
<pre><code class="java">/**
 * 帐户dao接口
 */
public interface AccountDao &#123;
    public List&lt;Account&gt; findAll();
    public void saveAccount(Account account);
&#125;
</code></pre>
<p>Service层，在Service层加上Service注解，使用Spring的IOC进行管理</p>
<pre><code class="java">@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements AccountService &#123;

    public List&lt;Account&gt; findAll() &#123;
        System.out.println(&quot;业务层：查询所有账户...&quot;);
        return null;
    &#125;
    public void saveAccount(Account account) &#123;
        System.out.println(&quot;业务层：保存帐户...&quot;);
    &#125;
&#125;
</code></pre>
<p>测试方法</p>
<pre><code class="java">public class TestSpring &#123;

    @Test
    public void run1()&#123;
        // 加载配置文件
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        // 获取对象
        AccountService as = (AccountService) ac.getBean(&quot;accountService&quot;,AccountService.class);
        // 调用方法
        as.findAll();
    &#125;
&#125;
</code></pre>
<p>运行结果为：业务层：查询所有账户… 表示Spring以及配置完成</p>
<h3 id="1-3-SpringMVC配置"><a href="#1-3-SpringMVC配置" class="headerlink" title="1.3 SpringMVC配置"></a>1.3 SpringMVC配置</h3><p>首先进行全局配置在web.xml中配置</p>
<pre><code class="java">&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

  &lt;!--配置前端控制器--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--加载springmvc.xml配置文件--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动服务器，创建该servlet--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

  &lt;!--解决中文乱码的过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>在resources中创建SpringMVC的配置文件springmvc.xml</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启注解扫描，只扫描Controller注解--&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;/context:component-scan&gt;

    &lt;!--配置的视图解析器对象--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--过滤静态资源--&gt;
    &lt;!--&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;--&gt;
    &lt;mvc:default-servlet-handler/&gt;

    &lt;!--开启SpringMVC注解的支持--&gt;
    &lt;mvc:annotation-driven/&gt;

&lt;/beans&gt;
</code></pre>
<p>在index.jsp中添加链接测试</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;account/findAll&quot;&gt;测试&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在控制层实现功能</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/account&quot;)
public class AccountController &#123;
    @RequestMapping(&quot;/findAll&quot;)
    public String findAll()&#123;
        System.out.println(&quot;表现层：查询所有用户&quot;);
        return &quot;list&quot;;
    &#125;
&#125;
</code></pre>
<p>添加返回的list.jsp页面</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt; 查询所有信息 &lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>SpringMVC配置完成，启动tomcat服务器，跳转成功，控制台打印输出：表现层：查询所有用户  到此SpringMVC配置成功</p>
<h3 id="1-4-Spring整合SpringMVC"><a href="#1-4-Spring整合SpringMVC" class="headerlink" title="1.4 Spring整合SpringMVC"></a>1.4 Spring整合SpringMVC</h3><p>原理：</p>
<ul>
<li><p>Spring整合SpringMVC之后能够在控制层调用service层方法，要想调用service方法需要有service对象，controller已经放入容器了，如果把service也放入容器，在controller中注入service对象，就能用service对象调用service方法</p>
</li>
<li><p>在web.xml中只配置了加载springmvc.xml，springmvc的配置文件中只扫描controller注解，别的注解不扫，因为spring配置文件没有被加载过，所以spring配置文件中配置的service注解不扫描，所以service类就没被加入到IOC的容器中，所以也不能注入</p>
</li>
<li><p>解决方法是在启动服务器时也要加载spring的配置文件，这样service类就会被放入容器，这样就能使用依赖注入将service注入到controller</p>
</li>
<li><p>ServletContext对象是servlet中最大的域对象，这个对象只会被创建一次，服务器启动时创建，关闭时销毁，这个对象的生命周期和tomcat的生命周期一样</p>
</li>
<li><p>有一个监听器可以监听ServletContext域对象的创建和销毁，一旦ServletContext对象被创建则此监听器就会被执行，只会执行一次，在服务器启动时执行，使用此监听器加载Spring配置文件，监听器会创建WEB版本的工程，存储ServletContext对象</p>
</li>
<li><p>监听器已经写好，只需要配置就行</p>
</li>
</ul>
<p>通过监听器整合，先配置web.xml，servlet，监听器，过滤器三大组件配置完成</p>
<pre><code class="xml">&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

  &lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;!--设置配置文件的路径--&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
  &lt;/context-param&gt;


  &lt;!--配置前端控制器--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--加载springmvc.xml配置文件--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动服务器，创建该servlet--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

  &lt;!--解决中文乱码的过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>测试控制层代码，通过控制层调用service层</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/account&quot;)
public class AccountController &#123;

    @Autowired
    private AccountService accountService;

    @RequestMapping(&quot;/findAll&quot;)
    public String findAll()&#123;
        System.out.println(&quot;表现层：查询所有用户&quot;);
        //调用service方法
        accountService.findAll();
        return &quot;list&quot;;
    &#125;

&#125;
</code></pre>
<p>Spring整合SpringMVC成功，启动服务器，点击测试成功跳转后，控制台输出结果为：</p>
<p>表现层：查询所有用户<br>业务层：查询所有账户…</p>
<p>表示Spring整合SpringMVC成功</p>
<h3 id="1-5-MyBatis配置"><a href="#1-5-MyBatis配置" class="headerlink" title="1.5 MyBatis配置"></a>1.5 MyBatis配置</h3><p>首先在resource文件夹中配置mybatis的配置文件：SqlMapConfig.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;
    &lt;mappers&gt;
        &lt;!--&lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&gt;
        &lt;mapper class=&quot;com.review.dao.AccountDao&quot;/&gt;--&gt;
        &lt;package name=&quot;com.review.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>然后再dao层直接使用注解实现sql</p>
<pre><code class="java">/**
 * 帐户dao接口
 */

public interface AccountDao &#123;
    // 查询所有账户
    @Select(&quot;select * from account&quot;)
    public List&lt;Account&gt; findAll();

    // 保存帐户信息
    @Insert(&quot;insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)&quot;)
    public void saveAccount(Account account);

&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">public class TestMyBatis &#123;

    /**
     * 测试查询
     * @throws Exception
     */
    @Test
    public void run1() throws Exception &#123;
        // 加载配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 创建SqlSessionFactory对象
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        // 创建SqlSession对象
        SqlSession session = factory.openSession();
        // 获取到代理对象
        AccountDao dao = session.getMapper(AccountDao.class);
        // 查询所有数据
        List&lt;Account&gt; list = dao.findAll();
        for(Account account : list)&#123;
            System.out.println(account);
        &#125;
        // 关闭资源
        session.close();
        in.close();
    &#125;

    /**
     * 测试保存
     * @throws Exception
     */
    @Test
    public void run2() throws Exception &#123;
        Account account = new Account();
        account.setName(&quot;jack&quot;);
        account.setMoney(400d);

        // 加载配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 创建SqlSessionFactory对象
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        // 创建SqlSession对象
        SqlSession session = factory.openSession();
        // 获取到代理对象
        AccountDao dao = session.getMapper(AccountDao.class);
        // 保存
        dao.saveAccount(account);
        // 提交事务
        session.commit();
        // 关闭资源
        session.close();
        in.close();
    &#125;

&#125;
</code></pre>
<p>最后查看数据库中的数据是否被查出，是否被存入，如果执行成功，表示mybatis配置完成</p>
<h3 id="1-6-Spring整合MyBatis"><a href="#1-6-Spring整合MyBatis" class="headerlink" title="1.6 Spring整合MyBatis"></a>1.6 Spring整合MyBatis</h3><p>service能够成功调用dao对象，表示Spring整合MyBatis成功</p>
<p>原理：</p>
<ul>
<li>Service类已经被放入IOC容器中，Dao是一个接口，但是可以生成代理对象，把生成的代理对象也存到IOC容器中，则Service通过注入也可以拿到这个对象，调用dao的方法</li>
<li>在Spring的配置文件中配置MyBatis属性，配置三部分，第一部分配置连接池，</li>
<li>然后配置SqlSessionFactory工厂，IOC容器中有工厂，可以通过工厂对象创建session对象，有了session可以创建代理，有了代理可以把代理存入IOC容器中，</li>
<li>最后要配置接口所在包，可以让IOC知道帮你生成哪些接口的代理对象</li>
</ul>
<p>配置spring的配置文件：applicationContext.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot; &gt;
        &lt;!--配置哪些注解不扫描--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;/context:component-scan&gt;

    &lt;!--Spring整合MyBatis框架--&gt;
    &lt;!--配置连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置SqlSessionFactory工厂,传入连接池--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置AccountDao接口所在包--&gt;
    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.review.dao&quot;/&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;
</code></pre>
<p>之后就可以删除mybatis的配置文件：SqlMapConfig.xml</p>
<p>然后再dao层加上注解，将AccountDao交给IOC容器管理</p>
<pre><code class="java">@Repository
public interface AccountDao &#123;
    // 查询所有账户
    @Select(&quot;select * from account&quot;)
    public List&lt;Account&gt; findAll();

    // 保存帐户信息
    @Insert(&quot;insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)&quot;)
    public void saveAccount(Account account);

&#125;
</code></pre>
<p>在Service中注入dao接口</p>
<pre><code class="java">@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements AccountService &#123;

    @Autowired
    private AccountDao accountDao;

    public List&lt;Account&gt; findAll() &#123;
        System.out.println(&quot;业务层：查询所有账户...&quot;);
        return accountDao.findAll();
    &#125;

    public void saveAccount(Account account) &#123;
        System.out.println(&quot;业务层：保存帐户...&quot;);
        accountDao.saveAccount(account);
    &#125;
&#125;
</code></pre>
<p>此时，spring整合springmvc成功，整合MyBatis成功，从controller层也可以直接访问Service层，Service层到dao层，一切畅通，修改controller层代码测试，调用Service方法返回list，将list存入request域中返回到list页面展示出来</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/account&quot;)
public class AccountController &#123;

    @Autowired
    private AccountService accountService;

    @RequestMapping(&quot;/findAll&quot;)
    public String findAll(Model model)&#123;
        System.out.println(&quot;表现层：查询所有用户&quot;);
        //调用service方法
        List&lt;Account&gt; list = accountService.findAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;list&quot;;
    &#125;
&#125;
</code></pre>
<p>list.jsp</p>
<pre><code class="java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot;  isELIgnored=&quot;false&quot; %&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt; 查询所有信息 &lt;/h3&gt;
&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;account&quot;&gt;
    $&#123;account.name&#125;
&lt;/c:forEach&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>结果：跳转成功，从数据库拿到数据</p>
<p><img src="/2020/10/08/SSM%E6%95%B4%E5%90%88/image-20200926210955002.png" alt="image-20200926210955002"></p>
<h3 id="1-7-Spring整合MyBatis框架配置事务"><a href="#1-7-Spring整合MyBatis框架配置事务" class="headerlink" title="1.7 Spring整合MyBatis框架配置事务"></a>1.7 Spring整合MyBatis框架配置事务</h3><p>上面你会发现使用的是查询方法，此时能够显示在页面上，但是要是执行增删改方法则没有效果，因为我们需要手动提交事务(可以查看上述mybatis配置这一小节中的测试方法，第二个方法保存信息只有加了session.commit();才能保存成功)，所以需要配置事务</p>
<p>在spring配置文件中配置事务：applicationContext.xml</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot; &gt;
        &lt;!--配置哪些注解不扫描--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;/context:component-scan&gt;

    &lt;!--Spring整合MyBatis框架--&gt;
    &lt;!--配置连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置SqlSessionFactory工厂,传入连接池--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置AccountDao接口所在包--&gt;
    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.review.dao&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置Spring框架声明式事务管理--&gt;
    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置事务通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--配置AOP增强--&gt;
    &lt;aop:config&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.review.service.impl.*ServiceImpl.*(..))&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>然后再index.jsp中加入添加的form表单</p>
<pre><code class="html">&lt;body&gt;
&lt;a href=&quot;account/findAll&quot;&gt;测试&lt;/a&gt;
&lt;form action=&quot;account/save&quot; method=&quot;post&quot;&gt;
    姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br/&gt;
    金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;br/&gt;
&lt;/form&gt;
&lt;/body&gt;
</code></pre>
<p>在控制层加入保存的代码</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/account&quot;)
public class AccountController &#123;

    @Autowired
    private AccountService accountService;

    @RequestMapping(&quot;/findAll&quot;)
    public String findAll(Model model)&#123;
        System.out.println(&quot;表现层：查询所有用户&quot;);
        //调用service方法
        List&lt;Account&gt; list = accountService.findAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;list&quot;;
    &#125;

    /**
     * 保存
     * @return
     */
    @RequestMapping(&quot;/save&quot;)
    public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        accountService.saveAccount(account);
        //重定向
        response.sendRedirect(request.getContextPath()+&quot;/account/findAll&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>到此，事务配置完成，整个ssm框架配置完成</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet基本使用</title>
    <url>/2020/09/19/Servlet/</url>
    <content><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>Servlet 是 JavaEE 规范之一。规范就是接口 </li>
<li>Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。</li>
<li>Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。</li>
</ul>
<h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2 快速入门"></a>1.2 快速入门</h3><ul>
<li>先创建一个类实现Servlet接口</li>
</ul>
<pre><code class="java">/*
Servlet快速入门
 */
public class ServletDemo1 implements Servlet &#123;
    @Override
    public void init(ServletConfig servletConfig) throws ServletException &#123;

    &#125;

    @Override
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;

    //提供服务的方法
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
        System.out.println(&quot;hello Servlet&quot;);
    &#125;

    @Override
    public String getServletInfo() &#123;
        return null;
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<ul>
<li>在xml中配置：每创建一个servlet都需要在xml中配置<code>servlet</code>和<code>servlet-mapping</code></li>
</ul>
<pre><code class="xml">&lt;!-- 配置Servlet --&gt;
    &lt;!-- servlet标签给Tomcat配置Servlet程序--&gt;
    &lt;servlet&gt;
        &lt;!--servlet-name标签Servlet程序起一个别名（一般是类名 ）--&gt;
        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
        &lt;!--servlet-class是Servlet程序的全类名--&gt;
        &lt;servlet-class&gt;com.web.servlet.ServletDemo1&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;!--servlet-mapping标签给servlet程序配置访问地址--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给哪个Servlet程序使用--&gt;
        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
        &lt;!--url-pattern标签配置访问地址    &lt;br/&gt;
                /斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径   &lt;br/&gt;
                /demo1表示地址为：http://ip:port/工程路径/demo1   &lt;br/&gt;--&gt;
        &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;
        &lt;!--当输入http://localhost:8080/08_Servlet_war_exploded/demo1时，进入到ServletDemo1，控制台会输出hello servlet--&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;demo2&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.web.servlet.ServletDemo2&lt;/servlet-class&gt;
        &lt;!--指定servlet的创建时机
        第一次被访问时创建，值为负数
        在服务器启动时创建，置为0或正整数
        --&gt;
        &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
</code></pre>
<ul>
<li>图解</li>
</ul>
<p><img src="/2020/09/19/Servlet/image-20200908163143658.png" alt="image-20200908163143658"></p>
<h3 id="1-3-Servlet生命周期"><a href="#1-3-Servlet生命周期" class="headerlink" title="1.3 Servlet生命周期"></a>1.3 Servlet生命周期</h3><ol>
<li><p>执行 Servlet 构造器方法 </p>
</li>
<li><p>执行 init 初始化方法，只执行一次</p>
<p>第一、二步，是在第一次访问时创建 Servlet 程序时会调用。</p>
<p>Servlet被创建的时机可以 在<servlet>标签下配置  <load-on-startup>实现</load-on-startup></servlet></p>
<p><load-on-startup> 值为负数，第一次被访问时创建 ，值为0或正整数在服务器启动时创建</load-on-startup></p>
<p>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的，多个用户同时访问时，可能存在线程安全问题。解决方法：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值提供服务</p>
</li>
<li><p>执行service方法，执行多次每次访问Servlet时，Service方法都会被调用一次。</p>
</li>
<li><p>执行destroy方法，只执行一次Servlet被销毁时执行。服务器关闭时，Servlet被销毁只有服务器正常关闭时，才会执行destroy方法destroy方法在Servlet被销毁之前执行，一般用于释放资源</p>
</li>
</ol>
<h4 id="post和get请求分发处理"><a href="#post和get请求分发处理" class="headerlink" title="post和get请求分发处理"></a>post和get请求分发处理</h4><pre><code class="java"> @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
        System.out.println(&quot;3 service === Hello Servlet 被访问了&quot;);
        // 类型转换（因为它有getMethod()方法）
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        // 获取请求的方式
        String method = httpServletRequest.getMethod();

        if (&quot;GET&quot;.equals(method)) &#123;
            System.out.println(&quot;get请求&quot;);
        &#125; else if (&quot;POST&quot;.equals(method)) &#123;
            System.out.println(&quot;post请求&quot;);
        &#125;

    &#125;
</code></pre>
<p>直接在浏览器地址栏中输入地址后敲回车是get请求，所以下面的代码都是放在doget中</p>
<h3 id="1-4-ServletConfig类"><a href="#1-4-ServletConfig类" class="headerlink" title="1.4 ServletConfig类"></a>1.4 ServletConfig类</h3><p><strong>servlet类的继承体系</strong></p>
<p><img src="/2020/09/19/Servlet/image-20200909084700597.png" alt="image-20200909084700597"></p>
<ul>
<li><p>GenericServlet类实现了servlet接口，并持有ServletConfig类的引用，对ServletConfig的使用提供了一些方法</p>
</li>
<li><p>ServletConfig 类是 Servlet 程序的<strong>配置信息</strong>类。</p>
</li>
<li><p>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。</p>
</li>
<li><p>Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对<br>象。</p>
</li>
</ul>
<p><code>ServletConfig</code>类的作用：<strong>获取配置信息</strong></p>
<ul>
<li><p>可以获取 Servlet 程序的别名 servlet-name 的值</p>
</li>
<li><p>获取初始化参数 init-param</p>
</li>
<li><p>获取 ServletContext 对象</p>
</li>
</ul>
<p><code>init-param</code>参数：初始化参数，配置在xml的servlet中，可以有多个，键值对形式</p>
<pre><code class="xml">&lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.review.servlet.HelloServlet&lt;/servlet-class&gt;
        &lt;!--init-param是初始化参数--&gt;
        &lt;init-param&gt;
            &lt;!--是参数名--&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;!--是参数值--&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--init-param是初始化参数--&gt;
        &lt;init-param&gt;
            &lt;!--是参数名--&gt;
            &lt;param-name&gt;url&lt;/param-name&gt;
            &lt;!--是参数值--&gt;
            &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p>在init()方法中使用，当你实现servlet接口，重写init方法时可以获取初始化参数</p>
<pre><code class="java">public class HelloServlet implements Servlet &#123;
    public HelloServlet() &#123;
        System.out.println(&quot;1 构造器方法&quot;);
    &#125;

    @Override
    public void init(ServletConfig servletConfig) throws ServletException &#123;
        System.out.println(&quot;2 init初始化方法&quot;);

//        1、可以获取Servlet程序的别名servlet-name的值
        System.out.println(&quot;HelloServlet程序的别名是:&quot; + servletConfig.getServletName());
//        2、获取初始化参数init-param
        System.out.println(&quot;初始化参数username的值是;&quot; + servletConfig.getInitParameter(&quot;username&quot;));
        System.out.println(&quot;初始化参数url的值是;&quot; + servletConfig.getInitParameter(&quot;url&quot;));
//        3、获取ServletContext对象
        System.out.println(servletConfig.getServletContext());
    &#125;
&#125;
</code></pre>
<p>在init方法外使用，当你继承HttpServlet时，你可以在<code>doget</code>或<code>dopost</code>方法中通过<code>getServletConfig()</code>方法来得到<code>servletConfig</code>对象</p>
<p><strong>注意</strong>：</p>
<ul>
<li>当自定义类继承了HttpServlet类的时候，此时若想重写init方法，则要加上<code>super.init(config);</code>，否则在使用ServletConfig类的时候会报空指针异常。</li>
<li>每一个ServletConfig类对应自己的Servlet，不能获取其他servlet的初始参数，例如<code>HelloServlet2</code>不能获取<code>HelloServlet</code>的参数</li>
</ul>
<pre><code class="java">public class HelloServlet2 extends HttpServlet &#123;

    @Override
    public void init(ServletConfig config) throws ServletException &#123;
        super.init(config);
        System.out.println(&quot;重写了init初始化方法,做了一些工作&quot;);
    &#125;

    /**
     * doGet（）在get请求的时候调用
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        int i =  12 / 0;

        System.out.println(&quot;HelloServlet2 的doGet方法&quot;);
        // 也可以使用.
        ServletConfig servletConfig = getServletConfig();
        System.out.println(servletConfig);

        //        2、获取初始化参数init-param(只能获取自己的servlet的初始化参数)
        System.out.println(&quot;初始化参数username的值是;&quot; + servletConfig.getInitParameter(&quot;username&quot;));
        System.out.println(&quot;初始化参数url的值是;&quot; + servletConfig.getInitParameter(&quot;url&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="1-5-ServletContext类"><a href="#1-5-ServletContext类" class="headerlink" title="1.5 ServletContext类"></a>1.5 ServletContext类</h3><ul>
<li>ServletContext 是一个接口，它表示 Servlet 上下文对象 </li>
<li>一个 web 工程，只有一个 ServletContext 对象实例。</li>
<li>ServletContext 对象是一个域对象。域对象：是可以像 Map 一样存取数据的对象，叫域对象。 这里的域指的是存取数据的操作范围，整个 web 工程</li>
<li>ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存数据</th>
<th>取数据</th>
<th>删除数据</th>
</tr>
</thead>
<tbody><tr>
<td>Map</td>
<td>put()</td>
<td>get()</td>
<td>remove()</td>
</tr>
<tr>
<td>域对象</td>
<td>setAttribute()</td>
<td>getAttribute()</td>
<td>removeAttribute();</td>
</tr>
</tbody></table>
<p><code>ServletContext</code>类的作用</p>
<ul>
<li>获取 web.xml 中配置的上下文参数 context-param </li>
<li>获取当前的工程路径，格式:/工程路径 </li>
<li>获取工程部署后在服务器硬盘上的绝对路径 </li>
<li>像 Map 一样存取数据</li>
</ul>
<p><code>ServletContext</code>类的使用：<strong>实现servlet接口可以通过ServletConfig来获取ServletContext</strong>，继承<code>HttpServlet</code>可以直接<code>getServletContext()</code>获取<code>ServletContext</code>对象</p>
<p>配置上下文参数context-param，在整个web工程配置，不在servlet中配置</p>
<pre><code class="xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;!--context-param是上下文参数(它属于整个web工程)--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;username&lt;/param-name&gt;
        &lt;param-value&gt;context&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;!--context-param是上下文参数(它属于整个web工程)--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;password&lt;/param-name&gt;
        &lt;param-value&gt;root&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.review.servlet.HelloServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>   <code>ServletContext</code> 类的使用</p>
<pre><code class="java">public class ContextServlet extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
//        1、获取web.xml中配置的上下文参数context-param
        ServletContext context = getServletConfig().getServletContext();
        //ServletContext context = getServletContext();
        
        String username = context.getInitParameter(&quot;username&quot;);
        System.out.println(&quot;context-param参数username的值是:&quot; + username);
        System.out.println(&quot;context-param参数password的值是:&quot; + context.getInitParameter(&quot;password&quot;));
//        2、获取当前的工程路径，格式: /工程路径
        System.out.println( &quot;当前工程路径:&quot; + context.getContextPath() );
//        3、获取工程部署后在服务器硬盘上的绝对路径
        /**
         *  / 斜杠被服务器解析地址为:http://ip:port/工程名/  映射到IDEA代码的web目录&lt;br/&gt;
         */
        System.out.println(&quot;工程部署的路径是:&quot; + context.getRealPath(&quot;/&quot;));
        System.out.println(&quot;工程下css目录的绝对路径是:&quot; + context.getRealPath(&quot;/css&quot;));
        System.out.println(&quot;工程下imgs目录1.jpg的绝对路径是:&quot; + context.getRealPath(&quot;/imgs/1.jpg&quot;));
    &#125;
&#125;
</code></pre>
<p>结果</p>
<pre><code>context-param参数username的值是:context
context-param参数password的值是:root
当前工程路径:/Servlet_war_exploded
工程部署的路径是:E:\IDEAProject\JavaReview\out\artifacts\Servlet_war_exploded\
工程下css目录的绝对路径是:E:\IDEAProject\JavaReview\out\artifacts\Servlet_war_exploded\css
工程下imgs目录1.jpg的绝对路径是:E:\IDEAProject\JavaReview\out\artifacts\Servlet_war_exploded\imgs\1.jpg
</code></pre>
<p><code>ServletContext</code>存取数据操作</p>
<pre><code class="java">public class ContextServlet1 extends HttpServlet &#123;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // 获取ServletContext对象
        ServletContext context = getServletContext();
        ServletContext servletContext = getServletConfig().getServletContext();
        System.out.println(context==servletContext);//true

        System.out.println(context);

        System.out.println(&quot;保存之前: Context1 获取 key1的值是:&quot;+ context.getAttribute(&quot;key1&quot;));//null

        context.setAttribute(&quot;key1&quot;, &quot;value1&quot;);

        System.out.println(&quot;Context1 中获取域数据key1的值是:&quot;+ context.getAttribute(&quot;key1&quot;));//value1
    &#125;
&#125;
</code></pre>
<blockquote>
<p><code>ServletContext</code>对象是域对象，只有一个，不论在哪个<code>Servlet</code>中存数据，其他的<code>servlet</code>都可以获取到，而且每个<code>servlet</code>中的<code>ServletContext</code>都是同一个，地址相同</p>
</blockquote>
<h3 id="1-6-Http协议"><a href="#1-6-Http协议" class="headerlink" title="1.6 Http协议"></a>1.6 Http协议</h3><ul>
<li>所谓 HTTP 协议，就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议。HTTP 协议中的数据又叫报文。</li>
</ul>
<h4 id="请求的-HTTP-协议格式"><a href="#请求的-HTTP-协议格式" class="headerlink" title="请求的 HTTP 协议格式"></a>请求的 HTTP 协议格式</h4><ul>
<li><p>客户端给服务器发送数据叫请求。 </p>
</li>
<li><p>服务器给客户端回传数据叫响应。</p>
</li>
<li><p>请求常用的又分为 GET 请求，和 POST 请求</p>
<ul>
<li><p>GET 请求</p>
<ul>
<li><p>请求行 </p>
<ul>
<li>(1) 请求的方式 GET </li>
<li>(2) 请求的资源路径[+?+请求参数]</li>
<li>(3) 请求的协议的版本号 HTTP/1.1 </li>
</ul>
</li>
<li><p>请求头 </p>
<ul>
<li>key:value 组成 </li>
<li>不同的键值对，表示不同的含义。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/19/Servlet/image-20200909110105052.png" alt="image-20200909110105052"></p>
<ul>
<li>POST请求<ul>
<li>请求行 <ul>
<li>(1) 请求的方式 POST </li>
<li>(2) 请求的资源路径</li>
<li>(3) 请求的协议的版本号 HTTP/1.1 </li>
</ul>
</li>
<li>2、请求头 <ul>
<li> key:value 不同的请求头，有不同的含义 </li>
</ul>
</li>
<li>空行 </li>
<li>请求体 ===&gt;&gt;&gt; 就是发送给服务器的数据</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/19/Servlet/image-20200909110322247.png" alt="image-20200909110322247"></p>
</li>
<li><p><strong>常用请求头的说明</strong></p>
<ul>
<li>Accept: 表示客户端可以接收的数据类型 </li>
<li>Accpet-Languege: 表示客户端可以接收的语言类型 </li>
<li>User-Agent: 表示客户端浏览器的信息 </li>
<li>Host： 表示请求时的服务器 ip 和端口号</li>
</ul>
</li>
<li><p><strong>GET和POST请求区别</strong></p>
<ul>
<li><p>GET： </p>
<ul>
<li><p>请求参数在请求行中，在url后。</p>
</li>
<li><p>请求的url长度有限制的</p>
</li>
<li><p>不太安全</p>
</li>
<li><p>包含参数的请求头</p>
<pre><code>GET /Servlet_war_exploded/hello3?action=login&amp;username=root HTTP/1.1
</code></pre>
</li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制的</li>
<li>相对安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>哪些是 GET 请求，哪些是 POST 请求</strong></li>
<li>GET 请求有哪些： <ul>
<li>1、form 标签 method=get </li>
<li>2、a 标签 </li>
<li>3、link 标签引入 css </li>
<li>4、Script 标签引入 js 文件 </li>
<li>5、img 标签引入图片 </li>
<li>6、iframe 引入 html 页面 </li>
<li>7、在浏览器地址栏中输入地址后敲回车</li>
<li>POST 请求有哪些： <ul>
<li>8、form 标签 method=post</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="响应的HTTP协议格式"><a href="#响应的HTTP协议格式" class="headerlink" title="响应的HTTP协议格式"></a>响应的HTTP协议格式</h4><ul>
<li>响应行 <ul>
<li>响应的协议和版本号 </li>
<li>响应状态码 </li>
<li>响应状态描述符</li>
</ul>
</li>
<li>响应头 key:value 不同的响应头，有其不同含义 </li>
<li>空行 </li>
<li>响应体 —-&gt;&gt;&gt; 就是回传给客户端的数据</li>
</ul>
<p><img src="/2020/09/19/Servlet/image-20200909111143438.png" alt="image-20200909111143438"></p>
<ul>
<li>响应码说明<ul>
<li>200 表示请求成功 </li>
<li>302 表示请求重定向 </li>
<li>404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） </li>
<li>500 表示服务器已经收到请求，但是服务器内部错误（代码错误）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-01(生产者和消费者模块构建)</title>
    <url>/2020/12/15/SpringCloud-01/</url>
    <content><![CDATA[<h1 id="SpringCloud-01"><a href="#SpringCloud-01" class="headerlink" title="SpringCloud-01"></a>SpringCloud-01</h1><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p><img src="/2020/12/15/SpringCloud-01/image-20210316133518559.png" alt="image-20210316133518559"></p>
<h2 id="1、IDEA新建project空间"><a href="#1、IDEA新建project空间" class="headerlink" title="1、IDEA新建project空间"></a>1、IDEA新建project空间</h2><p>步骤：</p>
<ul>
<li>第一步：New Project</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151050258.png" alt="image-20210314151050258"></p>
<ul>
<li>第二步：聚合总父工程名字</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151215003.png" alt="image-20210314151215003"></p>
<ul>
<li>选择maven版本</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151350803.png" alt="image-20210314151350803"></p>
<ul>
<li>工程名</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151438527.png" alt="image-20210314151438527"></p>
<ul>
<li>设置字符编码</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151727107.png" alt="image-20210314151727107"></p>
<ul>
<li>注解生效激活，表示支持注解</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314151935999.png" alt="image-20210314151935999"></p>
<ul>
<li>选择java编译版本</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314152134126.png" alt="image-20210314152134126"></p>
<ul>
<li>File Type过滤</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314152631628.png" alt="image-20210314152631628"></p>
<h2 id="2、设置父工程POM文件"><a href="#2、设置父工程POM文件" class="headerlink" title="2、设置父工程POM文件"></a>2、设置父工程POM文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
  &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;

  &lt;!--统一管理jar包版本--&gt;
  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;junit.version&gt;4.12&lt;/junit.version&gt;
    &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;
    &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;
    &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;
    &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;
    &lt;spring.boot.version&gt;2.2.2.RELEASE&lt;/spring.boot.version&gt;
    &lt;spring.cloud.version&gt;Hoxton.SR1&lt;/spring.cloud.version&gt;
    &lt;spring.cloud.alibaba.version&gt;2.1.0.RELEASE&lt;/spring.cloud.alibaba.version&gt;
    &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;
  &lt;/properties&gt;

  &lt;!--子模块继承后,提供作用:锁定版本+子module不用groupId和version--&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;!--springboot 2.2.2--&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;!--Spring cloud Hoxton.SR1--&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;!--Spring cloud alibaba 2.1.0.RELEASE--&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
        &lt;configuration&gt;
          &lt;fork&gt;true&lt;/fork&gt;
          &lt;addResources&gt;true&lt;/addResources&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;!--第三方maven私服--&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;nexus-aliyun&lt;/id&gt;
      &lt;name&gt;Nexus aliyun&lt;/name&gt;
      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
      &lt;releases&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
      &lt;/releases&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>删除src文件</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314154202848.png" alt="image-20210314154202848" style="zoom:80%;"><img src="/2020/12/15/SpringCloud-01/image-20210314154229101.png" alt="image-20210314154229101" style="zoom:80%;"></p>
<h2 id="3、maven中一些知识点"><a href="#3、maven中一些知识点" class="headerlink" title="3、maven中一些知识点"></a>3、maven中一些知识点</h2><h3 id="3-1-DependencyManagement和Dependencies区别"><a href="#3-1-DependencyManagement和Dependencies区别" class="headerlink" title="3.1 DependencyManagement和Dependencies区别"></a>3.1 <code>DependencyManagement</code>和<code>Dependencies</code>区别</h3><p>maven使用DependencyManagement元素来提供了一种管理依赖版本号的方式</p>
<p><strong>通常会在一个组织或项目的最顶层的父POM中看到DependencyManagement元素</strong></p>
<p>使用pom.xml中的DependencyManagement元素能让所有在子项目中引用一个依赖而不用显示的列出版本号。maven会沿着父子层次向上走，直到找到一个拥有DependencyManagement元素的项目，然后他就会使用这个DependencyManagement元素中指定的版本号</p>
<p>例如：</p>
<pre><code class="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.6&lt;/version&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p>然后再子项目中就可以添加mysql-connector时可以不指定版本号</p>
<pre><code class="xml">&lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>这样的好处是：如果多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样想升级或切换到另一个版本时,只需在顶层父容器里更新,而不需要一个一个子项目的修改;另外如果某个子项目需要另外的一个版本,只需声明version版本</p>
<p><strong>DependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖</strong></p>
<p>如果子项目中指定了版本号，那么会使用子项目中指定的jar版本</p>
<h3 id="3-2-maven中跳过单元测试"><a href="#3-2-maven中跳过单元测试" class="headerlink" title="3.2 maven中跳过单元测试"></a>3.2 maven中跳过单元测试</h3><p>点击之后test变不可用</p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314161610170.png" alt="image-20210314161610170"></p>
<ul>
<li><strong>父工程创建完成执行mvn:insall将父工程发布到仓库方便子工程继承</strong></li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314163503331.png" alt="image-20210314163503331"></p>
<h2 id="4、支付模块构建"><a href="#4、支付模块构建" class="headerlink" title="4、支付模块构建"></a>4、支付模块构建</h2><h3 id="4-1-建module"><a href="#4-1-建module" class="headerlink" title="4.1 建module"></a>4.1 建module</h3><p><strong>直接maven，不用骨架，创建完成之后查看主POM文件的变化</strong></p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210314165254465.png" alt="image-20210314165254465"></p>
<h3 id="4-2-改POM文件"><a href="#4-2-改POM文件" class="headerlink" title="4.2 改POM文件"></a>4.2 改POM文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10&lt;/version&gt;
            &lt;!--如果没写版本,从父层面找,找到了就直接用,全局统一--&gt;
        &lt;/dependency&gt;
        &lt;!--mysql-connector-java--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--jdbc--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="4-3-写YML"><a href="#4-3-写YML" class="headerlink" title="4.3 写YML"></a>4.3 写YML</h3><pre><code class="yml">server:
  port: 8001
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/db2019?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<h3 id="4-4-主启动类"><a href="#4-4-主启动类" class="headerlink" title="4.4 主启动类"></a>4.4 主启动类</h3><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class);
    &#125;
&#125;
</code></pre>
<h3 id="4-5-业务类"><a href="#4-5-业务类" class="headerlink" title="4.5 业务类"></a>4.5 业务类</h3><h4 id="4-5-1建表sql"><a href="#4-5-1建表sql" class="headerlink" title="4.5.1建表sql"></a>4.5.1建表sql</h4><pre><code class="sql">CREATE TABLE `payment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `serial` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;支付流水号&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;支付表&#39; ROW_FORMAT = Dynamic;
</code></pre>
<h4 id="4-5-2-entities"><a href="#4-5-2-entities" class="headerlink" title="4.5.2 entities"></a>4.5.2 entities</h4><ol>
<li><p>主实体Payment</p>
<pre><code class="java">package com.practice.springcloud.dao;

import com.practice.springcloud.entities.Payment;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface PaymentDao &#123;
    public int create(Payment payment);

    public Payment getPaymentById(@Param(&quot;id&quot;) Long id);
&#125;
</code></pre>
</li>
<li><p>Json封装体CommonResult</p>
<pre><code class="java">package com.practice.springcloud.entities;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResult&lt;T&gt;&#123;
    //404 not_fond
    private Integer code;
    private String message;
    private T data;

    public CommonResult(Integer code,String message)&#123;
        this(code,message,null);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-5-3-dao"><a href="#4-5-3-dao" class="headerlink" title="4.5.3 dao"></a>4.5.3 dao</h4><ol>
<li><p>接口PaymentDao</p>
<pre><code class="java">package com.practice.springcloud.dao;

import com.practice.springcloud.entities.Payment;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface PaymentDao &#123;
    ////增删改查
    public int create(Payment payment);//写操作

    public Payment getPaymentById(@Param(&quot;id&quot;) Long id);//读操作
&#125;
</code></pre>
</li>
<li><p>mybatis的映射文件PaymentMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.practice.springcloud.dao.PaymentDao&quot;&gt;
    &lt;insert id=&quot;create&quot; parameterType=&quot;Payment&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into payment(serial) values(#&#123;serial&#125;);
    &lt;/insert&gt;
    
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.practice.springcloud.entities.Payment&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;
        &lt;id column=&quot;serial&quot; property=&quot;serial&quot; jdbcType=&quot;VARCHAR&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getPaymentById&quot; parameterType=&quot;Long&quot; resultMap=&quot;BaseResultMap&quot;&gt;
        select * from payment where id=#&#123;id&#125;;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h4 id="4-5-4-service"><a href="#4-5-4-service" class="headerlink" title="4.5.4 service"></a>4.5.4 service</h4><ol>
<li><p>接口PaymentService</p>
<pre><code class="java">package com.practice.springcloud.service;

import com.practice.springcloud.entities.Payment;
import org.apache.ibatis.annotations.Param;


public interface PaymentService &#123;
    ////增删改查
    public int create(Payment payment);//写操作

    public Payment getPaymentById(@Param(&quot;id&quot;) Long id);//读操作
&#125;
</code></pre>
</li>
<li><p>实现类</p>
<pre><code class="java">package com.practice.springcloud.service.impl;

import com.practice.springcloud.dao.PaymentDao;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.service.PaymentService;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service
public class PaymentServiceImpl implements PaymentService &#123;

    @Resource
    private PaymentDao paymentDao;

    public int create(Payment payment)&#123;
        return paymentDao.create(payment);
    &#125;

    public Payment getPaymentById(@Param(&quot;id&quot;) Long id)&#123;
        return paymentDao.getPaymentById(id);
    &#125;
    
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-5-5controller"><a href="#4-5-5controller" class="headerlink" title="4.5.5controller"></a>4.5.5controller</h4><pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;

@RestController
@Slf4j
public class PaymentController &#123;

    @Resource
    private PaymentService paymentService;

    @PostMapping(value = &quot;/payment/create&quot;)
    public CommonResult create(Payment payment)&#123;

        int result=paymentService.create(payment);
        log.info(&quot;***插入结果：&quot;+result);

        if (result&gt;0)&#123;
            return new CommonResult(200,&quot;插入数据库成功&quot;,result);
        &#125;else &#123;
            return new CommonResult(444,&quot;插入数据库失败&quot;,null);
        &#125;
    &#125;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;

        Payment payment=paymentService.getPaymentById(id);
        log.info(&quot;***插入结果：&quot;+payment);

        if (payment != null)&#123;
            return new CommonResult(200,&quot;查询成功&quot;,payment);
        &#125;else &#123;
            return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><ul>
<li><p>使用浏览器测试<a href="http://localhost:8001/payment/get/31">http://localhost:8001/payment/get/31</a></p>
</li>
<li><p>使用postman模拟post请求</p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315100026410.png" alt="image-20210315100026410"></p>
</li>
</ul>
<h3 id="4-7-支付模块目录结构"><a href="#4-7-支付模块目录结构" class="headerlink" title="4.7 支付模块目录结构"></a>4.7 支付模块目录结构</h3><p><img src="/2020/12/15/SpringCloud-01/image-20210315102230250.png" alt="image-20210315102230250"></p>
<h2 id="5、微服务消费者模块构建"><a href="#5、微服务消费者模块构建" class="headerlink" title="5、微服务消费者模块构建"></a>5、微服务消费者模块构建</h2><h3 id="5-1-建module"><a href="#5-1-建module" class="headerlink" title="5.1 建module"></a>5.1 建module</h3><p><img src="/2020/12/15/SpringCloud-01/image-20210315102756261.png" alt="image-20210315102756261"></p>
<h3 id="5-2-改POM"><a href="#5-2-改POM" class="headerlink" title="5.2 改POM"></a>5.2 改POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt;
    &lt;description&gt;客户端消费者模块&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="5-3-写yml"><a href="#5-3-写yml" class="headerlink" title="5.3 写yml"></a>5.3 写yml</h3><pre><code class="yml">server:
  port: 80
</code></pre>
<h3 id="5-4-主启动"><a href="#5-4-主启动" class="headerlink" title="5.4 主启动"></a>5.4 主启动</h3><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="5-5-业务类"><a href="#5-5-业务类" class="headerlink" title="5.5 业务类"></a>5.5 业务类</h3><h4 id="5-5-1-entities"><a href="#5-5-1-entities" class="headerlink" title="5.5.1 entities"></a>5.5.1 entities</h4><ol>
<li><p>主实体Payment</p>
<pre><code class="java">package com.practice.springcloud.entities;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Payment implements Serializable &#123;
    private long id;
    private String serial;

&#125;
</code></pre>
</li>
<li><p>Json封装体CommonResult</p>
<pre><code class="java">package com.practice.springcloud.entities;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResult&lt;T&gt;&#123;
    //404 not_fond
    private Integer code;
    private String message;
    private T data;

    public CommonResult(Integer code,String message)&#123;
        this(code,message,null);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h4 id="5-5-2-RestTemplate作用"><a href="#5-5-2-RestTemplate作用" class="headerlink" title="5.5.2 RestTemplate作用"></a>5.5.2 RestTemplate作用</h4><p>此时，消费者模块80需要与支付模块8001连接，此时就需要RestTemplate，它能完成80到8001的远程调用</p>
<ul>
<li><p>RestTemplate提供了多种便捷访问远程Http服务的方法，是一种便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集</p>
</li>
<li><p>使用RestTemplate访问restful接口非常简单粗暴无脑，(url，requestMap，ResponseBean.class)这三个参数分别代表REST请求地址，请求参数，Http响应转换被转换成的对象类型</p>
</li>
</ul>
<h4 id="5-5-3-config配置类"><a href="#5-5-3-config配置类" class="headerlink" title="5.5.3 config配置类"></a>5.5.3 config配置类</h4><pre><code class="java">package com.practice.springcloud.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;

    @Bean
    public RestTemplate getRestTemplate()&#123;
        return new RestTemplate();
    &#125;
&#125;
//applicationContext.xml &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
</code></pre>
<h4 id="5-5-4-controller"><a href="#5-5-4-controller" class="headerlink" title="5.5.4 controller"></a>5.5.4 controller</h4><pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderController &#123;

    public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;
    @Resource
    private RestTemplate restTemplate;

    @GetMapping(&quot;/consumer/payment/create&quot;)
    public CommonResult&lt;Payment&gt; create(Payment payment)&#123;
        return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class);
    &#125;

    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123;
        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class);
    &#125;
&#125;
</code></pre>
<h3 id="5-6-测试"><a href="#5-6-测试" class="headerlink" title="5.6 测试"></a>5.6 测试</h3><p>启动支付模块，再启动消费者模块，消费者模块端口是80，默认不用写端口号</p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315123907831.png" alt="image-20210315123907831"></p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315123921190.png" alt="image-20210315123921190"></p>
<ul>
<li>插入数据记得加@RequestBody注解，否则页面显示成功但数据库无值</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315124738879.png" alt="image-20210315124738879"></p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315125013741.png" alt="image-20210315125013741"></p>
<h3 id="5-7-目录结构"><a href="#5-7-目录结构" class="headerlink" title="5.7 目录结构"></a>5.7 目录结构</h3><p><img src="/2020/12/15/SpringCloud-01/image-20210315125727614.png" alt="image-20210315125727614"></p>
<h2 id="6、工程重构"><a href="#6、工程重构" class="headerlink" title="6、工程重构"></a>6、工程重构</h2><p><img src="/2020/12/15/SpringCloud-01/image-20210315130020383.png" alt="image-20210315130020383"></p>
<p>可以看出，这两个模块中entities是一样的，所以需要重构</p>
<p><strong>新建一个工程<code>cloud-api-commons</code>将整个微服务工程中的共用代码放入此工程下</strong></p>
<h3 id="6-1-建module"><a href="#6-1-建module" class="headerlink" title="6.1 建module"></a>6.1 建module</h3><p><img src="/2020/12/15/SpringCloud-01/image-20210315130534844.png" alt="image-20210315130534844"></p>
<h3 id="6-2-改POM"><a href="#6-2-改POM" class="headerlink" title="6.2 改POM"></a>6.2 改POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.1.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="6-3-entities"><a href="#6-3-entities" class="headerlink" title="6.3 entities"></a>6.3 entities</h3><p>将微服务工程通用的实体包粘贴过去</p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315131605235.png" alt="image-20210315131605235"></p>
<h3 id="6-4-maven命令clean-install"><a href="#6-4-maven命令clean-install" class="headerlink" title="6.4 maven命令clean install"></a>6.4 maven命令clean install</h3><p>maven打包上传到共用的本地库中，供其他模块使用</p>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315132049794.png" alt="image-20210315132049794"></p>
<ul>
<li>clean，测试本机maven环境配置是否正确</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315131900679.png" alt="image-20210315131900679"></p>
<ul>
<li>install，打包上传</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315132022601.png" alt="image-20210315132022601"></p>
<h3 id="6-5-改造支付和消费者模块"><a href="#6-5-改造支付和消费者模块" class="headerlink" title="6.5 改造支付和消费者模块"></a>6.5 改造支付和消费者模块</h3><ul>
<li>删除两个模块的entities模块，在POM文件中添加依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<ul>
<li>此时工程目录</li>
</ul>
<p><img src="/2020/12/15/SpringCloud-01/image-20210315133149092.png" alt="image-20210315133149092"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-02(Eureka服务注册中心)</title>
    <url>/2021/01/15/SpringCloud-02/</url>
    <content><![CDATA[<h1 id="SpringCloud-02"><a href="#SpringCloud-02" class="headerlink" title="SpringCloud-02"></a>SpringCloud-02</h1><h2 id="1、Eureka服务注册中心"><a href="#1、Eureka服务注册中心" class="headerlink" title="1、Eureka服务注册中心"></a>1、Eureka服务注册中心</h2><p>什么是服务治理</p>
<ul>
<li>Spring Cloud封装了Netflix公司开发的Eureka模块来实现服务治理</li>
<li>在传统的rpc远程调用框架中，管理每个服务于服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用，负载均衡，容错等，实现服务发现与注册</li>
</ul>
<p>什么是服务注册</p>
<ul>
<li>Eureka采用了CS的设计框架，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行</li>
<li>在服务注册与发现中，有一个注册中心，当服务器启动的时候，会把当前自己服务器的信息比如 服务地址通讯地址等以别名方式注册到注册中心，另一方(消费者|服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用，RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)，在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315140645329.png" alt="image-20210315140645329"></p>
<p>Eureka的两个组件</p>
<ul>
<li>Eureka包含两个组件：Eureka Server和Eureka Client</li>
<li>Eureka Server提供服务注册服务<ul>
<li>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到</li>
</ul>
</li>
<li>Eureka Client通过注册中心进行访问<ul>
<li>是一个java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的，使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)</li>
</ul>
</li>
</ul>
<h2 id="2、EurekaServer模块"><a href="#2、EurekaServer模块" class="headerlink" title="2、EurekaServer模块"></a>2、EurekaServer模块</h2><h3 id="2-1-建Module"><a href="#2-1-建Module" class="headerlink" title="2.1 建Module"></a>2.1 建Module</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210315143224955.png" alt="image-20210315143224955"></p>
<h3 id="2-2-改POM"><a href="#2-2-改POM" class="headerlink" title="2.2 改POM"></a>2.2 改POM</h3><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--eureka-server--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引用自己定义的api通用包，可以使用Payment支付entity--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--一般为通用配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="2-3-建yml"><a href="#2-3-建yml" class="headerlink" title="2.3 建yml"></a>2.3 建yml</h3><pre><code class="yml">server:
  port: 7001

eureka:
  instance:
    # eureka服务端的实例名称
    # 单机 hostname: localhost
    hostname: localhost
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<h3 id="2-4-主启动"><a href="#2-4-主启动" class="headerlink" title="2.4 主启动"></a>2.4 主启动</h3><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class EurekaMain7001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaMain7001.class);
    &#125;
&#125;
</code></pre>
<h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210315151137866.png" alt="image-20210315151137866"></p>
<h2 id="3、支付模块注册进Eureka"><a href="#3、支付模块注册进Eureka" class="headerlink" title="3、支付模块注册进Eureka"></a>3、支付模块注册进Eureka</h2><p><strong>注意：</strong>支付模块8001又称为服务提供者</p>
<h3 id="3-1-改POM"><a href="#3-1-改POM" class="headerlink" title="3.1 改POM"></a>3.1 改POM</h3><pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="3-2-改yml"><a href="#3-2-改yml" class="headerlink" title="3.2 改yml"></a>3.2 改yml</h3><pre><code class="yml">server:
  port: 8001
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud2020?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:7001/eureka

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<h3 id="3-3-主启动"><a href="#3-3-主启动" class="headerlink" title="3.3 主启动"></a>3.3 主启动</h3><p>添加<code>@EnableEurekaClient</code>注解</p>
<pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h3><ul>
<li>先启动EurekaServer，支付模块才能注册进去</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315153745205.png" alt="image-20210315153745205"></p>
<ul>
<li>微服务注册名称配置说明</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315153929060.png" alt="image-20210315153929060"></p>
<h2 id="4、订单服务模块注册进Eureka"><a href="#4、订单服务模块注册进Eureka" class="headerlink" title="4、订单服务模块注册进Eureka"></a>4、订单服务模块注册进Eureka</h2><p><strong>注意</strong>：订单服务80又称为服务消费者模块</p>
<h3 id="4-1-改POM"><a href="#4-1-改POM" class="headerlink" title="4.1 改POM"></a>4.1 改POM</h3><ul>
<li>80注册进Eureka，也相当与客户端</li>
</ul>
<pre><code class="java">&lt;!--Eureka-client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="4-2-改yml"><a href="#4-2-改yml" class="headerlink" title="4.2 改yml"></a>4.2 改yml</h3><pre><code class="yml">server:
  port: 80
spring:
  application:
    name: cloud-order-service

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
</code></pre>
<h3 id="4-3-主启动"><a href="#4-3-主启动" class="headerlink" title="4.3 主启动"></a>4.3 主启动</h3><ul>
<li>需要添加<code>@EnableEurekaClient</code>注解</li>
</ul>
<pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class OrderMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderMain80.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210315154911589.png" alt="image-20210315154911589"></p>
<h2 id="5、Eureka集群构建"><a href="#5、Eureka集群构建" class="headerlink" title="5、Eureka集群构建"></a>5、Eureka集群构建</h2><h3 id="5-1-Eureka集群原理"><a href="#5-1-Eureka集群原理" class="headerlink" title="5.1 Eureka集群原理"></a>5.1 Eureka集群原理</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210315155840479.png" alt="image-20210315155840479"></p>
<p>微服务RPC远程服务调用最核心的是什么</p>
<ul>
<li>高可用，试想你的注册中心只有一个only one，它出了故障那就全部崩盘，会导致整个服务环境不可用，所以解决办法就是：搭建Eureka注册中心集群，实现负载均衡+故障容错</li>
</ul>
<blockquote>
<p><strong>当有多个EurekaServer该如何构建集群？</strong></p>
<p>Eureka集群构建要点：互相注册，相互守望</p>
<p>例如：有三个Eureka服务构建集群，Eureka1中要注册Eureka2和Eureka3，Eureka2中要注册Eureka1和Eureka3，Eureka3中要注册Eureka1和Eureka2</p>
</blockquote>
<h3 id="5-2-建module"><a href="#5-2-建module" class="headerlink" title="5.2 建module"></a>5.2 建module</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210315163238031.png" alt="image-20210315163238031"></p>
<h3 id="5-3-改POM"><a href="#5-3-改POM" class="headerlink" title="5.3 改POM"></a>5.3 改POM</h3><ul>
<li>和EurekaServer7001的POM一样</li>
</ul>
<h3 id="5-4-修改配置映射"><a href="#5-4-修改配置映射" class="headerlink" title="5.4 修改配置映射"></a>5.4 修改配置映射</h3><ul>
<li>找到C:\Windows\System32\drivers\etc路径下的hosts文件</li>
<li>修改映射配置添加进hosts文件<ul>
<li>127.0.0.1 eureka7001.com</li>
<li>127.0.0.1 eureka7002.com</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315163605238.png" alt="image-20210315163605238"></p>
<h3 id="5-5-写yml"><a href="#5-5-写yml" class="headerlink" title="5.5 写yml"></a>5.5 写yml</h3><blockquote>
<p>此例中就是7001中注册7002,7002中注册7001</p>
</blockquote>
<ul>
<li>修改7001的yml</li>
</ul>
<pre><code class="yml">server:
  port: 7001
eureka:
  instance:
    # eureka服务端的实例名称
    # 单机 hostname: localhost
    hostname: eureka7001.com
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      # 单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
      # 相互注册
      defaultZone: http://eureka7002.com:7002/eureka/
</code></pre>
<ul>
<li>修改7002的yml</li>
</ul>
<pre><code class="yml">server:
  port: 7002
eureka:
  instance:
    # eureka服务端的实例名称
    # 单机 hostname: localhost
    hostname: eureka7002.com
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      # 单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
      # 相互注册
      defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>
<h3 id="5-6-主启动"><a href="#5-6-主启动" class="headerlink" title="5.6 主启动"></a>5.6 主启动</h3><ul>
<li>与EurekaServer7001一致</li>
</ul>
<pre><code class="java">@SpringBootApplication
@EnableEurekaServer
public class EurekaMain7002 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaMain7002.class);
    &#125;
&#125;
</code></pre>
<h3 id="5-7-测试"><a href="#5-7-测试" class="headerlink" title="5.7 测试"></a>5.7 测试</h3><ul>
<li>启动7001和7002</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315165037078.png" alt="image-20210315165037078"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315165053078.png" alt="image-20210315165053078"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315165209819.png" alt="image-20210315165209819"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210315165256071.png" alt="image-20210315165256071"></p>
<h2 id="6、将两个模块-80和8001-都配置到Eureka集群中"><a href="#6、将两个模块-80和8001-都配置到Eureka集群中" class="headerlink" title="6、将两个模块(80和8001)都配置到Eureka集群中"></a>6、将两个模块(80和8001)都配置到Eureka集群中</h2><h3 id="6-1-支付模块8001发布到Eureka集群中"><a href="#6-1-支付模块8001发布到Eureka集群中" class="headerlink" title="6.1 支付模块8001发布到Eureka集群中"></a>6.1 支付模块8001发布到Eureka集群中</h3><ul>
<li>只需要修改yml文件，将<code>defaultZone: http://localhost:7001/eureka</code>改为<code>dafaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</code></li>
</ul>
<pre><code class="yml">server:
  port: 8001
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud2020?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      dafaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
#      defaultZone: http://localhost:7001/eureka 单机版


mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<h3 id="6-2-订单服务80发布到Eureka集群中"><a href="#6-2-订单服务80发布到Eureka集群中" class="headerlink" title="6.2 订单服务80发布到Eureka集群中"></a>6.2 订单服务80发布到Eureka集群中</h3><ul>
<li>一样与8001相同，修改yml文件</li>
</ul>
<pre><code class="yml">server:
  port: 80
spring:
  application:
    name: cloud-order-service

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true,不想注册进Eureka
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
#      defaultZone: http://localhost:7001/eureka 单机版
      dafaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
</code></pre>
<h3 id="6-3-测试"><a href="#6-3-测试" class="headerlink" title="6.3 测试"></a>6.3 测试</h3><p>第一步：先启动Eureka集群7001和7002</p>
<p>第二步：再启动服务提供者：8001</p>
<p>第三步：再启动消费者：80</p>
<p>最后：<code>http://localhost/consumer/payment/get/31</code></p>
<p><strong>注意</strong>：</p>
<blockquote>
<p> 此时发现，两个模块的yml文件中，将<code>defaultZone: http://localhost:7001/eureka</code>改为<code>dafaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</code>后，测试没问题，两个服务都注册进去了</p>
</blockquote>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316091956096.png" alt="image-20210316091956096"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316093029582.png" alt="image-20210316093029582"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316093056415.png" alt="image-20210316093056415"></p>
<p><strong>但是</strong>：</p>
<blockquote>
<p>保持两个模块的yml文件单机版的注册方式：<code>defaultZone: http://localhost:7001/eureka</code>，发现虽然两个模块都注册到7001Eureka，但是7002和7001中都有注册这两个模块</p>
</blockquote>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316091833555.png" alt="image-20210316091833555"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316091649028.png" alt="image-20210316091649028"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316091720730.png" alt="image-20210316091720730"></p>
<h2 id="7、服务提供者集群配置"><a href="#7、服务提供者集群配置" class="headerlink" title="7、服务提供者集群配置"></a>7、服务提供者集群配置</h2><p><img src="/2021/01/15/SpringCloud-02/image-20210316093434236.png" alt="image-20210316093434236"></p>
<ul>
<li>既然是集群，那就要有多个服务提供者，所以建8002</li>
</ul>
<h3 id="7-1-建Module"><a href="#7-1-建Module" class="headerlink" title="7.1 建Module"></a>7.1 建Module</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210316094505120.png" alt="image-20210316094505120"></p>
<h3 id="7-2-改POM"><a href="#7-2-改POM" class="headerlink" title="7.2 改POM"></a>7.2 改POM</h3><ul>
<li>POM与8001一致</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-payment8002&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--Eureka-client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;!--如果没写版本,从父层面找,找到了就直接用,全局统一--&gt;
            &lt;version&gt;$&#123;druid.spring.boot.starter.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql-connector-java--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--jdbc--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;


    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="7-3-写yml"><a href="#7-3-写yml" class="headerlink" title="7.3 写yml"></a>7.3 写yml</h3><ul>
<li>yml与8001保持一致，记住要修改端口号</li>
</ul>
<pre><code class="yml">server:
  port: 8002
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud2020?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
#      defaultZone: http://localhost:7001/eureka #单机版


mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<h3 id="7-4-主启动类"><a href="#7-4-主启动类" class="headerlink" title="7.4 主启动类"></a>7.4 主启动类</h3><ul>
<li>与8001一致</li>
</ul>
<h3 id="7-5-业务类"><a href="#7-5-业务类" class="headerlink" title="7.5 业务类"></a>7.5 业务类</h3><ul>
<li>与8001一致</li>
</ul>
<h3 id="7-6-修改8001-8002的Controller"><a href="#7-6-修改8001-8002的Controller" class="headerlink" title="7.6 修改8001/8002的Controller"></a>7.6 修改8001/8002的Controller</h3><ul>
<li>提供一个端口号</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316100101192.png" alt="image-20210316100101192"></p>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;

@RestController
@Slf4j
public class PaymentController &#123;

    @Resource
    private PaymentService paymentService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;//得到端口号


    @PostMapping(value = &quot;/payment/create&quot;)
    public CommonResult create(@RequestBody Payment payment)&#123;

        int result=paymentService.create(payment);
        log.info(&quot;***插入结果：&quot;+result);

        if (result&gt;0)&#123;
            return new CommonResult(200,&quot;插入数据库成功,serverPort:&quot;+serverPort,result);
        &#125;else &#123;
            return new CommonResult(444,&quot;插入数据库失败&quot;,null);
        &#125;
    &#125;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;

        Payment payment=paymentService.getPaymentById(id);
        log.info(&quot;***插入结果：&quot;+payment);

        if (payment != null)&#123;
            return new CommonResult(200,&quot;查询成功,serverPort:&quot;+serverPort,payment);
        &#125;else &#123;
            return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>8001和8002保持一致</li>
</ul>
<h3 id="7-7-负载均衡"><a href="#7-7-负载均衡" class="headerlink" title="7.7 负载均衡"></a>7.7 负载均衡</h3><p>三个服务全部注册进去了</p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101231603.png" alt="image-20210316101231603"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101309182.png" alt="image-20210316101309182"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101329458.png" alt="image-20210316101329458"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101344242.png" alt="image-20210316101344242"></p>
<ul>
<li>当用80服务消费者来访问，发现只能访问到8001端口</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101440183.png" alt="image-20210316101440183"></p>
<ul>
<li>因为代码中已经写死了</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316101657964.png" alt="image-20210316101657964"></p>
<ul>
<li><strong>所以订单访问地址不能写死</strong>，通过微服务名称调用服务</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316102645345.png" alt="image-20210316102645345"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316102733398.png" alt="image-20210316102733398"></p>
<ul>
<li>使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316102805074.png" alt="image-20210316102805074"></p>
<h3 id="7-8-测试"><a href="#7-8-测试" class="headerlink" title="7.8 测试"></a>7.8 测试</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210316102901840.png" alt="image-20210316102901840"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316102913474.png" alt="image-20210316102913474"></p>
<ul>
<li>此时8001/8002端口就可以交替出现</li>
</ul>
<blockquote>
<p>Ribbon和Eureka整合后Consumer可以直接调用服务而不用关心地址和端口号，且该服务还有负载功能</p>
</blockquote>
<h2 id="8、actuator微服务信息完善"><a href="#8、actuator微服务信息完善" class="headerlink" title="8、actuator微服务信息完善"></a>8、actuator微服务信息完善</h2><h3 id="8-1-主机名称-服务名称修改"><a href="#8-1-主机名称-服务名称修改" class="headerlink" title="8.1 主机名称:服务名称修改"></a>8.1 主机名称:服务名称修改</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210316103832584.png" alt="image-20210316103832584"></p>
<ul>
<li>在yml中修改</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316104433401.png" alt="image-20210316104433401"></p>
<pre><code class="yml">server:
  port: 8002
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud2020?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
#      defaultZone: http://localhost:7001/eureka #单机版:
  instance:
    instance-id: payment8002


mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<ul>
<li>效果</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316104703032.png" alt="image-20210316104703032"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316105241692.png" alt="image-20210316105241692"></p>
<h3 id="8-2-访问信息有IP提示"><a href="#8-2-访问信息有IP提示" class="headerlink" title="8.2  访问信息有IP提示"></a>8.2  访问信息有IP提示</h3><p><img src="/2021/01/15/SpringCloud-02/image-20210316105501486.png" alt="image-20210316105501486"></p>
<ul>
<li>在yml中修改</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316105639720.png" alt="image-20210316105639720"></p>
<pre><code class="yml">server:
  port: 8002
spring:
  application:
    name: cloud-payment-service
  datasource:
    # 当前数据源操作类型
    type: com.alibaba.druid.pool.DruidDataSource
    # mysql驱动类
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud2020?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: 123456

eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true，单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
#      defaultZone: http://localhost:7001/eureka #单机版:
  instance:
    instance-id: payment8002
    prefer-ip-address: true


mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.practice.springcloud.entities
</code></pre>
<ul>
<li>效果</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316105856981.png" alt="image-20210316105856981"></p>
<h2 id="9、服务发现Discovery"><a href="#9、服务发现Discovery" class="headerlink" title="9、服务发现Discovery"></a>9、服务发现Discovery</h2><ul>
<li><p>对于注册进Eureka里面的微服务，可以通过服务发现来获得该服务的信息</p>
</li>
<li><p>例如：现在8001,8002注册进Eureka，消费者80想要看看8001的一些相关信息，例如端口号，服务名等，如何才能取到这些信息</p>
</li>
<li><p>8001是服务提供者，要么别人来调用我，要么自己写好关于自己的基本信息</p>
</li>
<li><p>以8001为例，修改Controller</p>
</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.util.List;

@RestController
@Slf4j
public class PaymentController &#123;

    @Resource
    private PaymentService paymentService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;//得到端口号

    @Resource
    private DiscoveryClient discoveryClient;

    @PostMapping(value = &quot;/payment/create&quot;)
    public CommonResult create(@RequestBody Payment payment)&#123;

        int result=paymentService.create(payment);
        log.info(&quot;***插入结果：&quot;+result);

        if (result&gt;0)&#123;
            return new CommonResult(200,&quot;插入数据库成功,serverPort:&quot;+serverPort,result);
        &#125;else &#123;
            return new CommonResult(444,&quot;插入数据库失败&quot;,null);
        &#125;
    &#125;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;

        Payment payment=paymentService.getPaymentById(id);
        log.info(&quot;***插入结果：&quot;+payment);

        if (payment != null)&#123;
            return new CommonResult(200,&quot;查询成功,serverPort:&quot;+serverPort,payment);
        &#125;else &#123;
            return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null);
        &#125;
    &#125;

    @GetMapping(value = &quot;/payment/discovery&quot;)
    public Object discovery()&#123;
        List&lt;String&gt; services = discoveryClient.getServices();
        for (String element : services) &#123;
            log.info(&quot;****element: &quot;+element);
        &#125;

        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
        for (ServiceInstance instance : instances) &#123;
            log.info(instance.getServiceId()+&quot;\t&quot;+instance.getHost()+&quot;\t&quot;+instance.getPort()+&quot;\t&quot;+instance.getUri());
        &#125;

        return this.discoveryClient;
    &#125;
&#125;
</code></pre>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316120705064.png" alt="image-20210316120705064"></p>
<ul>
<li>修改8001的启动类加上<code>@EnableDiscoveryClient</code>注解</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316120855621.png" alt="image-20210316120855621"></p>
<ul>
<li>测试</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316121415535.png" alt="image-20210316121415535"></p>
<ul>
<li>日志消息</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316121445552.png" alt="image-20210316121445552"></p>
<ul>
<li>8002和8001保持一致</li>
</ul>
<h2 id="10、Eureka自我保护机制"><a href="#10、Eureka自我保护机制" class="headerlink" title="10、Eureka自我保护机制"></a>10、Eureka自我保护机制</h2><ul>
<li>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务</li>
<li>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316122408393.png" alt="image-20210316122408393"></p>
<ul>
<li>简单来说：某时刻，一个微服务不可用了，Eureka不会立刻进行清理，依旧会对该服务的信息进行保存</li>
<li>Eureka设计思想是CAP里面的AP分支</li>
</ul>
<h3 id="10-1-为什么会产生Eureka自我保护机制"><a href="#10-1-为什么会产生Eureka自我保护机制" class="headerlink" title="10.1 为什么会产生Eureka自我保护机制"></a>10.1 为什么会产生Eureka自我保护机制</h3><p>为了防止，在EurekaClient可以正常运行，但是与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务提出</p>
<h3 id="10-2-什么是自我保护模式"><a href="#10-2-什么是自我保护模式" class="headerlink" title="10.2 什么是自我保护模式"></a>10.2 什么是自我保护模式</h3><p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。</p>
<p>但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险—–因为微服务本身是健康的，此时不应该注销这个微服务。</p>
<p>Eureka通过“自我保护模式”来解决这个问题—-当EurekaServer节点在短时间内丢失过多客户端(可能发生了网络分区故障)，那么这个节点就会自动进入自我保护模式</p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316124531040.png" alt="image-20210316124531040"></p>
<ul>
<li>在自我保护模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例</li>
<li>它的设计就是宁可保留错误的服务服务注册信息，也不盲目注销任何可能健康的服务实例。</li>
<li>综上，自我保护模式是一种应对网络异常的安全保护措施，它的架构是宁可保留所有微服务也不盲目注销任何健康的微服务。使用自我被保护模式，可以让Eureka集群更加健壮，稳定</li>
</ul>
<h3 id="10-3-禁止自我保护"><a href="#10-3-禁止自我保护" class="headerlink" title="10.3 禁止自我保护"></a>10.3 禁止自我保护</h3><ul>
<li>以注册中心EurekaServer7001为例，出厂默认自我保护机制是开启的<code>eureka.server.enable-self-preservation=true</code></li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316132853179.png" alt="image-20210316132853179"></p>
<ul>
<li>关闭之后的效果</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316130523459.png" alt="image-20210316130523459"></p>
<ul>
<li>生产者客户端EurekaClient端8001</li>
</ul>
<p>默认<code>eureka.instance.lease-renewal-interval-in-seconds=30</code>（表示客户端向7001发送心跳的间隔是30秒）</p>
<p>默认<code>eureka.instance.lease-expiration-duration-in-seconds=90</code>（表示Eureka服务端7001在收到最后一次心跳后等待时间上限是90秒，超时将删除服务）</p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316131327456.png" alt="image-20210316131327456"></p>
<h3 id="10-3-测试"><a href="#10-3-测试" class="headerlink" title="10.3 测试"></a>10.3 测试</h3><ul>
<li>先启动7001，再启动8001</li>
</ul>
<p>为了方便，只启动7001，将7001设为单机版，8001也是</p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316132921552.png" alt="image-20210316132921552"></p>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316132208739.png" alt="image-20210316132208739"></p>
<ul>
<li>7001和8001启动之后，8001注册进7001中</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316132236432.png" alt="image-20210316132236432"></p>
<ul>
<li>这时关闭8001，若开启自我保护模式，8001不会删除，此时关闭自我保护模式，8001被剔除</li>
</ul>
<p><img src="/2021/01/15/SpringCloud-02/image-20210316132646873.png" alt="image-20210316132646873"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-03(Zookeeper/Consul服务注册中心)</title>
    <url>/2021/01/23/SpringCloud-03/</url>
    <content><![CDATA[<h1 id="SpringCloud-03"><a href="#SpringCloud-03" class="headerlink" title="SpringCloud-03"></a>SpringCloud-03</h1><p>Eureka已经停止更新，找一个替代Eureka的服务注册中心</p>
<p><strong>SpringCloud整合Zookeeper替代Eureka</strong></p>
<h2 id="1、Zookeeper服务注册"><a href="#1、Zookeeper服务注册" class="headerlink" title="1、Zookeeper服务注册"></a>1、Zookeeper服务注册</h2><p><img src="/2021/01/23/SpringCloud-03/image-20210316142711515.png" alt="image-20210316142711515"></p>
<p>Zookeeper特点</p>
<ul>
<li>一个领导者(Leader)，多个跟随者(Follower)组成的集群</li>
<li>集群中只要有<strong>半数以上</strong>节点存活，Zookeeper集群就能正常服务，四个节点死亡两个就不能服务</li>
<li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</li>
<li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>实时性，在一定时间范围内，Client能读到最新数据</li>
</ul>
<h3 id="1-1、安装Zookeeper"><a href="#1-1、安装Zookeeper" class="headerlink" title="1.1、安装Zookeeper"></a>1.1、安装Zookeeper</h3><ul>
<li><p>前提Linux中要有JDK</p>
</li>
<li><p>下载Zookeeper安装包，传到Linux</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316151619327.png" alt="image-20210316151619327"></p>
</li>
<li><p>解压</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316151719386.png" alt="image-20210316151719386"></p>
</li>
<li><p>修改配置文件，修改/opt/zookeeper-3.4.11/conf下的zoo_sample.cfg为zoo.cfg</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316152126444.png" alt="image-20210316152126444"></p>
</li>
<li><p>创建一个文件夹zkData</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316152733899.png" alt="image-20210316152733899"></p>
</li>
<li><p>编辑zoo.cfg</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316152329013.png" alt="image-20210316152329013"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316152544257.png" alt="image-20210316152544257"></p>
</li>
<li><p>修改dataDir的路径为<code>/opt/zookeeper-3.4.11/zkData</code></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316152920211.png" alt="image-20210316152920211"></p>
</li>
<li><p>启动Zookeeper，进入到Zookeeper的bin目录</p>
</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316153617351.png" alt="image-20210316153617351"></p>
<ul>
<li><p>在Zookeeper目录启动</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316153847450.png" alt="image-20210316153847450"></p>
</li>
<li><p>查看状态</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316153949992.png" alt="image-20210316153949992"></p>
</li>
<li><p>启动客户端</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316154051977.png" alt="image-20210316154051977"></p>
</li>
<li><p>进入Zookeeper客户端，退出客户端quit</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316154226049.png" alt="image-20210316154226049"></p>
</li>
<li><p>关闭服务</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316154418153.png" alt="image-20210316154418153"></p>
</li>
</ul>
<h3 id="1-2-Zookeeper前期准备"><a href="#1-2-Zookeeper前期准备" class="headerlink" title="1.2 Zookeeper前期准备"></a>1.2 Zookeeper前期准备</h3><ul>
<li><p>确认安装Zookeeper，关闭防火墙</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316155734216.png" alt="image-20210316155734216"></p>
</li>
<li><p>查看Linux的IP</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316155850399.png" alt="image-20210316155850399"></p>
</li>
<li><p>查看本机IP，window10查看ip地址命令是ipconfig</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316160339390.png" alt="image-20210316160339390"></p>
</li>
<li><p>Linux能够ping通</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316160320073.png" alt="image-20210316160320073"></p>
</li>
</ul>
<h3 id="1-3-服务提供者"><a href="#1-3-服务提供者" class="headerlink" title="1.3 服务提供者"></a>1.3 服务提供者</h3><h4 id="1-3-1-新建Module"><a href="#1-3-1-新建Module" class="headerlink" title="1.3.1 新建Module"></a>1.3.1 新建Module</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210316160706579.png" alt="image-20210316160706579"></p>
<h4 id="1-3-2-改POM"><a href="#1-3-2-改POM" class="headerlink" title="1.3.2 改POM"></a>1.3.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringBoot整合Zookeeper客户端--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="1-3-3-改yml"><a href="#1-3-3-改yml" class="headerlink" title="1.3.3 改yml"></a>1.3.3 改yml</h4><pre><code class="yml">server:
  # 8004表示注册到zookeeper服务器的支付服务提供者端口号
  port: 8004
spring:
  application:
    # 服务别名---注册zookeeper到注册中心的名称
    name: cloud-provider-payment
  cloud:
    zookeeper:
      # Linux的Zookeeper默认端口号:2181
      connect-string: 192.168.127.7:2181



</code></pre>
<h4 id="1-3-4-主启动类"><a href="#1-3-4-主启动类" class="headerlink" title="1.3.4 主启动类"></a>1.3.4 主启动类</h4><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient //该注解用于向使用consul或者Zookeeper作为注册中心时注册服务
public class PaymentMain8004 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8004.class);
    &#125;
&#125;
</code></pre>
<h4 id="1-3-5-启动Zookeeper"><a href="#1-3-5-启动Zookeeper" class="headerlink" title="1.3.5 启动Zookeeper"></a>1.3.5 启动Zookeeper</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210316163139705.png" alt="image-20210316163139705"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316163429655.png" alt="image-20210316163429655"></p>
<h4 id="1-3-6-启动8004"><a href="#1-3-6-启动8004" class="headerlink" title="1.3.6 启动8004"></a>1.3.6 启动8004</h4><ul>
<li>发现报错，jar包版本不一致</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316163837859.png" alt="image-20210316163837859"></p>
<ul>
<li>解决Zookeeper版本jar包冲突问题</li>
<li>在POM中需要先排除自带的jar</li>
<li>然后再引入我们需要的jar包</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringBoot整合Zookeeper客户端--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;!--先排除自带的zookeeper3.5.3--&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;!--添加zookeeper3.4.11版本--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.4.11&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>此时再启动8004，启动成功，8004注册进Zookeeper</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316164733846.png" alt="image-20210316164733846"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316164903722.png" alt="image-20210316164903722"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316165207934.png" alt="image-20210316165207934"></p>
<h3 id="1-4-服务节点是临时节点还是持久节点"><a href="#1-4-服务节点是临时节点还是持久节点" class="headerlink" title="1.4 服务节点是临时节点还是持久节点"></a>1.4 服务节点是临时节点还是持久节点</h3><ul>
<li>刚开始关闭8004时，zookeeper并未撤除，过一段时间后才删除8004服务</li>
<li>所以Zookeeper服务节点是临时的，8004没有回应在一定时间后就会被删除</li>
</ul>
<h3 id="1-5-服务消费者"><a href="#1-5-服务消费者" class="headerlink" title="1.5 服务消费者"></a>1.5 服务消费者</h3><h4 id="1-5-1-建Module"><a href="#1-5-1-建Module" class="headerlink" title="1.5.1 建Module"></a>1.5.1 建Module</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210316170708571.png" alt="image-20210316170708571"></p>
<h4 id="1-5-2-改POM"><a href="#1-5-2-改POM" class="headerlink" title="1.5.2 改POM"></a>1.5.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringBoot整合Zookeeper客户端--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;!--先排除自带的zookeeper3.5.3--&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;!--添加zookeeper3.4.11版本--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.4.11&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;
</code></pre>
<h4 id="1-5-3-改yml"><a href="#1-5-3-改yml" class="headerlink" title="1.5.3 改yml"></a>1.5.3 改yml</h4><pre><code class="yml">server:
  # 80表示注册到zookeeper服务器的支付服务提供者端口号
  port: 80
spring:
  application:
    # 服务别名---注册zookeeper到注册中心的名称
    name: cloud-consumer-order
  cloud:
    zookeeper:
      # 默认localhost:2181
      connect-string: 192.168.127.7:2181
</code></pre>
<h4 id="1-5-4-主启动类"><a href="#1-5-4-主启动类" class="headerlink" title="1.5.4 主启动类"></a>1.5.4 主启动类</h4><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class OrderZKMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderZKMain80.class);
    &#125;
&#125;
</code></pre>
<h4 id="1-5-5-业务类"><a href="#1-5-5-业务类" class="headerlink" title="1.5.5 业务类"></a>1.5.5 业务类</h4><ul>
<li>config类</li>
</ul>
<pre><code class="java">package com.practice.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate()&#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderZKController &#123;

    public static final String INVOKE_URL = &quot;http://cloud-provider-payment&quot;;

    @Resource
    private RestTemplate restTemplate;

    @GetMapping(value = &quot;/consumer/payment/zk&quot;)
    public String paymentInfo()&#123;

        String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/zk&quot;,String.class);

        return result;
    &#125;
&#125;
</code></pre>
<ul>
<li>同时启动8004和zk80，可以看到两个服务都注册进Zookeeper，并且可以互相调用</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316175831683.png" alt="image-20210316175831683"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316175944110.png" alt="image-20210316175944110"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210316180020593.png" alt="image-20210316180020593"></p>
<h2 id="2、-Consul服务注册中心"><a href="#2、-Consul服务注册中心" class="headerlink" title="2、 Consul服务注册中心"></a>2、 Consul服务注册中心</h2><h3 id="2-1-Consul简介"><a href="#2-1-Consul简介" class="headerlink" title="2.1 Consul简介"></a>2.1 Consul简介</h3><h4 id="2-1-1-Consul是什么"><a href="#2-1-1-Consul是什么" class="headerlink" title="2.1.1 Consul是什么"></a>2.1.1 Consul是什么</h4><ul>
<li><p>官网：<a href="https://www.consul.io/intro/index.html">https://www.consul.io/intro/index.html</a></p>
</li>
<li><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发</p>
</li>
<li><p>提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网络，总之Consul提供了一种完整的服务网格解决方案</p>
</li>
<li><p>它具有很多优点，包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议，支持跨数据中心的WAN集群，提供图形界面，跨平台，支持Linux，Mac，Windows</p>
</li>
</ul>
<h4 id="2-1-2-Consul特性"><a href="#2-1-2-Consul特性" class="headerlink" title="2.1.2 Consul特性"></a>2.1.2 Consul特性</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210317084834221.png" alt="image-20210317084834221"></p>
<ul>
<li>服务发现：提供HTTP/DNS两种发现方式</li>
<li>健康检测：支持多种方式，HTTP、TCP、Docker、shell脚本定制化</li>
<li>KV存储：Key、Value的存储方式</li>
<li>多数据中心：Consul支持多数据中心</li>
<li>可视化界面</li>
</ul>
<h4 id="2-1-3-Consul下载"><a href="#2-1-3-Consul下载" class="headerlink" title="2.1.3 Consul下载"></a>2.1.3 Consul下载</h4><ul>
<li><a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></li>
</ul>
<h4 id="2-1-4-Consul使用"><a href="#2-1-4-Consul使用" class="headerlink" title="2.1.4 Consul使用"></a>2.1.4 Consul使用</h4><ul>
<li><a href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></li>
</ul>
<h4 id="2-1-5-安装并运行Consul"><a href="#2-1-5-安装并运行Consul" class="headerlink" title="2.1.5 安装并运行Consul"></a>2.1.5 安装并运行Consul</h4><ul>
<li>官网说明：<a href="https://learn.hashicorp.com/consul/getting-started/install.html">https://learn.hashicorp.com/consul/getting-started/install.html</a></li>
<li>下载完成之后，解压只有一个exe文件</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317090546173.png" alt="image-20210317090546173"></p>
<ul>
<li>命令行窗口打开：<code>consul --version</code>查看版本</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317090631097.png" alt="image-20210317090631097"></p>
<ul>
<li>使用开发者模式启动，输入命令<code>consul agent -dev</code></li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317090843227.png" alt="image-20210317090843227"></p>
<ul>
<li>启动完成之后，通过<a href="http://localhost:8500可以访问Consul首页">http://localhost:8500可以访问Consul首页</a></li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317091021223.png" alt="image-20210317091021223"></p>
<h3 id="2-2-服务提供者"><a href="#2-2-服务提供者" class="headerlink" title="2.2 服务提供者"></a>2.2 服务提供者</h3><h4 id="2-2-1-建Module支付服务"><a href="#2-2-1-建Module支付服务" class="headerlink" title="2.2.1 建Module支付服务"></a>2.2.1 建Module支付服务</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210317092816520.png" alt="image-20210317092816520"></p>
<h4 id="2-2-2-改POM"><a href="#2-2-2-改POM" class="headerlink" title="2.2.2 改POM"></a>2.2.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt;
    &lt;dependencies&gt;
        &lt;!--SpringCloud consul-server--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="2-2-3-建yml"><a href="#2-2-3-建yml" class="headerlink" title="2.2.3 建yml"></a>2.2.3 建yml</h4><pre><code class="yml">server:
  # consul服务端口
  port: 8006
spring:
  application:
    name: consul-provider-payment
  cloud:
    consul:
      # consul注册中心地址
      host: localhost
      port: 8500
      discovery:
        hostname: 127.0.0.1
        service-name: $&#123;spring.application.name&#125;
</code></pre>
<h4 id="2-2-4-主启动"><a href="#2-2-4-主启动" class="headerlink" title="2.2.4 主启动"></a>2.2.4 主启动</h4><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8006 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8006.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="2-2-5-业务类"><a href="#2-2-5-业务类" class="headerlink" title="2.2.5 业务类"></a>2.2.5 业务类</h4><pre><code class="java">package com.practice.springcloud.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.UUID;

@RestController
@Slf4j
public class PaymentController &#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @RequestMapping(value = &quot;/payment/consul&quot;)
    public String paymentZConsul() &#123;
        return &quot;SpringCloud with consul:&quot; + serverPort + &quot;\t&quot; + UUID.randomUUID().toString();
    &#125;
&#125;
</code></pre>
<h4 id="2-2-6-测试"><a href="#2-2-6-测试" class="headerlink" title="2.2.6 测试"></a>2.2.6 测试</h4><ul>
<li>启动8006，查看Consul可视化界面</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317094005678.png" alt="image-20210317094005678"></p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317094328590.png" alt="image-20210317094328590"></p>
<ul>
<li>访问8006服务</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317094135287.png" alt="image-20210317094135287"></p>
<h3 id="2-3-服务消费者"><a href="#2-3-服务消费者" class="headerlink" title="2.3 服务消费者"></a>2.3 服务消费者</h3><h4 id="2-3-1-建Module消费服务"><a href="#2-3-1-建Module消费服务" class="headerlink" title="2.3.1 建Module消费服务"></a>2.3.1 建Module消费服务</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210317095120646.png" alt="image-20210317095120646"></p>
<h4 id="2-3-2-改POM"><a href="#2-3-2-改POM" class="headerlink" title="2.3.2 改POM"></a>2.3.2 改POM</h4><pre><code class="yml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;description&gt;Consul消费模块&lt;/description&gt;

    &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud consul-server--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;
</code></pre>
<h4 id="2-3-3-建yml"><a href="#2-3-3-建yml" class="headerlink" title="2.3.3 建yml"></a>2.3.3 建yml</h4><pre><code class="yml">server:
  port: 80
spring:
  application:
    name: consul-consumer-order
  cloud:
    consul:
      # consul注册中心地址
      host: localhost
      port: 8500
      discovery:
        hostname: 127.0.0.1
        service-name: $&#123;spring.application.name&#125;
</code></pre>
<h4 id="2-3-4-主启动"><a href="#2-3-4-主启动" class="headerlink" title="2.3.4 主启动"></a>2.3.4 主启动</h4><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class OrderConsulMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderConsulMain80.class, args);
    &#125;
&#125;
</code></pre>
<h4 id="2-3-5-业务类"><a href="#2-3-5-业务类" class="headerlink" title="2.3.5 业务类"></a>2.3.5 业务类</h4><ul>
<li>配置类</li>
</ul>
<pre><code class="java">package com.practice.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate()&#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderConsulController &#123;
    public static final String INVOKE_URL = &quot;http://consul-provider-payment&quot;;

    @Resource
    private RestTemplate restTemplate;

    @GetMapping(value = &quot;/consumer/payment/consul&quot;)
    public String paymentInfo()&#123;

        String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/consul&quot;,String.class);

        return result;
    &#125;
&#125;
</code></pre>
<h4 id="2-3-6-测试"><a href="#2-3-6-测试" class="headerlink" title="2.3.6 测试"></a>2.3.6 测试</h4><p><img src="/2021/01/23/SpringCloud-03/image-20210317102335274.png" alt="image-20210317102335274"></p>
<ul>
<li>服务提供者自测</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317102407775.png" alt="image-20210317102407775"></p>
<ul>
<li>服务消费者访问服务提供者</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317102447232.png" alt="image-20210317102447232"></p>
<h2 id="3、三个服务注册中心异同"><a href="#3、三个服务注册中心异同" class="headerlink" title="3、三个服务注册中心异同"></a>3、三个服务注册中心异同</h2><table>
<thead>
<tr>
<th>组件名</th>
<th>语言</th>
<th>CAP</th>
<th>服务健康检查</th>
<th>对外暴露接口</th>
<th>SpringCloud集成</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP</td>
<td>可配支持</td>
<td>HTTP</td>
<td>已集成</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>支持</td>
<td>HTTP/DNS</td>
<td>已集成</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>支持</td>
<td>客户端</td>
<td>已集成</td>
</tr>
</tbody></table>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317103008281.png" alt="image-20210317103008281"></p>
<p>CAP</p>
<ul>
<li>C：Consistency（强一致性）</li>
<li>A：Availablity（可用性）</li>
<li>P：Partition tolerance（分区容错性）</li>
<li>CAP理论关注粒度是数据，而不是整体系统设计的策略</li>
</ul>
<p><strong>CAP最多只能同时较好的满足两个</strong></p>
<p>CAP理论核心：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</strong>，因此，根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类：</p>
<ul>
<li>CA-单点集群，满足一致性，可用性的系统，通常性能不是特别高</li>
<li>CP-满足一致性，分区容忍性的系统，通常性能不是特别高</li>
<li>AP-满足可用性，分区容忍性的系统，通常可能对一致性要求低一些</li>
</ul>
<p>AP（Eureka）</p>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317104440305.png" alt="image-20210317104440305"></p>
<p>CP（Zookeeper/Consul）</p>
<ul>
<li>当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性，</li>
<li>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP</li>
</ul>
<p><img src="/2021/01/23/SpringCloud-03/image-20210317105543119.png" alt="image-20210317105543119"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-04(Ribbon负载均衡/OpenFeign服务调用)</title>
    <url>/2021/02/05/SpringCloud-04/</url>
    <content><![CDATA[<h1 id="SpringCloud-04"><a href="#SpringCloud-04" class="headerlink" title="SpringCloud-04"></a>SpringCloud-04</h1><h2 id="1、Ribbon负载均衡服务调用"><a href="#1、Ribbon负载均衡服务调用" class="headerlink" title="1、Ribbon负载均衡服务调用"></a>1、Ribbon负载均衡服务调用</h2><h3 id="1-1-Ribbon是什么"><a href="#1-1-Ribbon是什么" class="headerlink" title="1.1 Ribbon是什么"></a>1.1 Ribbon是什么</h3><ul>
<li><p>Spring Cloud Ribbon 是基于Netflix Ribbon实现的一套<strong>客户端(应该在消费者端80)    负载均衡工具</strong></p>
</li>
<li><p>简单来说，Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和服务调用</strong>。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单来说，就是配置文件中列出Load Balancer(简称LB)后面的所有机器，Ribbon会自动的帮助理你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法</p>
</li>
<li><p>官网资料：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a></p>
</li>
<li><p>Ribbon目前也进入维护模式，未来可能会被SpringCloud的LoadBalance替换</p>
</li>
</ul>
<h3 id="1-2-可以干什么"><a href="#1-2-可以干什么" class="headerlink" title="1.2 可以干什么"></a>1.2 可以干什么</h3><p>LB负载均衡(Load Balance)是什么</p>
<ul>
<li><p>简单来说，就是将用户请求平摊到多个服务器上，从而达到系统的HA(高可用)</p>
</li>
<li><p>常见的负载均衡有 软件Nginx，LVS，硬件F5等</p>
</li>
</ul>
<p>Ribbon本地负载均衡客户端和Nginx服务端负载均衡区别</p>
<ul>
<li>Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡是由服务端实现</li>
<li>Ribbon本地负载均衡，在调用微服务接口的时候，会在注册中心上获取信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术</li>
</ul>
<p><strong>集中式负载均衡LB</strong></p>
<ul>
<li>即在服务的消费方和提供方之间使用独立LB设施(可以是硬件，如F5，也可以是软件，如Nginx)，由该设施负责把访问请求通过某种策略转发到服务的提供方</li>
</ul>
<p><strong>进程内LB</strong></p>
<ul>
<li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器，Ribbon就属于进程内LB，它只是一个类库，集成与消费方进程，消费方通过它来获取到服务提供方的地址</li>
</ul>
<p><strong>Ribbon：负载均衡+RestTemplate调用</strong></p>
<h3 id="1-3-负载均衡演示"><a href="#1-3-负载均衡演示" class="headerlink" title="1.3 负载均衡演示"></a>1.3 负载均衡演示</h3><p>Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和Eureka结合只是其中一个实例</p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317122201421.png" alt="image-20210317122201421"></p>
<p>Ribbon在工作时分成两步</p>
<ul>
<li><p>第一步先选择EurekaServer，它优先选择在同一个区域内负载较少的server</p>
</li>
<li><p>第二步再根据用户指定的策略，从server取到的服务注册列表中选择一个地址</p>
</li>
<li><p>其中Ribbon提供了多种策略，比如轮询，随机和根据响应时间加权</p>
</li>
</ul>
<p>启动配置了Eureka的服务注册中心的7001和7002服务，再启动配置了Eureka的支付模块<code>cloud-provider-payment8001</code>，<code>cloud-provider-payment8002</code>，再启动配置了Eureka的消费者模块<code>cloud-consumer-order80</code></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317123909054.png" alt="image-20210317123909054"></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317123438489.png" alt="image-20210317123438489"></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317123455721.png" alt="image-20210317123455721"></p>
<p><strong>发现此是8001和8002服务端口交替出现，此时Ribbon是轮询策略</strong></p>
<p>但是此时查看80消费端的POM文件，发现并没有配置Ribbon依赖，但是我们负载均衡已经完成了</p>
<p>因为<code>spring-cloud-starter-netflix-eureka-client</code>自带了<code>spring-cloud-starter-ribbon</code></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317124307620.png" alt="image-20210317124307620"></p>
<h3 id="1-4-RestTemplate的使用"><a href="#1-4-RestTemplate的使用" class="headerlink" title="1.4 RestTemplate的使用"></a>1.4 RestTemplate的使用</h3><p><img src="/2021/02/05/SpringCloud-04/image-20210317125020829.png" alt="image-20210317125020829"></p>
<p><code>getForObject</code>方法/<code>getForEntity</code>方法</p>
<p>如果需要详细信息就使用<code>getForEntity</code>方法，如果只需要返回一个Json串，就使用<code>getForObject</code>方法</p>
<pre><code class="java">//返回对象为响应体中数据转化成的对象，基本可以理解为Json
@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123;
        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class);
    &#125;

  
//返回对象为ResponseEntity对象，包含响应中的一些重要信息，比如响应头，响应状态码，响应体等
@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment2(@PathVariable(&quot;id&quot;) Long id)&#123;

        ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + &quot;/payment/get/&quot; + id, CommonResult.class);
        if (entity.getStatusCode().is2xxSuccessful())&#123;
            return entity.getBody();
        &#125;else &#123;
            return new CommonResult&lt;&gt;(444,&quot;操作失败&quot;);
        &#125;
    &#125;
</code></pre>
<p>postForObject/postForEntity</p>
<pre><code class="java">@GetMapping(&quot;/consumer/payment/create&quot;)
    public CommonResult&lt;Payment&gt; create(Payment payment)&#123;
        return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class);
//        return restTemplate.postForEntity(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class).getBody();
    &#125;
</code></pre>
<h3 id="1-5-Ribbon核心组件IRule"><a href="#1-5-Ribbon核心组件IRule" class="headerlink" title="1.5 Ribbon核心组件IRule"></a>1.5 Ribbon核心组件IRule</h3><p>IRule：根据特定算法从服务列表中选取一个要访问的服务</p>
<ul>
<li><code>com.netflix.loadbalancer.RoundRobinRule</code>：轮询(默认)</li>
<li><code>com.netflix.loadbalancer.RandomRule</code>：随机</li>
<li><code>com.netflix.loadbalancer.RetryRule</code>：先按照RoundRobinRule的策略获取服务,如果获取服务失败则在指定时间内进行重试,获取可用的服务</li>
<li><code>WeightedResponseTimeRule</code>：对RoundRobinRule的扩展,响应速度越快的实例选择权重越多大,越容易被选择</li>
<li><code>BestAvailableRule</code>：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务,然后选择一个并发量最小的服务</li>
<li><code>AvailabilityFilteringRule</code>：先过滤掉故障实例,再选择并发较小的实例</li>
<li><code>ZoneAvoidanceRule</code>：默认规则,复合判断server所在区域的性能和server的可用性选择服务器</li>
</ul>
<p><strong>如何替换服务</strong></p>
<ul>
<li><p>修改<code>cloud-consumer-order80</code></p>
</li>
<li><p>注意：官方文档明确给出警告：Ribbon自定义配置类不能放在<code>@ComponentScan</code>所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的</p>
</li>
<li><p>通俗来讲，每一个启动类都有<code>@SpringBootApplication</code>注解，而此注解上有<code>@ComponentScan</code>注解，所以不能放在主启动类的当前包下以及子包下</p>
</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317134013468.png" alt="image-20210317134013468"></p>
<ul>
<li>所以，既然不能在主启动的包下，那就新建一个包</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317134240134.png" alt="image-20210317134240134"></p>
<ul>
<li>上面包下新建MySelfRule规则类</li>
</ul>
<pre><code class="java">package com.practice.myrule;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RoundRobinRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
/**
 * 自定义负载均衡路由规则类
 * */
@Configuration
public class MySelfRule &#123;
    @Bean
    public IRule myRule() &#123;
        // 定义为随机
        return new RandomRule();
    &#125;

&#125;
</code></pre>
<ul>
<li>在主启动类上添加<code>@RibbonClient</code></li>
</ul>
<pre><code class="java">package com.practice.springcloud;

import com.practice.myrule.MySelfRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;

@SpringBootApplication
@EnableEurekaClient
@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)
public class OrderMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderMain80.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>测试，可以看出8001和8002端口随机变化，不会跟之前默认轮询一样互相切换</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317144004875.png" alt="image-20210317144004875"></p>
<h3 id="1-6-负载均衡算法"><a href="#1-6-负载均衡算法" class="headerlink" title="1.6 负载均衡算法"></a>1.6 负载均衡算法</h3><h4 id="1-6-1-原理"><a href="#1-6-1-原理" class="headerlink" title="1.6.1 原理"></a>1.6.1 原理</h4><p>负载均衡算法：rest接口第几次请求数%服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始</p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317144510886.png" alt="image-20210317144510886"></p>
<h4 id="1-6-2-手写负载算法"><a href="#1-6-2-手写负载算法" class="headerlink" title="1.6.2 手写负载算法"></a>1.6.2 手写负载算法</h4><ul>
<li><p>原理+JUC （CAS+自旋锁）</p>
</li>
<li><p>7001/7002集群启动</p>
</li>
<li><p>8001/8002微服务改造，都修改Controller</p>
</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317152206578.png" alt="image-20210317152206578"></p>
<pre><code class="java">@GetMapping(value = &quot;/payment/lb&quot;)
    public String getPaymentLB() &#123;
        return serverPort;
    &#125;
</code></pre>
<ul>
<li><p>80订单微服务改造</p>
<ol>
<li><code>ApplicationContextBean</code>去掉注解<code>@LoadBalanced</code></li>
</ol>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317152422861.png" alt="image-20210317152422861"></p>
<ol start="2">
<li>LoadBalancer接口</li>
</ol>
<pre><code class="java">package com.practice.springcloud.lb;

import org.springframework.cloud.client.ServiceInstance;

import java.util.List;

/**
 * 获取存活的服务实例列表
 * */
public interface LoadBalancer &#123;

    ServiceInstance instance(List&lt;ServiceInstance&gt; serviceInstances);
&#125;
</code></pre>
<ol start="3">
<li>MyLB</li>
</ol>
<pre><code class="java">package com.practice.springcloud.lb;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Ribbon手写轮询算法
 * */
@Component
public class MyLB implements  LoadBalancer&#123;


    private AtomicInteger atomicInteger = new AtomicInteger(0);

    public final int getAndIncrement()&#123;
        int current;
        int next;

        do &#123;
            current = this.atomicInteger.getAndIncrement();
            // 超过最大值,为0,重新计数 2147483647 = Integer.MAX_VALUE
            next = current &gt;= Integer.MAX_VALUE ? 0 : current + 1;
            // 自旋锁
        &#125;while (this.atomicInteger.compareAndSet(current,next));
        System.out.println(&quot;****第几次访问，次数next: &quot;+next);
        return next;
    &#125;

    /*
    * 负载均衡算法:rest接口第几次请求数%服务器集群总数量=实际调用服务器位置下标,每次服务重启动后rest接口计数从1开始.
    * */
    @Override
    public ServiceInstance instance(List&lt;ServiceInstance&gt; serviceInstances) &#123;

        int index = getAndIncrement() % serviceInstances.size();


        return serviceInstances.get(index);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>OrderController</li>
</ol>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.lb.LoadBalancer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;
import java.net.URI;
import java.util.List;

@RestController
@Slf4j
public class OrderController &#123;

    /**
     * 通过在eureka上注册过的微服务名称调用
     * */
//    public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;
    public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;
    @Resource
    private RestTemplate restTemplate;

    /**
     * 自定义负载均衡规则
     * */
    @Resource
    private LoadBalancer loadBalancer;
    @Resource
    private DiscoveryClient discoveryClient;

    @GetMapping(&quot;/consumer/payment/create&quot;)
    public CommonResult&lt;Payment&gt; create(Payment payment)&#123;
        return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class);
//        return restTemplate.postForEntity(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class).getBody();
    &#125;

    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123;
        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class);
    &#125;

    @GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment2(@PathVariable(&quot;id&quot;) Long id)&#123;

        ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + &quot;/payment/get/&quot; + id, CommonResult.class);
        if (entity.getStatusCode().is2xxSuccessful())&#123;
            return entity.getBody();
        &#125;else &#123;
            return new CommonResult&lt;&gt;(444,&quot;操作失败&quot;);
        &#125;
    &#125;

    /**
     * 路由规则: 轮询
     * http://localhost/consumer/payment/payment/lb
     */
    @GetMapping(value = &quot;/consumer/payment/lb&quot;)
    public String getPaymentLB()&#123;
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
        if (instances == null || instances.size() &lt;= 0)&#123;
            return null;
        &#125;

        ServiceInstance serviceInstance = loadBalancer.instance(instances);
        URI uri = serviceInstance.getUri();

        return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class);

    &#125;
&#125;
</code></pre>
</li>
<li><p>测试，输入<a href="http://localhost/consumer/payment/lb%E5%9C%B0%E5%9D%80%EF%BC%8C8001%E5%92%8C8002%E4%BA%A4%E6%9B%BF%E5%87%BA%E7%8E%B0">http://localhost/consumer/payment/lb地址，8001和8002交替出现</a></p>
</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317155440728.png" alt="image-20210317155440728"></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210317160604862.png" alt="image-20210317160604862"></p>
<h2 id="2、OpenFeign服务调用"><a href="#2、OpenFeign服务调用" class="headerlink" title="2、OpenFeign服务调用"></a>2、OpenFeign服务调用</h2><h3 id="2-1-OpenFeign是什么"><a href="#2-1-OpenFeign是什么" class="headerlink" title="2.1 OpenFeign是什么"></a>2.1 OpenFeign是什么</h3><ul>
<li>Feign是一个声明式WebService客户端。使用Feign能让编写WebService客户端更加简单。</li>
<li>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可插拔式的编码器和解码器。SpringCloud对Feign进行了封装，使其支持了SpringMVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</li>
<li>Feign是一个声明式的Web服务客户端，让编写Web服务客户端变的非常容易，只需要创建一个接口并在接口上添加注解即可</li>
</ul>
<h3 id="2-2-可以干什么"><a href="#2-2-可以干什么" class="headerlink" title="2.2 可以干什么"></a>2.2 可以干什么</h3><ul>
<li>Feign旨在使编写Java Http客户端变的更容易</li>
<li>前面在使用Ribbon+RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，<strong>往往一个接口会被多处调用，所以通常会针对每个微服务自行封装一些客户端来包装这些依赖服务的调用</strong>，所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，**我们只需要创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)**，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量</li>
</ul>
<p><strong>Feign集成了Ribbon</strong></p>
<ul>
<li>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用</li>
</ul>
<p>Feign和OpenFeign两者区别</p>
<ul>
<li>Feign<ul>
<li>Feign是Spring Cloud组件中的一个轻量级RESTful的Http服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务，Feign的使用方法是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</li>
</ul>
</li>
<li>OpenFeign<ul>
<li>OpenFeign是SpringCloud在Feign基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</li>
</ul>
</li>
</ul>
<h3 id="2-3-OpenFeign的使用"><a href="#2-3-OpenFeign的使用" class="headerlink" title="2.3 OpenFeign的使用"></a>2.3 OpenFeign的使用</h3><ul>
<li>OpenFeign替换了Ribbon+RestTemplate</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318131350182.png" alt="image-20210318131350182"></p>
<ul>
<li>接口+注解   微服务调用接口+@FeginClient</li>
</ul>
<h4 id="2-3-1-新建Module，Feign在消费端使用"><a href="#2-3-1-新建Module，Feign在消费端使用" class="headerlink" title="2.3.1 新建Module，Feign在消费端使用"></a>2.3.1 新建Module，Feign在消费端使用</h4><p><img src="/2021/02/05/SpringCloud-04/image-20210318131802389.png" alt="image-20210318131802389"></p>
<h4 id="2-3-2-改POM"><a href="#2-3-2-改POM" class="headerlink" title="2.3.2 改POM"></a>2.3.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt;
    &lt;description&gt;订单消费者之feign&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;!--openfeign--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--eureka client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;
</code></pre>
<h4 id="2-3-3-改YML"><a href="#2-3-3-改YML" class="headerlink" title="2.3.3 改YML"></a>2.3.3 改YML</h4><pre><code class="yml">server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
</code></pre>
<h4 id="2-3-4-主启动类"><a href="#2-3-4-主启动类" class="headerlink" title="2.3.4 主启动类"></a>2.3.4 主启动类</h4><ul>
<li>@EnableFeignClient</li>
</ul>
<pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class OrderFeignMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderFeignMain80.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="2-3-5-业务类"><a href="#2-3-5-业务类" class="headerlink" title="2.3.5 业务类"></a>2.3.5 业务类</h4><p>业务逻辑接口+<strong>@FeignClient配置调用provider服务</strong></p>
<ul>
<li>新建PaymentFeignService接口并新增注解@FeignClient</li>
</ul>
<pre><code class="java">package com.practice.springcloud.service;


import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import feign.Param;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Component
@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)
public interface PaymentFeignService &#123;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<ul>
<li>控制层Controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import com.practice.springcloud.service.PaymentFeignService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderFeignController &#123;

    @Resource
    private PaymentFeignService paymentFeignService;

    @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;

        return paymentFeignService.getPaymentById(id);
    &#125;
&#125;
</code></pre>
<h4 id="2-3-6-测试"><a href="#2-3-6-测试" class="headerlink" title="2.3.6 测试"></a>2.3.6 测试</h4><ul>
<li>启动Eureka集群7001和7002</li>
<li>启动支付服务8001和8002</li>
<li>启动消费模块Feign80</li>
<li>输入<a href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></li>
<li>8001和8002轮询切换，说明Feign中自带负载均衡配置项</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318135443770.png" alt="image-20210318135443770"></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318135427320.png" alt="image-20210318135427320"></p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318140303175.png" alt="image-20210318140303175"></p>
<h3 id="2-4-OpenFeign超时控制"><a href="#2-4-OpenFeign超时控制" class="headerlink" title="2.4 OpenFeign超时控制"></a>2.4 OpenFeign超时控制</h3><ul>
<li>设置超时，8001服务提供方写暂停程序</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318144018677.png" alt="image-20210318144018677"></p>
<pre><code class="java">@GetMapping(value = &quot;/payment/feign/timeout&quot;)
    public String paymentFeignTimeout()&#123;
        //暂停几秒钟线程
        try &#123;
            TimeUnit.SECONDS.sleep(3);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
        return serverPort;
    &#125;
</code></pre>
<ul>
<li>80服务消费方添加超时方法PaymentFeignService</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318144222327.png" alt="image-20210318144222327"></p>
<pre><code class="java">@Component
@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)
public interface PaymentFeignService &#123;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id);

    @GetMapping(value = &quot;/payment/feign/timeout&quot;)
    public String paymentFeignTimeout();
&#125;
</code></pre>
<ul>
<li>80服务消费方添加超时方法OrderFeignController</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318144327033.png" alt="image-20210318144327033"></p>
<pre><code class="java">@RestController
@Slf4j
public class OrderFeignController &#123;

    @Resource
    private PaymentFeignService paymentFeignService;

    @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;

        return paymentFeignService.getPaymentById(id);
    &#125;

    @GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)
    public String paymentFeignTimeout()&#123;
        //openfeign-ribbon，客户端一般默认等待1秒钟
        return paymentFeignService.paymentFeignTimeout();
    &#125;
&#125;
</code></pre>
<ul>
<li>测试：<a href="http://localhost/consumer/payment/feign/timeout">http://localhost/consumer/payment/feign/timeout</a></li>
<li>8001服务提供者访问没问题</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318144955210.png" alt="image-20210318144955210"></p>
<ul>
<li>服务消费方测试超时</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318145050463.png" alt="image-20210318145050463"></p>
<ul>
<li>OpenFeign默认等待1秒钟，超过后报错</li>
<li>OpenFeign客户端默认只等待一秒钟，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待，直接返回报错，为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制</li>
<li>在客户端80的yml文件中设置超时控制</li>
</ul>
<pre><code class="yml">server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
# 设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
  # 指的是建立连接后从服务器读取到可用资源所用的时间
  ReadTimeout: 5000
  #指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间
  ConnectTimeout: 5000
</code></pre>
<ul>
<li>这样客户端80访问就没有什么问题了</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318145705330.png" alt="image-20210318145705330"></p>
<h3 id="2-5-OpenFeign日志打印功能"><a href="#2-5-OpenFeign日志打印功能" class="headerlink" title="2.5 OpenFeign日志打印功能"></a>2.5 OpenFeign日志打印功能</h3><ul>
<li>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节，说白了就是<strong>对Feign接口的调用情况进行监控和输出</strong></li>
</ul>
<p>OpenFeign的日志级别</p>
<ul>
<li>NONE：默认的，不显示任何日志；</li>
<li>BASIC：仅记录请求方法，URL，响应状态码以及执行时间</li>
<li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息</li>
<li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据</li>
</ul>
<p>配置日志Bean，在80服务下配置</p>
<pre><code class="java">@Configuration
public class FeignConfig &#123;

    /**
     * feignClient配置日志级别
     *
     * @return
     */
    @Bean
    public Logger.Level feignLoggerLevel() &#123;
        // 请求和响应的头信息,请求和响应的正文及元数据
        return Logger.Level.FULL;
    &#125;
&#125;
</code></pre>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318151027980.png" alt="image-20210318151027980"></p>
<ul>
<li>YML文件中需要开启日志的Feign客户端</li>
</ul>
<pre><code class="yml">server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
# 设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
  # 指的是建立连接后从服务器读取到可用资源所用的时间
  ReadTimeout: 5000
  #指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间
  ConnectTimeout: 5000
logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.practice.springcloud.service.PaymentFeignService: debug
</code></pre>
<ul>
<li>测试</li>
</ul>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318151646862.png" alt="image-20210318151646862"></p>
<p>后台日志查看</p>
<p><img src="/2021/02/05/SpringCloud-04/image-20210318151632185.png" alt="image-20210318151632185"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-06(Gateway网关)</title>
    <url>/2021/02/20/SpringCloud-06/</url>
    <content><![CDATA[<h1 id="SpringCloud-06"><a href="#SpringCloud-06" class="headerlink" title="SpringCloud-06"></a>SpringCloud-06</h1><h2 id="1、Gateway新一代网关"><a href="#1、Gateway新一代网关" class="headerlink" title="1、Gateway新一代网关"></a>1、Gateway新一代网关</h2><h3 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h3><ul>
<li>上一代zuul 1.x <a href="https://github.com/Netflix/zuul/wiki">https://github.com/Netflix/zuul/wiki</a></li>
<li>当前gateway <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></li>
</ul>
<h3 id="1-2-是什么"><a href="#1-2-是什么" class="headerlink" title="1.2 是什么"></a>1.2 是什么</h3><p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；</p>
<p>但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发看一个网关替代Zuul</p>
<p>那就是SpringCloud Gateway 一句话：Gateway是原zuul1.x版的替代</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320085548005.png" alt="image-20210320085548005"></p>
<p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring5，Spring Boot 2和Project Reactor等技术</p>
<p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断，限流，重试等</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320090009085.png" alt="image-20210320090009085"></p>
<p>SpringCloud Gateway是Spring Cloud的一个全新项目，基于 Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的API路由管理方式</p>
<p>SpringCloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本，而为了提升网关的性能，<strong>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</strong></p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于Filter链的方式提供了网关基本功能，例如：安全，监控/指标，和限流。</p>
<p><strong>总结：</strong>SpringCloud Gateway使用的是Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架</p>
<h3 id="1-3-能干什么"><a href="#1-3-能干什么" class="headerlink" title="1.3 能干什么"></a>1.3 能干什么</h3><p>反向代理、鉴权、流量控制、熔断、日志监控等等</p>
<h3 id="1-4-微服务框架中网关所在位置"><a href="#1-4-微服务框架中网关所在位置" class="headerlink" title="1.4 微服务框架中网关所在位置"></a>1.4 微服务框架中网关所在位置</h3><p><img src="/2021/02/20/SpringCloud-06/image-20210320091724522.png" alt="image-20210320091724522"></p>
<h3 id="1-5-为什么使用Gateway"><a href="#1-5-为什么使用Gateway" class="headerlink" title="1.5 为什么使用Gateway"></a>1.5 为什么使用Gateway</h3><ol>
<li>因为Zuul 1.0 已经进入了维护阶段，而且Gateway是Spring Cloud团队研发的，值得信赖，而且很多功能Zuul都没有用起来，Gateway用起来也非常的简单快捷</li>
<li>Gateway是基于<strong>异步非阻塞模型</strong>上进行开发的，性能方面不需要担心，虽然Netflix早就发布了最新的Zuul 2.x，但Spring Cloud貌似没有整合计划，而且Netflix相关组件都宣布进入维护期；不知前景如何，所以多方面考虑Gateway是很理想的网关选择</li>
</ol>
<p>Spring Cloud Gateway 具有以下特性：</p>
<ul>
<li><strong>基于Spring Framework 5.Project Reactor和Spring Boot 2.0进行构建；</strong></li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定 Predicate（断言）和 Filter （过滤器）；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成Spring Cloud服务发现功能；</li>
<li>易于编写的 Predicate（断言）和 Filter（过滤器）；</li>
<li>请求限流功能；</li>
<li>支持路径重写；</li>
</ul>
<p>Spring Cloud Gateway与Zuul的区别</p>
<p>在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul；</p>
<ol>
<li>Zuul 1.x，是一个基于阻塞I/O的API Gateway</li>
<li>Zuul 1.x <strong>基于Servlet2.5使用阻塞架构</strong>它不支持任何长连接（如WebSocket）Zuul的设计模式和Nginx较像，每次I/O操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能相对较差</li>
<li>Zuul 2.x 理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul 2.x 的性能较Zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway 的RPS（每秒请求数）是Zuul的1.6倍</li>
<li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot 2之上，使用非阻塞API</li>
<li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li>
</ol>
<h3 id="1-6-Zuul1-x模型"><a href="#1-6-Zuul1-x模型" class="headerlink" title="1.6 Zuul1.x模型"></a>1.6 Zuul1.x模型</h3><p>SpringCloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型。</p>
<p><strong>Servlet生命周期</strong>？servlet由servlet container进行生命周期管理</p>
<ul>
<li>container启动时构造servlet对象并调用servlet init()进行初始化；</li>
<li>container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service().</li>
<li>container关闭时调用servlet destory()销毁servlet</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320100715431.png" alt="image-20210320100715431"></p>
<p>上述模式的缺点：</p>
<p>servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在<strong>并发不高的场景下</strong>这种模型是适用的，但是一旦高并发（比如用JMeter模拟高并发），线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发请求，这种业务场景下servlet模型没有优势</p>
<p>所以Zuul 1.x是基于<strong>servlet之上的一个阻塞式处理模型</strong>，即spring实现了处理所有request请求的一个servlet（DispatchServlet）并由该servlet阻塞式处理。所以SpringCloud Zuul无法摆脱servlet模型的弊端</p>
<h3 id="1-7-Gateway模型"><a href="#1-7-Gateway模型" class="headerlink" title="1.7 Gateway模型"></a>1.7 Gateway模型</h3><p>Spring WebFlux</p>
<p>官网：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux</a></p>
<p>传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的</p>
<p>但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型的非阻塞异步框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用java8）</p>
<p>spring WebFlux是Spring5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范</p>
<h2 id="2、Gateway的三大核心概念"><a href="#2、Gateway的三大核心概念" class="headerlink" title="2、Gateway的三大核心概念"></a>2、Gateway的三大核心概念</h2><ul>
<li><strong>Route（路由）</strong></li>
</ul>
<p>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</p>
<ul>
<li><strong>Predicate（断言）</strong></li>
</ul>
<p>参考的是Java8的java.util.function.Predicate<br>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由</p>
<ul>
<li><strong>Filter（过滤）</strong></li>
</ul>
<p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改.</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320103323578.png" alt="image-20210320103323578"></p>
<p>Web请求，通过一些匹配条件，定位到真正的服务点，并在这个转发过程的前后，进行一些精细化控制，predicate就是我们的匹配条件，而filter，就可以理解为一个无所不能的拦截器，有了这两个元素，再加上目标uri，就可以实现一个具体的路由了</p>
<h2 id="3、Gateway工作流程"><a href="#3、Gateway工作流程" class="headerlink" title="3、Gateway工作流程"></a>3、Gateway工作流程</h2><p><img src="/2021/02/20/SpringCloud-06/image-20210320104102665.png" alt="image-20210320104102665"></p>
<p>客户端向Spring Cloud Gateway发出请求。然后再Gateway Handler Mapping中找到与请求想匹配的路由，将其发送到Gateway Web Handler。</p>
<p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（”pre“）或之后（”post“）执行业务逻辑</p>
<p>Filter在“pre”类型的过滤器可以做参数校验，权限校验，流量监控，日志输出，协议转换等，在“post”类型的过滤器中可以做响应内容，响应头的修改，日志的输出，流量的监控等有着非常重要的作用</p>
<p><strong>核心逻辑：路由转发+执行过滤器链</strong></p>
<h2 id="4、入门配置"><a href="#4、入门配置" class="headerlink" title="4、入门配置"></a>4、入门配置</h2><h3 id="4-1-新建Module"><a href="#4-1-新建Module" class="headerlink" title="4.1 新建Module"></a>4.1 新建Module</h3><ul>
<li>cloud-gateway-gateway9527</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320105119590.png" alt="image-20210320105119590"></p>
<h3 id="4-2-改POM"><a href="#4-2-改POM" class="headerlink" title="4.2 改POM"></a>4.2 改POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-gateway-gateway9527&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--gateway无需web和actuator--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="4-3-改YML"><a href="#4-3-改YML" class="headerlink" title="4.3 改YML"></a>4.3 改YML</h3><pre><code class="yml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进Eureka服务列表内
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>
<h3 id="4-4-主启动"><a href="#4-4-主启动" class="headerlink" title="4.4 主启动"></a>4.4 主启动</h3><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class GateWayMain9527 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(GateWayMain9527.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="4-5-9527网关如何路由映射"><a href="#4-5-9527网关如何路由映射" class="headerlink" title="4.5 9527网关如何路由映射"></a>4.5 9527网关如何路由映射</h3><ul>
<li>cloud-provider-payment8001看看controller的访问地址</li>
</ul>
<p>有两个方法，一个get一个lb</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320110953444.png" alt="image-20210320110953444"></p>
<ul>
<li>我们目前不想暴露8001端口,希望在8001外面套一层9527</li>
</ul>
<h4 id="4-5-1-YML新增网关配置"><a href="#4-5-1-YML新增网关配置" class="headerlink" title="4.5.1 YML新增网关配置"></a>4.5.1 YML新增网关配置</h4><pre><code class="yml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名
          uri: http://localhost:8001 #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/** # 断言，路径相匹配的进行路由

        - id: payment_route2 # 路由的id,没有规定规则但要求唯一,建议配合服务名
          uri: http://localhost:8001 #匹配后提供服务的路由地址
          predicates:
            Path=/payment/lb/** #断言,路径相匹配的进行路由
eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进Eureka服务列表内
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>
<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><p>启动7001，8001，9527</p>
<ul>
<li>注意9527的POM文件中不能加这两个依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320124934719.png" alt="image-20210320124934719"></p>
<ul>
<li>添加网关前：<a href="http://localhost:8001/payment/get/31">http://localhost:8001/payment/get/31</a></li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320125011158.png" alt="image-20210320125011158"></p>
<ul>
<li>添加网关后：<a href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a></li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320125048731.png" alt="image-20210320125048731"></p>
<h2 id="5、-配置路由的两种方式"><a href="#5、-配置路由的两种方式" class="headerlink" title="5、 配置路由的两种方式"></a>5、 配置路由的两种方式</h2><h3 id="5-1-在配置文件yml中配置"><a href="#5-1-在配置文件yml中配置" class="headerlink" title="5.1 在配置文件yml中配置"></a>5.1 在配置文件yml中配置</h3><ul>
<li>在上述 <strong>4、入门配置</strong> 中有介绍</li>
</ul>
<h3 id="5-2-代码中注入RouteLocator的Bean"><a href="#5-2-代码中注入RouteLocator的Bean" class="headerlink" title="5.2 代码中注入RouteLocator的Bean"></a>5.2 代码中注入RouteLocator的Bean</h3><p>业务需求：通过9527网关访问到外网的百度新闻网址</p>
<p><a href="http://news.baidu.com/guonei">http://news.baidu.com/guonei</a></p>
<p>编码：加一个配置文件</p>
<pre><code class="java">package com.practice.springcloud.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig &#123;

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&#123;
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        //http://news.baidu.com/guonei
        routes.route(&quot;path_route_practice&quot;,
                r -&gt; r.path(&quot;/guonei&quot;)
                        .uri(&quot;http://news.baidu.com/guonei&quot;)).build();

        return routes.build();
    &#125;

&#125;
</code></pre>
<p>测试：</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320131309673.png" alt="image-20210320131309673"></p>
<h2 id="6、通过微服务名实现动态路由"><a href="#6、通过微服务名实现动态路由" class="headerlink" title="6、通过微服务名实现动态路由"></a>6、通过微服务名实现动态路由</h2><ul>
<li>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<strong>动态路由进行转发，从而实现动态路由的功能</strong></li>
<li>启动：一个Eureka7001+两个服务提供者8001/8002</li>
<li>改yml<ul>
<li>需要注意的是uri的协议lb，表示启用Gateway的负载均衡功能。</li>
<li>lb://serverName是spring cloud Gateway在微服务中自动为我们创建的负载均衡uri</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320133459353.png" alt="image-20210320133459353"></p>
<pre><code class="yml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名
#          uri: http://localhost:8001 #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/** # 断言，路径相匹配的进行路由

        - id: payment_route2 # 路由的id,没有规定规则但要求唯一,建议配合服务名
#          uri: http://localhost:8001 #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            Path=/payment/lb/** #断言,路径相匹配的进行路由
eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进Eureka服务列表内
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>
<ul>
<li>测试，启动9527，<a href="http://localhost:9527/payment/lb%EF%BC%8C8001/8002%E4%B8%A4%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%88%87%E6%8D%A2">http://localhost:9527/payment/lb，8001/8002两个端口切换</a></li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320134124316.png" alt="image-20210320134124316"></p>
<h2 id="7、Predicate的使用"><a href="#7、Predicate的使用" class="headerlink" title="7、Predicate的使用"></a>7、Predicate的使用</h2><p>启动9527会发现</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320134332976.png" alt="image-20210320134332976"></p>
<p>Route Predicate Factories是什么</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320135054291.png" alt="image-20210320135054291"></p>
<p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。</p>
<p>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与Http请求的不用属性匹配。多个Route Predicate工厂可以进行组合</p>
<p>Spring Cloud Gateway 创建 Route对象时，使用RoutePredicateFactory 创建 Predicate 对象，Predicate对象可以赋值给Route。Spring Cloud Gateway 包含许多内置的Route Predicate Factories。</p>
<p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and</p>
<h3 id="7-1-常用的Route-Predicate"><a href="#7-1-常用的Route-Predicate" class="headerlink" title="7.1 常用的Route Predicate"></a>7.1 常用的Route Predicate</h3><ol>
<li><p>After Route Predicate </p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320140719693.png" alt="image-20210320140719693"></p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320141819293.png" alt="image-20210320141819293"></p>
</li>
<li><p>Before Route Predicate </p>
</li>
<li><p>Between Route Predicate </p>
</li>
<li><p>Cookie Route Predicate</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320142201938.png" alt="image-20210320142201938"></p>
<p>Cookie Route Predicate需要两个参数，一个是Cookie name，一个正则表达式。</p>
<p>路由规则会通过获取对应的Cookie name值和正则表达式去匹配，如果匹配上了就会执行路由，如果没有匹配上则不执行</p>
<ul>
<li>不带cookie访问</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320143455722.png" alt="image-20210320143455722"></p>
<ul>
<li>带上cookie访问</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320143533780.png" alt="image-20210320143533780"></p>
</li>
<li><p>Header Route Predicate </p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320143743143.png" alt="image-20210320143743143"></p>
<p>两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320144311985.png" alt="image-20210320144311985"></p>
</li>
<li><p>Host Route Predicate</p>
</li>
<li><p>Method Route Predicate</p>
</li>
<li><p>Path Route Predicate</p>
</li>
<li><p>Query Route Predicate</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320144502710.png" alt="image-20210320144502710"></p>
<p>支持传入两个参数，一个属性名，一个为属性值，属性值可以是正则表达式</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理</li>
</ul>
<h2 id="8、Filter的使用"><a href="#8、Filter的使用" class="headerlink" title="8、Filter的使用"></a>8、Filter的使用</h2><h3 id="8-1-Filter是什么"><a href="#8-1-Filter是什么" class="headerlink" title="8.1 Filter是什么"></a>8.1 Filter是什么</h3><p><img src="/2021/02/20/SpringCloud-06/image-20210320145531651.png" alt="image-20210320145531651"></p>
<p>路由过滤器可用于修改进入的Http请求和返回的Http响应，路由过滤器只能指定路由进行使用</p>
<p>Spring Cloud Fateway 内置了多种路由过滤器，他们都由Gateway Filter的工厂类来产生</p>
<p>Spring Cloud Gateway 的Filter</p>
<ul>
<li>GatewayFilter（单一的）</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320150235626.png" alt="image-20210320150235626"></p>
<ul>
<li>Global Filters（全局的）</li>
</ul>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320150510149.png" alt="image-20210320150510149"></p>
<p>常用的GatewayFilter：AddRequestParameter</p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320151302238.png" alt="image-20210320151302238"></p>
<h3 id="8-2-自定义过滤器"><a href="#8-2-自定义过滤器" class="headerlink" title="8.2 自定义过滤器"></a>8.2 自定义过滤器</h3><p>自定义全局GlobalFilter，</p>
<p>两个主要接口介绍：GlobalFilter，Ordered</p>
<p>能干吗？</p>
<ul>
<li>全局日志记录</li>
<li>统一网关鉴权</li>
<li>等等</li>
</ul>
<p><strong>案例代码，自定义全局过滤器</strong></p>
<pre><code class="java">package com.practice.springcloud.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;
/*
全局自定义过滤器
*/
@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter, Ordered &#123;

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;
        log.info(&quot;*********come in MyLogGateWayFilter: &quot;+new Date());
        String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);
        if (uname==null)&#123;
            log.info(&quot;******用户名为null，非法用户&quot;);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        &#125;
        return chain.filter(exchange);
    &#125;

    /*
    * 过滤器加载的顺序 越小,优先级别越高
     * */
    @Override
    public int getOrder() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<p><strong>测试：</strong></p>
<p>错误：<a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a></p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320152747044.png" alt="image-20210320152747044"></p>
<p>正确：<a href="http://localhost:9527/payment/lb?uname=z3">http://localhost:9527/payment/lb?uname=z3</a></p>
<p><img src="/2021/02/20/SpringCloud-06/image-20210320152820291.png" alt="image-20210320152820291"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-07(Config服务配置/Bus服务总线)</title>
    <url>/2021/03/03/SpringCloud-07/</url>
    <content><![CDATA[<h1 id="SpringCloud-07"><a href="#SpringCloud-07" class="headerlink" title="SpringCloud-07"></a>SpringCloud-07</h1><h2 id="1、服务配置config"><a href="#1、服务配置config" class="headerlink" title="1、服务配置config"></a>1、服务配置config</h2><p><strong>分布式服务面临的配置问题</strong></p>
<ul>
<li>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</li>
<li>SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理……/(ㄒoㄒ)/~~</li>
</ul>
<p><strong>config是什么</strong></p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320164806342.png" alt="image-20210320164806342"></p>
<ul>
<li>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为<strong>各个不同微服务应用</strong>的所有环境提供了一个<strong>中心化的外部配置</strong>。</li>
</ul>
<p><strong>config怎么玩</strong><br>SpringCloud Config分为<strong>服务端和客户端</strong>两部分。</p>
<ul>
<li>服务端也称为<strong>分布式配置中心，它是一个独立的微服务应用</strong>，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口</li>
<li>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</li>
</ul>
<p><strong>config能干吗</strong></p>
<ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露，post、curl访问刷新均可…</li>
</ul>
<p><strong>分布式配置中心推荐跟GitHub整合</strong></p>
<ul>
<li>由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式</li>
</ul>
<p><strong>官网：</strong><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>
<h2 id="2、Config服务端配置与测试"><a href="#2、Config服务端配置与测试" class="headerlink" title="2、Config服务端配置与测试"></a>2、Config服务端配置与测试</h2><ol>
<li><p>用自己的GitHub账号在GitHub上新建一个名为springcloud-config的新Repository</p>
</li>
<li><p>获得SSH协议的git地址</p>
<p><a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#x6d;</a>:wyc1228/springcloud-config.git</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320171817426.png" alt="image-20210320171817426"></p>
</li>
<li><p>在本地硬盘目录上新建git仓库并clone（不需要初始化，直接clone）</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320190223936.png" alt="image-20210320190223936"></p>
<p>此时此文件下就有这些文件</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320190813007.png" alt="image-20210320190813007"></p>
</li>
</ol>
<h3 id="新建配置中心模块"><a href="#新建配置中心模块" class="headerlink" title="新建配置中心模块"></a>新建配置中心模块</h3><h3 id="2-1-建Module"><a href="#2-1-建Module" class="headerlink" title="2.1 建Module"></a>2.1 建Module</h3><ul>
<li>cloud-config-center-3344</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320191221526.png" alt="image-20210320191221526"></p>
<h3 id="2-2-改POM"><a href="#2-2-改POM" class="headerlink" title="2.2 改POM"></a>2.2 改POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-config-center-3344&lt;/artifactId&gt;


    &lt;dependencies&gt;
        &lt;!-- springCloud Config --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p><strong>注意：</strong>POM文件最好加上此依赖</p>
<pre><code class="xml">&lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
            &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
            &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>防止测试时报此错误</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321094331146.png" alt="image-20210321094331146"></p>
<h3 id="2-3-改YML"><a href="#2-3-改YML" class="headerlink" title="2.3 改YML"></a>2.3 改YML</h3><pre><code class="yml">server:
  port: 3344

spring:
  application:
    name:  cloud-config-center #注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
#          uri: git@github.com:wyc1228/springcloud-config.git #GitHub上面的git仓库名字
          uri: https://github.com/wyc1228/springcloud-config.git #GitHub上面的git仓库名字
          ####搜索目录
          search-paths:
            - springcloud-config
          ####读取分支
          force-pull: true
          username: github账号
          password: github密码
      label: main
#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
</code></pre>
<p><strong>注意</strong></p>
<p>现在github中master已更新为main</p>
<blockquote>
<p>使用SSH连接github无法成功，使用HTTP+账号密码的方式连接，可以成功，但是偶尔也会连接失败，不知道是否是网络原因。</p>
</blockquote>
<h3 id="2-4-增加映射"><a href="#2-4-增加映射" class="headerlink" title="2.4 增加映射"></a>2.4 增加映射</h3><p>找到C:\Windows\System32\drivers\etc路径下的hosts文件</p>
<p>修改配置文件，当然，不增加映射也可以，这样测试的时候是localhost:端口号</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320194946402.png" alt="image-20210320194946402"></p>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><ul>
<li>测试config微服务是否可以从GitHub上获取配置内容</li>
<li><a href="http://config-3344.com:3344/main/config-test.yml">http://config-3344.com:3344/main/config-test.yml</a></li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210320203056198.png" alt="image-20210320203056198"></p>
<p>测试成功：至此此线路打通，实现了Spring Cloud Config 通过Github获取配置信息</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321101841877.png" alt="image-20210321101841877"></p>
<h2 id="3、配置读取规则"><a href="#3、配置读取规则" class="headerlink" title="3、配置读取规则"></a>3、配置读取规则</h2><p>官网上有四种：</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321100532843.png" alt="image-20210321100532843"></p>
<p><code>/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</code>(推荐)</p>
<ul>
<li><code>http://config-3344.com:3344/master/application-dev.yml</code></li>
<li><code>http://config-3344.com:3344/master/application-test.yml</code></li>
</ul>
<p><code>/&#123;application&#125;-&#123;profile&#125;.yml</code> ，默认读出master分支</p>
<ul>
<li><code>http://config-3344.com:3344/application-dev.yml</code></li>
<li><code>http://config-3344.com:3344/application-test.yml</code></li>
<li><code>http://config-3344.com:3344/application-xxx.yml</code>(不存在的配置)</li>
</ul>
<p><code>/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</code></p>
<ul>
<li><code>http://config-3344.com:3344/application/dev/master</code></li>
<li><code>http://config-3344.com:3344/application/test/master</code></li>
<li><code>http://config-3344.com:3344/application/xxx/master</code></li>
</ul>
<h2 id="4、Config客户端配置与测试"><a href="#4、Config客户端配置与测试" class="headerlink" title="4、Config客户端配置与测试"></a>4、Config客户端配置与测试</h2><h3 id="4-1-建Module"><a href="#4-1-建Module" class="headerlink" title="4.1 建Module"></a>4.1 建Module</h3><ul>
<li>cloud-config-client-3355</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321102401325.png" alt="image-20210321102401325"></p>
<h3 id="4-2-改POM"><a href="#4-2-改POM" class="headerlink" title="4.2 改POM"></a>4.2 改POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-config-client-3355&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!-- SpringCloud Config客户端 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="4-3-改yml"><a href="#4-3-改yml" class="headerlink" title="4.3 改yml"></a>4.3 改yml</h3><ul>
<li>bootstrap.yml<ul>
<li>applicaiton.yml是用户级的资源配置项</li>
<li>bootstrap.yml是系统级的，<strong>优先级更加高</strong></li>
</ul>
</li>
<li>Spring Cloud会创建一个<code>Bootstrap Context</code>，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</li>
<li><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，<br>所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</li>
<li><strong>要将Client模块下的application.yml文件改为bootstrap.这是很关键的</strong>，因为bootstrap.yml是比application.yml文件先加载的。bootstrap.yml优先级高于application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: main #分支名称
      name: config #配置文件名称
      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 #配置中心地址k

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
</code></pre>
<h3 id="4-4-主启动类"><a href="#4-4-主启动类" class="headerlink" title="4.4 主启动类"></a>4.4 主启动类</h3><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3355 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConfigClientMain3355.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="4-5-业务类"><a href="#4-5-业务类" class="headerlink" title="4.5 业务类"></a>4.5 业务类</h3><pre><code class="java">package com.practice.springcloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ConfigClientController
&#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo()
    &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><ul>
<li>启动7001,3344，自测</li>
<li><a href="http://config-3344.com:3344/main/application-test.yml">http://config-3344.com:3344/main/application-test.yml</a></li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321105157886.png" alt="image-20210321105157886"></p>
<ul>
<li>通过之后，启动3355，测试</li>
<li><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321110259008.png" alt="image-20210321110259008"></p>
<ul>
<li>成功访问</li>
</ul>
<h2 id="5、客户端动态刷新问题"><a href="#5、客户端动态刷新问题" class="headerlink" title="5、客户端动态刷新问题"></a>5、客户端动态刷新问题</h2><ul>
<li><p>linux运维修改Github上的配置文件内容修改</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321111226983.png" alt="image-20210321111226983"></p>
</li>
<li><p>刷新3344,发现ConfigServer服务端配置中心立刻响应</p>
<ul>
<li>如果没有及时响应，可能是缓存问题，记得及时清除缓存</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321111426900.png" alt="image-20210321111426900"></p>
</li>
<li><p>刷新3355,发现ConfigClient客户端的没有任何响应</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321111906087.png" alt="image-20210321111906087"></p>
</li>
<li><p>3355没有变化除非自己重启或者重新加载</p>
</li>
<li><p>所以需要解决，每次修改配置文件，客户端都要重启的问题</p>
</li>
</ul>
<p>修改3355模块，</p>
<ul>
<li><p>在POM中引入actuator监控</p>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li><p>修改YML，暴露监控端口</p>
<pre><code class="yml"># 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
</li>
<li><p>业务类Controller修改，加@RefreshScope</p>
<pre><code class="java">package com.practice.springcloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope
public class ConfigClientController
&#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo()
    &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
</li>
<li><p>然后，运维人员在github上修改之后，需要运维人员发送POST请求刷新3355，必须是POST请求</p>
<ul>
<li>curl  -X POST “<a href="http://localhost:3355/actuator/refresh&quot;">http://localhost:3355/actuator/refresh&quot;</a></li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321124616572.png" alt="image-20210321124616572"></p>
</li>
<li><p>最后，刷新3355，就可以看到变化了</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321124632089.png" alt="image-20210321124632089"></p>
</li>
</ul>
<p><strong>存在的问题</strong></p>
<ul>
<li>假设有多个微服务，每个微服务都需要执行一次post请求吗？</li>
<li>可否广播，一次通知，处处生效，这就需要用到总线</li>
</ul>
<h2 id="6、-SpringCloud-Bus消息总线"><a href="#6、-SpringCloud-Bus消息总线" class="headerlink" title="6、 SpringCloud Bus消息总线"></a>6、 SpringCloud Bus消息总线</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>消息总线有对分布式自动刷新配置功能</p>
<p>Spring Cloud Bus 配合Spring Cloud Config使用可以实现配置的动态刷新，一般它们两个都是一起使用</p>
<p>Bus支持两种消息代理：RabbitMQ和Kafka</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321125741170.png" alt="image-20210321125741170"></p>
<p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，<strong>它整合了Java的事件处理机制和消息中间件功能。</strong></p>
<p><strong>能干什么？</strong></p>
<p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改，事件推送等，也可以当做微服务间的通信通道</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321130322151.png" alt="image-20210321130322151"></p>
<p><strong>为什么被称为总线</strong></p>
<p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个<strong>共用的消息主题</strong>，并让系统中所有微服务实例都连接上来。由于<strong>该主题中产生的消息会被所有实例监听和消费，所以称为它为消息总线</strong>，在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息</p>
<p><strong>基本原理：</strong></p>
<p>ConfigClient实例都监听MQ中同一个topic(默认是SpringCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其他监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p>
<h2 id="7、RabbitMQ环境配置"><a href="#7、RabbitMQ环境配置" class="headerlink" title="7、RabbitMQ环境配置"></a>7、RabbitMQ环境配置</h2><p>我已经在Linux上安装好了</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321134519901.png" alt="image-20210321134519901"></p>
<h2 id="8、Bus动态刷新全局广播"><a href="#8、Bus动态刷新全局广播" class="headerlink" title="8、Bus动态刷新全局广播"></a>8、Bus动态刷新全局广播</h2><p>前提：必须先具备良好的RabbitMQ环境</p>
<p>演示广播效果，增加复杂度，以3355为模板再制作一个3366</p>
<ul>
<li><p>新建Module：cloud-config-client-3366</p>
</li>
<li><p>改POM：跟3355一致</p>
</li>
<li><p>改YML：跟3355一致，改个端口号就行</p>
</li>
<li><p>主启动：</p>
</li>
<li><p>业务类：和3355一致</p>
<pre><code class="java">package com.practice.springcloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope
public class ConfigClientController
&#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String configInfo()
    &#123;
        return &quot;serverPort: &quot;+serverPort+&quot;\t\n\n configInfo: &quot;+configInfo;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="8-1-设计思想"><a href="#8-1-设计思想" class="headerlink" title="8.1 设计思想"></a>8.1 设计思想</h3><ul>
<li>第一种：利用消息总线触发一个客户端/bus/refresh，从而刷新所有客户端的配置</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321140549541.png" alt="image-20210321140549541"></p>
<ul>
<li>第二种：利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端配置(通知总控，再通知其他)</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321140638891.png" alt="image-20210321140638891"></p>
<p><strong>第二种更加合适，第一种不合适，原因：</strong></p>
<ul>
<li>打破了微服务的职责单一性，因为微服务本事是业务模块，它本不应该承担配置刷新的职责。</li>
<li>破坏了微服务各节点的对等性</li>
<li>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，就会增加更多的修改</li>
</ul>
<h3 id="8-2-实现"><a href="#8-2-实现" class="headerlink" title="8.2 实现"></a>8.2 实现</h3><p>给cloud-config-center-3344配置中心<strong>服务端</strong>添加消息总线支持</p>
<ul>
<li><p>POM，增加总线支持依赖</p>
<pre><code class="xml">&lt;!--添加消息总线RabbitMQ支持--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li><p>yml</p>
<pre><code class="yml">server:
  port: 3344

spring:
  application:
    name:  cloud-config-center #注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
#          uri: git@github.com:wyc1228/springcloud-config.git #GitHub上面的git仓库名字
          uri: https://github.com/wyc1228/springcloud-config.git #GitHub上面的git仓库名字
          ####搜索目录
          search-paths:
            - springcloud-config
          ####读取分支
          force-pull: true #配置为true表示如果本地副本是脏的，将使Spring Cloud Config Server强制从远程存储库拉取配置
          username: wyc1228
          password: wyc199712285415
      label: main
#rabbitmq相关配置 15672是web管理界面的端口，5672是MQ访问的端口
  rabbitmq:
    host: 192.168.127.7
    port: 5672
    username: guest
    password: guest
#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

##rabbitmq相关配置,暴露bus刷新配置的端点
management:
  endpoints: #暴露bus刷新配置的端点
    web:
      exposure:
        include: &#39;bus-refresh&#39;
</code></pre>
</li>
</ul>
<p>给cloud-config-center-3355<strong>客户端</strong>添加消息总线的支持</p>
<ul>
<li><p>POM</p>
<pre><code class="xml">&lt;!--添加消息总线RabbitMQ支持--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li><p>YML</p>
<pre><code class="yml">server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: main #分支名称
      name: config #配置文件名称
      profile: test #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 #配置中心地址k

#rabbitmq相关配置 15672是web管理界面的端口，5672是MQ访问的端口
  rabbitmq:
    host: 192.168.127.7
    port: 5672
    username: guest
    password: guest

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

##rabbitmq相关配置,暴露bus刷新配置的端点
management:
  endpoints: #暴露bus刷新配置的端点
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
</li>
</ul>
<p>给cloud-config-center-3366<strong>客户端</strong>添加消息总线的支持</p>
<ul>
<li>POM，YML一样的配置</li>
</ul>
<h3 id="8-3-测试"><a href="#8-3-测试" class="headerlink" title="8.3 测试"></a>8.3 测试</h3><p>运维工程师修改GitHub上的配置文件增加版本号</p>
<p>运维工程师发送POST请求，</p>
<p>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh&quot;">http://localhost:3344/actuator/bus-refresh&quot;</a></p>
<p>一次发送，处处生效</p>
<p>此时。启动7001,3344,3355,3366</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321145646682.png" alt="image-20210321145646682"></p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321145659360.png" alt="image-20210321145659360"></p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321145719641.png" alt="image-20210321145719641"></p>
<p>修改Git配置文件</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150123846.png" alt="image-20210321150123846"></p>
<ul>
<li>此时3344，未重启刷新完成</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150609160.png" alt="image-20210321150609160"></p>
<ul>
<li>而3355和3366刷新不了</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150635034.png" alt="image-20210321150635034"></p>
<ul>
<li>输入POST请求</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150735309.png" alt="image-20210321150735309"></p>
<ul>
<li>再次刷新3355和3366，发现<strong>都能刷新成功</strong>，这就是全局通知</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150802509.png" alt="image-20210321150802509"></p>
<ul>
<li>此时查看RabbitMQ，发现有bus</li>
</ul>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321150940822.png" alt="image-20210321150940822"></p>
<h2 id="9、Bus动态刷新定点通知"><a href="#9、Bus动态刷新定点通知" class="headerlink" title="9、Bus动态刷新定点通知"></a>9、Bus动态刷新定点通知</h2><p>不想全部通知，只想定点通知，例如只通知3355，不通知3366</p>
<p>指定一个具体事例生效而不是全部，公式</p>
<ul>
<li><a href="http://localhost:配置中心端口号/actuator/bus-refresh/{destination}">http://localhost:配置中心端口号/actuator/bus-refresh/{destination}</a></li>
<li>/bus/refresh请求不再发送到具体的服务实例上,而是发给config server并通过destination参数类指定需要重新配置的服务或实例</li>
</ul>
<p>我们这里以刷新运行在3355端口上的config-client为例</p>
<ul>
<li>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;">http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;</a></li>
</ul>
<p>总结：</p>
<p><img src="/2021/03/03/SpringCloud-07/image-20210321151902459.png" alt="image-20210321151902459"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-08(Stream消息驱动/Sleuth链路跟踪)</title>
    <url>/2020/03/10/SpringCloud-08/</url>
    <content><![CDATA[<h1 id="SpringCloud-08"><a href="#SpringCloud-08" class="headerlink" title="SpringCloud-08"></a>SpringCloud-08</h1><h2 id="1、Stream消息驱动"><a href="#1、Stream消息驱动" class="headerlink" title="1、Stream消息驱动"></a>1、Stream消息驱动</h2><p>什么是Spring Cloud Stream？</p>
<ul>
<li><p>官方定义Spring Cloud Stream 是一个构件微消息驱动微服务的框架</p>
</li>
<li><p>应用程序通过<code>inputs</code>或者<code>outputs</code>来与Spring Cloud Stream中的binder对象交互。</p>
</li>
<li><p>通过我们配置来binding(绑定)，而Spring Cloud Stream的binder对象负责与消息中间件交互。</p>
</li>
<li><p>所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式</p>
</li>
</ul>
<p>通过使用Spring Integration来连接消息代理中间件以试下消息事件驱动。</p>
<p>Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p>
<p><strong>目前仅支持RabbitMQ、Kafka</strong></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321160542463.png" alt="image-20210321160542463"></p>
<p><strong>总结：</strong></p>
<ul>
<li>屏蔽底层信息中间件的差异,降低切换成本,统一消息的编程模型</li>
</ul>
<p><strong>官网：</strong></p>
<p><a href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a></p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/</a></p>
<p>Stream中文指导手册：<a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">https://m.wang1314.com/doc/webapp/topic/20971999.html</a></p>
<h2 id="2、设计思想"><a href="#2、设计思想" class="headerlink" title="2、设计思想"></a>2、设计思想</h2><p>标准的MQ</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321160950884.png" alt="image-20210321160950884"></p>
<ul>
<li>生产者/消费者之间靠消息媒介传递消息内容（Message）</li>
<li>消息必须走特定的通道（消息通道MessageChannel）</li>
<li>消息通道里的消息如何被消费呢,谁负责收发处理<ul>
<li>消息通道MessageChannel的子接口SubscribableChannel,由MessageHandler消息处理器所订阅</li>
</ul>
</li>
</ul>
<h3 id="2-1-为什么要用Cloud-Stream"><a href="#2-1-为什么要用Cloud-Stream" class="headerlink" title="2.1 为什么要用Cloud Stream"></a>2.1 为什么要用Cloud Stream</h3><p>比如说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321161426685.png" alt="image-20210321161426685"></p>
<p>这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大推东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候SpringCloud Stream给我们提供了一种解耦合的方式</p>
<h3 id="2-2-Stream为什么可以统一底层差异"><a href="#2-2-Stream为什么可以统一底层差异" class="headerlink" title="2.2 Stream为什么可以统一底层差异"></a>2.2 Stream为什么可以统一底层差异</h3><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行消息交互的时候，由于各消息中间件构建的初衷不同，他们的实现细节上会有较大的差异性</p>
<p>通过定义绑定器作为中间层，完美的实现了<strong>应用程序与消息中间件细节之间的隔离</strong>。</p>
<p>通过向应用程序暴露统一的Channel通道，使得应用程序不需要考虑各种不同的消息中间件的实现</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321162555867.png" alt="image-20210321162555867"></p>
<h3 id="2-3-Binder"><a href="#2-3-Binder" class="headerlink" title="2.3 Binder"></a>2.3 Binder</h3><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美的实现了<strong>应用程序与消息中间件细节之间的隔离</strong>。</p>
<p>Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至与动态的切换中间件(rabbitmq切换kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321163215802.png" alt="image-20210321163215802"></p>
<p><strong>通过定义绑定器作为中间层，完美的实现了应用程序与消息中间件细节之间的隔离</strong>。</p>
<ul>
<li><strong>input对应消费者</strong></li>
<li><strong>output对应生产者</strong></li>
</ul>
<h3 id="2-4-通信方式"><a href="#2-4-通信方式" class="headerlink" title="2.4 通信方式"></a>2.4 通信方式</h3><p><strong>Stream中的消息通信方式遵循了发布-订阅模式</strong></p>
<ul>
<li>topic主题进行广播<ul>
<li>在ribbitmq就是Exchange</li>
<li>在kafka中就是topic</li>
</ul>
</li>
</ul>
<h2 id="3、Stream标准流程套路"><a href="#3、Stream标准流程套路" class="headerlink" title="3、Stream标准流程套路"></a>3、Stream标准流程套路</h2><p><img src="/2020/03/10/SpringCloud-08/image-20210321171518926.png" alt="image-20210321171518926"></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321171508230.png" alt="image-20210321171508230"></p>
<p><strong>Binder</strong></p>
<ul>
<li>很方便的连接中间件,屏蔽差异</li>
</ul>
<p><strong>Channel</strong></p>
<ul>
<li>通道,是队列Queue的一种抽象,在消息通讯系统中就是实现存储和转发的媒介,通过Channel对队列进行配置</li>
</ul>
<p><strong>Source和Sink</strong></p>
<ul>
<li>简单的可理解为参考对象是Spring Cloud Stream的自身,从Stream发布信息就是输出,接受消息就是输入</li>
</ul>
<h2 id="4、常用注解"><a href="#4、常用注解" class="headerlink" title="4、常用注解"></a>4、常用注解</h2><p><img src="/2020/03/10/SpringCloud-08/image-20210321163730080.png" alt="image-20210321163730080"></p>
<h2 id="5、消息驱动之生产者"><a href="#5、消息驱动之生产者" class="headerlink" title="5、消息驱动之生产者"></a>5、消息驱动之生产者</h2><p>说明：本案例将要建三个模块，前提是RabbitMQ环境ok</p>
<ul>
<li>cloud-stream-rabbitmq-provider8801,作为生产者进行发消息模块</li>
<li>cloud-stream-rabbitmq-consumer8802,作为消息接收模块</li>
<li>cloud-stream-rabbitmq-consumer8803,作为消息接收模块</li>
</ul>
<h3 id="5-1-新建Module"><a href="#5-1-新建Module" class="headerlink" title="5.1 新建Module"></a>5.1 新建Module</h3><ul>
<li>cloud-stream-rabbitmq-provider8801</li>
</ul>
<h3 id="5-2-POM文件"><a href="#5-2-POM文件" class="headerlink" title="5.2 POM文件"></a>5.2 POM文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--基础配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="5-3-YML文件"><a href="#5-3-YML文件" class="headerlink" title="5.3 YML文件"></a>5.3 YML文件</h3><pre><code class="yml">server:
  port: 8801

spring:
  application:
    name: cloud-stream-provider
  rabbitmq:
    host: 192.168.127.7
    port: 5672
    username: guest
    password: guest
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
      bindings: # 服务的整合处理
        output: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置

eureka:
  client: # 客户端进行Eureka注册的配置
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）
    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）
    instance-id: send-8801.com  # 在信息列表时显示主机名称
    prefer-ip-address: true     # 访问的路径变为IP地址
</code></pre>
<p><strong>注意：</strong>binder: defaultRabbit配置变红无影响</p>
<blockquote>
<p><strong>视频里的application.yml使用了spring.cloud.stream.binders.defaultRabbit.environment.spring.rabbitmq.xx来配置rabbitmq的环境，如果你是用的其他服务器上的rabbitmq，比如我使用的是linux服务器来运行rabbitmq。</strong><br><strong>按照视频中的配置方式的话，启动时会试图连接两次rabbitmq程序</strong><br><strong>第一次试图连接访问的就是application.yml中配置的地址，此时已经订阅成功了，但是程序还会在之后进行第二次连接，此时访问的地址就是localhost:5672，在我的环境中，我本地没有rabbitmq环境，所以直接报IOException。</strong></p>
<p><strong>所以，如果是使用的自己的服务器来配置，则需要修改配置文件，将rabbitmq的配置信息移动到application.yml中的spring节点下修改后的配置如上述代码</strong></p>
</blockquote>
<h3 id="5-4-业务类："><a href="#5-4-业务类：" class="headerlink" title="5.4 业务类："></a>5.4 业务类：</h3><ul>
<li>发送消息接口</li>
</ul>
<pre><code class="java">package com.practice.springcloud.service;

public interface IMessageProvider &#123;
    public String send();
&#125;
</code></pre>
<ul>
<li>发送消息接口实现类：</li>
</ul>
<pre><code class="java">package com.practice.springcloud.service.impl;

import com.practice.springcloud.service.IMessageProvider;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.messaging.MessageChannel;

import javax.annotation.Resource;
import java.util.UUID;


@EnableBinding(Source.class) //定义消息的推送管道
public class MessageProviderImpl implements IMessageProvider &#123;

    @Resource
    private MessageChannel output; //消息发送管道

    @Override
    public String send() &#123;
        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build()); //官网有
        System.out.println(&quot;****serial:&quot;+serial);
        return null;
    &#125;
&#125;
</code></pre>
<ul>
<li>Controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.service.IMessageProvider;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
public class SendMessageController &#123;
    @Resource
    private IMessageProvider messageProvider;

    @GetMapping(value = &quot;/sendMessage&quot;)
    public String sendMessage()&#123;
        return messageProvider.send();

    &#125;
&#125;
</code></pre>
<h3 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5 测试"></a>5.5 测试</h3><p>启动7001，启动RabbitMQ，<a href="http://localhost:15672/">http://localhost:15672/</a></p>
<p>启动8801：<a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321193654961.png" alt="image-20210321193654961"></p>
<p>多次刷新此地址会发现波峰流量变动：</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321193732838.png" alt="image-20210321193732838"><img src="/2020/03/10/SpringCloud-08/image-20210321193822743.png" alt="image-20210321193822743"></p>
<h2 id="6、-消息驱动之消费者"><a href="#6、-消息驱动之消费者" class="headerlink" title="6、 消息驱动之消费者"></a>6、 消息驱动之消费者</h2><h3 id="6-1-新建Module"><a href="#6-1-新建Module" class="headerlink" title="6.1 新建Module"></a>6.1 新建Module</h3><ul>
<li>cloud-stream-rabbitmq-consumer8802</li>
</ul>
<h3 id="6-2-POM"><a href="#6-2-POM" class="headerlink" title="6.2 POM"></a>6.2 POM</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8802&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="6-3-YML"><a href="#6-3-YML" class="headerlink" title="6.3 YML"></a>6.3 YML</h3><pre><code class="yml">server:
  port: 8802

spring:
  application:
    name: cloud-stream-consumer
  rabbitmq:
    host: 192.168.127.7
    port: 5672
    username: guest
    password: guest
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitMQ的服务信息
        defaultRabbit: # 表示定义的名称，用于binding的整合
          type: rabbit # 消息中间件类型
      bindings: # 服务的整合处理
        input: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的exchange名称定义
          content-type: application/json # 设置消息类型，本次为json，文本则设为text/plain
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置

eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 # 设置心跳的间隔时间，默认30
    lease-expiration-duration-in-seconds: 5 # 超过5秒间隔，默认90
    instance-id: receive-8802.com #主机名
    prefer-ip-address: true # 显示ip
</code></pre>
<h3 id="6-4-主启动"><a href="#6-4-主启动" class="headerlink" title="6.4 主启动"></a>6.4 主启动</h3><ul>
<li>和8801一致</li>
</ul>
<h3 id="6-5-业务类"><a href="#6-5-业务类" class="headerlink" title="6.5 业务类"></a>6.5 业务类</h3><pre><code class="java">package com.practice.springcloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Component;

@Component
@EnableBinding(Sink.class)
public class ReceiveMessageListenerController &#123;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @StreamListener(Sink.INPUT)
    public void input(Message&lt;String&gt; message)&#123;
        System.out.println(&quot;消费者1号，----------》接收到的消息：&quot;+message.getPayload()+&quot;\t Port: &quot;+serverPort);

    &#125;
&#125;
</code></pre>
<h3 id="6-6-测试"><a href="#6-6-测试" class="headerlink" title="6.6 测试"></a>6.6 测试</h3><p>启动7001，启动RabbitMQ，启动8801，启动8802</p>
<p>输入地址：<a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<p>此时8801发送了消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321200346701.png" alt="image-20210321200346701"></p>
<p>8802也接收到了消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321200408829.png" alt="image-20210321200408829"></p>
<p>RabbitMQ也产生了波峰</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321200450579.png" alt="image-20210321200450579"></p>
<h2 id="7、分组消费与持久化"><a href="#7、分组消费与持久化" class="headerlink" title="7、分组消费与持久化"></a>7、分组消费与持久化</h2><p>依照8802，创建8803</p>
<p>启动7001,8801,8802,8803，查看Eureka服务注册中心，发现8801服务发送者，8802和8803服务消费者都注册进来了</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321201514126.png" alt="image-20210321201514126"></p>
<p>运行后存在两个问题</p>
<ul>
<li>有重复消费问题</li>
<li>消息持久化问题</li>
</ul>
<p>运行<a href="http://localhost:8801/sendMessage%EF%BC%8C%E5%8F%91%E9%80%81%E4%B8%A4%E6%9D%A1%E6%B6%88%E6%81%AF(%E5%88%B7%E6%96%B0%E4%B8%A4%E4%B8%8B)">http://localhost:8801/sendMessage，发送两条消息(刷新两下)</a></p>
<p>此时8801发送两条数据</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321201912987.png" alt="image-20210321201912987"></p>
<p>而8802消费了2条</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321201945445.png" alt="image-20210321201945445"></p>
<p>并且8803也消费了两条</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321202015835.png" alt="image-20210321202015835"></p>
<p>此时出现消息重复消费问题，要如何解决？</p>
<p><strong>使用分组和持久化属性group解决</strong></p>
<h3 id="7-1-生产者实际案例"><a href="#7-1-生产者实际案例" class="headerlink" title="7.1 生产者实际案例"></a>7.1 生产者实际案例</h3><p><img src="/2020/03/10/SpringCloud-08/image-20210321202211214.png" alt="image-20210321202211214"></p>
<p><strong>不同组是可以全面消费的(重复消费)</strong></p>
<p><strong>同一个组内会发生竞争关系，只有其中一个可以消费</strong></p>
<p>故障现象：重复消费</p>
<p>导致原因：默认分组group是不同的，组流水号不一样，被认为不同组，可以消费</p>
<p>自定义配置分组，自定义配置分为同一个组，解决重复消费问题</p>
<p><strong>分组的原理：</strong></p>
<ul>
<li>微服务应用放置于同一个group中,就能保证消息只会被其中一个应用消费一次.  <strong>不同的组是可以消费的,同一个组内会发生竞争关系,只有其中一个可以消费</strong></li>
</ul>
<p><strong>将8802和8803分为不同的组PracticeA，PracticeB（可以消费）</strong></p>
<ul>
<li>8802分到PracticeA组</li>
</ul>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321203627268.png" alt="image-20210321203627268"></p>
<ul>
<li>同理，8803分到PracticeB组只需要加这个配置就可以</li>
</ul>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321203741432.png" alt="image-20210321203741432"></p>
<ul>
<li>此时，可以在RabbitMQ中看到这两个组</li>
</ul>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321204019042.png" alt="image-20210321204019042"></p>
<p>分布式微服务应用为了实现高可用和负载均衡，实际上都会部署多个实例，本例启动了两个消费微服务(8802/8803)。</p>
<p>多数情况，生产者发送消息给某个具体微服务时只希望被消费一次，按照上面我们启动两个应用的例子，虽然他们同属于一个应用，但是这个消息出现了被重复消费两次的情况，为了解决这个问题，在Spring Cloud Stream中提供了消费组的概念</p>
<p><strong>如何解决重复消费</strong></p>
<p>8802/8803实现轮询分组，每次只有一个消费者，8801模块发的消息只能被8802或8803其中一个接收到，这样就避免了重复消费。</p>
<p>所以8802/8803都变成相同组，group两个相同，都放入PracticeA组</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321204849366.png" alt="image-20210321204849366"></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321204921445.png" alt="image-20210321204921445"></p>
<p>此时发送两条消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321205105742.png" alt="image-20210321205105742"></p>
<p>8802接收到1条消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321205123337.png" alt="image-20210321205123337"></p>
<p>8803接收到1条</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321205141387.png" alt="image-20210321205141387"></p>
<p>结论：<strong>同一个组的多个微服务实例,每次只会有一个拿到</strong></p>
<h3 id="7-2-消费持久化"><a href="#7-2-消费持久化" class="headerlink" title="7.2 消费持久化"></a>7.2 消费持久化</h3><p>停止8802/8803并去除掉<strong>8802的分组group：PracticeA</strong>，<strong>不要去掉8803的group</strong></p>
<p>8801先发送4条消息到rabbitmq</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321210200306.png" alt="image-20210321210200306"></p>
<p>先启动8802，无分组属性配置，后台没有打出来消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321210341175.png" alt="image-20210321210341175"></p>
<p>再启动8803，有分组属性配置，后台打出来了MQ上的消息</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210321210330815.png" alt="image-20210321210330815"></p>
<p>由此可见：有分组属性，会自动进行消费持久化</p>
<h2 id="8、SpringCloud-Sleuth请求链路跟踪"><a href="#8、SpringCloud-Sleuth请求链路跟踪" class="headerlink" title="8、SpringCloud Sleuth请求链路跟踪"></a>8、SpringCloud Sleuth请求链路跟踪</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p><strong>为何会出现此技术，有何作用？</strong></p>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求的失败</p>
<p><strong>Sleuth链路跟踪是什么？</strong></p>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></li>
<li>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案</li>
<li>在分布式系统中提供了追踪解决方案并且兼容支持了zipkin</li>
</ul>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322083925373.png" alt="image-20210322083925373"></p>
<ul>
<li>当产品模块去调用库存模块，Zipkin就记录下来并以网页的形式展现出来</li>
</ul>
<p>Sleuth和Zipkin：Sleuth用来收集整理，Zipkin用来展现</p>
<h3 id="8-2-搭建链路监控"><a href="#8-2-搭建链路监控" class="headerlink" title="8.2 搭建链路监控"></a>8.2 搭建链路监控</h3><p>Zipkin下载安装：</p>
<p>SpringCloud从F版已不需要自己搭建Zipkin Server了,只需调用jar包即可</p>
<p><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></p>
<p>zipkin-server-2.12.9-exec.jar</p>
<p>运行jar(在jar包所在的路径)</p>
<p>java -jar zipkin-server-2.12.9-exec.jar</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322085734859.png" alt="image-20210322085734859"></p>
<p>运行控制台（相当于前端页面）</p>
<p><a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322085852979.png" alt="image-20210322085852979"></p>
<p>术语：</p>
<p>完整的调用链路图：</p>
<p>表示一请求链路，一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id关联起来</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322090104252.png" alt="image-20210322090104252"></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322090416872.png" alt="image-20210322090416872"></p>
<p>Trace:类似于树结构的Span集合,表示一条调用链路,存在唯一标识</p>
<p>span:表示调用链路来源,通俗的理解span就是一次请求信息</p>
<h3 id="8-3-服务提供者"><a href="#8-3-服务提供者" class="headerlink" title="8.3 服务提供者"></a>8.3 服务提供者</h3><p>以<code>cloud-provider-payment8001</code>为例</p>
<p>增加POM依赖</p>
<pre><code class="xml">&lt;!--包含了sleuth+zipkin--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>可以看到Zipkin中包含Sleuth</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322091131284.png" alt="image-20210322091131284"></p>
<p>修改YML文件</p>
<pre><code class="yml">spring:
  application:
    name: cloud-order-service
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
    #采样率值介于 0 到 1 之间，1 则表示全部采集
      probability: 1
</code></pre>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322091405690.png" alt="image-20210322091405690"></p>
<p>业务类中加一段代码</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322092129287.png" alt="image-20210322092129287"></p>
<h3 id="8-4-服务消费者"><a href="#8-4-服务消费者" class="headerlink" title="8.4 服务消费者"></a>8.4 服务消费者</h3><p>以<code>cloud-consumer-order80</code>为例</p>
<p>改POM</p>
<pre><code class="xml">&lt;!--包含了sleuth+zipkin--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>改yml</p>
<pre><code class="yml">spring:
  application:
    name: cloud-payment-service

  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
    #采样率值介于 0 到 1 之间，1 则表示全部采集
      probability: 1
</code></pre>
<p>业务类Controller中加一段代码</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322092844786.png" alt="image-20210322092844786"></p>
<h3 id="8-5-测试"><a href="#8-5-测试" class="headerlink" title="8.5 测试"></a>8.5 测试</h3><p>启动7001,8001，80</p>
<p>输入<a href="http://localhost/consumer/payment/zipkin">http://localhost/consumer/payment/zipkin</a></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322094140646.png" alt="image-20210322094140646"></p>
<p>查看Zipkin页面</p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322094242418.png" alt="image-20210322094242418"></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322094444227.png" alt="image-20210322094444227"></p>
<p><img src="/2020/03/10/SpringCloud-08/image-20210322094511931.png" alt="image-20210322094511931"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-09(nacos服务注册与配置中心)</title>
    <url>/2021/03/15/SpringCloud-09/</url>
    <content><![CDATA[<h1 id="SpringCloud-09"><a href="#SpringCloud-09" class="headerlink" title="SpringCloud-09"></a>SpringCloud-09</h1><h2 id="1、SpringCloud-alibaba"><a href="#1、SpringCloud-alibaba" class="headerlink" title="1、SpringCloud alibaba"></a>1、SpringCloud alibaba</h2><p><strong>为什么会出现SpringCloud alibaba？</strong></p>
<ul>
<li><p>Spring Cloud Netflix 项目进入维护模式</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322100046684.png" alt="image-20210322100046684"></p>
</li>
<li><p>进入维护模式意味着Spring Cloud Netflix将不再开发新组件，目前以至以后一段时间Spring Cloud Netflix提供的服务和功能就这么多了，不再开发新的组件和功能了</p>
</li>
</ul>
<p><strong>SpringCloud alibaba概述</strong></p>
<p>2018.10.31，Spring Cloud Alibaba 正式入驻了Spring Cloud官方孵化器，并在Maven中央仓库发布了第一个版本。</p>
<p>功能：</p>
<ul>
<li>服务限流降级：默认支持Servlet，Fegin，RestTemplate，Dubbo和RocketMQ限流降级功能的接入，可以运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metric监控</li>
<li>服务注册与发现：适配Spring Cloud服务注册与发现标准，默认集成了Ribbon的支持</li>
<li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li>消息驱动能力：基于Spring Cloud Stream为微服务应用构建消息驱动能力。</li>
<li>阿里云对象存储：阿里云提供海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间，任何地点存储和访问任意类型的数据</li>
<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于Cron表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker（schedulerx-client）上执行</li>
</ul>
<p><strong>下载地址：</strong></p>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<p>Spring Cloud Alibaba的组件</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322102805572.png" alt="image-20210322102805572"></p>
<p><strong>资料：</strong></p>
<p>官网：<a href="https://spring.io/projects/spring-cloud-alibaba">https://spring.io/projects/spring-cloud-alibaba</a></p>
<p>英文：</p>
<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a></li>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a></li>
</ul>
<p>中文：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<h2 id="2、Nacos服务注册与配置中心"><a href="#2、Nacos服务注册与配置中心" class="headerlink" title="2、Nacos服务注册与配置中心"></a>2、Nacos服务注册与配置中心</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Nacos前四个字母为Nameing和Configuration的前两个字母,最后的s为Service</p>
<p>Nacos是什么？</p>
<ul>
<li>一个更易于构建原生应用的动态服务发现、配置管理和服务管理平台</li>
<li>Nacos就是注册中心+配置中心的组合</li>
<li>等价于：Nacos=Eureka+Config+Bus</li>
</ul>
<p>Nacos能干什么？</p>
<ul>
<li>替代Eureka做服务注册中心</li>
<li>替代Config做服务配置中心</li>
</ul>
<p>各注册中心对比</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322103818099.png" alt="image-20210322103818099"></p>
<p>Nacos下载地址：</p>
<ul>
<li><a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a></li>
</ul>
<p>官方文档：</p>
<ul>
<li><p><a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p>
</li>
<li><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery</a></p>
</li>
</ul>
<h3 id="2-2-Nacos下载安装"><a href="#2-2-Nacos下载安装" class="headerlink" title="2.2 Nacos下载安装"></a>2.2 Nacos下载安装</h3><p>我使用的是1.1.4版本</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322110311951.png" alt="image-20210322110311951"></p>
<p>解压后使用cmd运行startup.cmd</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322110355345.png" alt="image-20210322110355345"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322110436642.png" alt="image-20210322110436642"></p>
<p>之后再web端查看界面<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p>
<p>用户名，密码都是Nacos，出现此界面则安装成功</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322110600561.png" alt="image-20210322110600561"></p>
<h2 id="3、Nacos作为服务注册中心"><a href="#3、Nacos作为服务注册中心" class="headerlink" title="3、Nacos作为服务注册中心"></a>3、Nacos作为服务注册中心</h2><p>官方文档：</p>
<p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery</a></p>
<h3 id="3-1-基于Nacos的服务提供者"><a href="#3-1-基于Nacos的服务提供者" class="headerlink" title="3.1 基于Nacos的服务提供者"></a>3.1 基于Nacos的服务提供者</h3><p>建Module</p>
<ul>
<li>cloudalibaba-provider-payment9001</li>
</ul>
<p>改POM</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-provider-payment9001&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud ailibaba nacos --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringBoot整合Web组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--日常通用jar包配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>建YML</p>
<pre><code class="yml">server:
  port: 9001

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #配置Nacos地址

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<p>主启动类</p>
<pre><code class="java">@EnableDiscoveryClient
@SpringBootApplication
public class PaymentMain9001
&#123;
    public static void main(String[] args) &#123;
            SpringApplication.run(PaymentMain9001.class, args);
    &#125;
&#125;
</code></pre>
<p>业务类controller</p>
<pre><code class="java">package com.practice.springcloud.alibaba.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PaymentController
&#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)
    public String getPayment(@PathVariable(&quot;id&quot;) Integer id)
    &#123;
        return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\t id&quot;+id;
    &#125;
&#125;
</code></pre>
<p>测试，启动9001，查看Nacos服务列表，发现9001已经注册进Nacos</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322133414235.png" alt="image-20210322133414235"></p>
<p>为了演示Nacos负载均衡，依照9001建9002</p>
<p>如不想重复建Module，可以直接拷贝虚拟端口映射</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322140815930.png" alt="image-20210322140815930"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322141049864.png" alt="image-20210322141049864"></p>
<p>注意：此时并未新建项目，启动9011后相当于启动9001只是端口变动了</p>
<h3 id="3-2-基于Nacos的服务消费者"><a href="#3-2-基于Nacos的服务消费者" class="headerlink" title="3.2 基于Nacos的服务消费者"></a>3.2 基于Nacos的服务消费者</h3><p>Nacos自带负载均衡</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322142323926.png" alt="image-20210322142323926"></p>
<p>建Module</p>
<ul>
<li>cloudalibaba-consumer-nacos-order83</li>
</ul>
<p>改POM</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-consumer-nacos-order83&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud ailibaba nacos --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringBoot整合Web组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--日常通用jar包配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>改YML</p>
<pre><code class="yml">server:
  port: 83


spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848


#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)
service-url:
  nacos-user-service: http://nacos-payment-provider
</code></pre>
<p>主启动类：</p>
<pre><code class="java">package com.practice.springcloud.alibaba;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class OrderNacosMain83
&#123;
    public static void main(String[] args)
    &#123;
        SpringApplication.run(OrderNacosMain83.class,args);
    &#125;
&#125;
</code></pre>
<p>业务类：</p>
<p>config</p>
<pre><code class="java">package com.practice.springcloud.alibaba.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig
&#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate()
    &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<p>controller</p>
<pre><code class="java">package com.practice.springcloud.alibaba.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderNacosController
&#123;
    @Resource
    private RestTemplate restTemplate;

    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)
    private String serverURL;

    @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)
    public String paymentInfo(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class);
    &#125;

&#125;
</code></pre>
<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p>启动9001,9002,83</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322143626836.png" alt="image-20210322143626836"></p>
<p>查看Nacos</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322143707666.png" alt="image-20210322143707666"></p>
<p>83访问9001和9002，交替切换，轮询，负载均衡OK</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322143812180.png" alt="image-20210322143812180"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322143827498.png" alt="image-20210322143827498"></p>
<h3 id="3-4-各注册中心对比"><a href="#3-4-各注册中心对比" class="headerlink" title="3.4 各注册中心对比"></a>3.4 各注册中心对比</h3><p>Nacos和CAP</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322144517809.png" alt="image-20210322144517809"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322144523551.png" alt="image-20210322144523551"></p>
<p>Nacos支持AP和CP模式的切换</p>
<ul>
<li><p>C是所有节点在同一时间看到的数据是一致的</p>
</li>
<li><p>A的定义是所有请求都会收到响应</p>
</li>
</ul>
<p>何时选择使用何种方式？</p>
<p>如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，就可以选择AP模式。当前主流的服务如Spring Cloud 和Dubbo服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例</p>
<p>如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务适用于CP模式。</p>
<p>CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误</p>
<h2 id="4、Nacos作为配置中心"><a href="#4、Nacos作为配置中心" class="headerlink" title="4、Nacos作为配置中心"></a>4、Nacos作为配置中心</h2><h3 id="4-1-Nacos作为配置中心-基础配置"><a href="#4-1-Nacos作为配置中心-基础配置" class="headerlink" title="4.1 Nacos作为配置中心-基础配置"></a>4.1 Nacos作为配置中心-基础配置</h3><p>新建Module：<code>cloudalibaba-config-nacos-client3377</code></p>
<p>建POM：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-config-nacos-client3377&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--nacos-config--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--nacos-discovery--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--web + actuator--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--一般基础配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>建YML，配置两个</p>
<p>Nacos同SpringCloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目正常启动。</p>
<p>SpringBoot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application</p>
<p>bootstrap.yml</p>
<pre><code class="yml"># nacos配置
server:
  port: 3377

spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置
</code></pre>
<p>application.yml</p>
<pre><code class="yml">spring:
  profiles:
    active: dev # 表示开发环境
    #active: test # 表示测试环境
    #active: info
</code></pre>
<p>主启动类</p>
<pre><code class="java">package com.practice.springcloud.alibaba;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class NacosConfigClientMain3377
&#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(NacosConfigClientMain3377.class, args);
    &#125;
&#125;
</code></pre>
<p>业务类：controller</p>
<pre><code class="java">package com.practice.springcloud.alibaba.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope //支持Nacos的动态刷新功能。通过Spring Cloud原生注解 @RefreshScope实现配置自动更新
public class ConfigClientController
&#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/config/info&quot;)
    public String getConfigInfo() &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
<h3 id="4-2-Nacos中配置规则"><a href="#4-2-Nacos中配置规则" class="headerlink" title="4.2 Nacos中配置规则"></a>4.2 Nacos中配置规则</h3><p>理论：</p>
<p>Nacos中dataid的组成格式及与SpringBoot配置文件中的匹配规则</p>
<p>官网：<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322152616288.png" alt="image-20210322152616288"></p>
<p>最后公式：<br><img src="/2021/03/15/SpringCloud-09/image-20210322153117688.png" alt="image-20210322153117688">实操：</p>
<p>添加配置</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322153249344.png" alt="image-20210322153249344"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322160145384.png" alt="image-20210322160145384"></p>
<p>设置DataId总结：</p>
<p>公式：${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322153904594.png" alt="image-20210322153904594"></p>
<h3 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h3><ul>
<li>启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件</li>
<li>运行3377，调用接口查看配置信息</li>
<li><a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322160322963.png" alt="image-20210322160322963"></p>
<p>自带动态刷新</p>
<ul>
<li>修改下Nacos中的yaml配置文件,再次调用查看配置的接口,就会发现配置已经刷新</li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322160631571.png" alt="image-20210322160631571"></p>
<h3 id="4-4-Nacos作为配置中心-分类配置"><a href="#4-4-Nacos作为配置中心-分类配置" class="headerlink" title="4.4 Nacos作为配置中心-分类配置"></a>4.4 Nacos作为配置中心-分类配置</h3><p>多环境多项目管理：</p>
<p>实际开发中，通常一个系统会准备</p>
<ul>
<li>dev开发环境</li>
<li>test测试环境</li>
<li>prod生产环境</li>
</ul>
<p>如何保证指定环境启动时服务能正确读取到Nacos上相关环境的配置文件呢？</p>
<p>一个大型分布式微服务系统会有很多微服务子项目，每个微服务又都会有相应的开发环境，测试环境，预发环境，正式环境，如何对这些微服务配置进行管理呢？</p>
<p><strong>Nacos图形化管理界面</strong></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322161354476.png" alt="image-20210322161354476"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322161453939.png" alt="image-20210322161453939"></p>
<p>图形化界面管理使用了namespace+Group+Data ID</p>
<ul>
<li><p>类似java里面的package名和类名</p>
</li>
<li><p>最外层的namespace是可以区分部署环境的，Group和DataID逻辑上区分两个目标对象</p>
</li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322161826412.png" alt="image-20210322161826412"></p>
<p>默认情况下：</p>
<ul>
<li>NameSpace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT</li>
<li>Nacos默认的命名空间是public，NameSpace主要用来实现隔离</li>
<li>比如我们现在有三个环境：开发，测试，生产环境，我们就可以创建三个NameSpace，不同的NameSpace之间是隔离的</li>
<li>Group默认是Group=DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</li>
</ul>
<p>Service就是微服务；一个Service可以包含多个Cluster(集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。</p>
<ul>
<li>比如说为了容灾，将Service微服务分别部署在两个机房，这样就可以给两个机房的微服务各起一个集群名称，还可以让同一个机房的微服务互相调用，以提升性能</li>
</ul>
<h3 id="4-5-三种方式加载配置"><a href="#4-5-三种方式加载配置" class="headerlink" title="4.5 三种方式加载配置"></a>4.5 三种方式加载配置</h3><p><strong>DataID方案：</strong></p>
<p>指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置</p>
<p>默认空间+默认分组+新建dev和test两个DataId</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322163607013.png" alt="image-20210322163607013"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322163621861.png" alt="image-20210322163621861"></p>
<p>通过spring.profile.active属性就能进行多环境下配置文件的读取，配置是什么就加载什么</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322163914760.png" alt="image-20210322163914760"></p>
<p>此时，刷新地址：<a href="http://localhost:3377/config/info%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%8F%98%E4%B8%BAtest">http://localhost:3377/config/info，配置变为test</a></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322164628660.png" alt="image-20210322164628660"></p>
<p><strong>Group方案：</strong></p>
<p>通过Group实现环境区分，新建Group</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165055629.png" alt="image-20210322165055629"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165240510.png" alt="image-20210322165240510"></p>
<ul>
<li>此时DataID一样，但是Group不一样</li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165324795.png" alt="image-20210322165324795"></p>
<p>在bootstrap.xml中config下增加一条Group的配置即可配置为DEV_GROUP或TEST_GROUP</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165620243.png" alt="image-20210322165620243"></p>
<p>此时文件名为Info，也要在application.yml加上</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165727294.png" alt="image-20210322165727294"></p>
<p>测试：</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322165936974.png" alt="image-20210322165936974"></p>
<p><strong>Namespace方案：</strong></p>
<p>新建dev/test的NameSpace</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322170203706.png" alt="image-20210322170203706"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322170247672.png" alt="image-20210322170247672"></p>
<p>此时在配置列表页面发现新增了两个命令空间</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322170421602.png" alt="image-20210322170421602"></p>
<p>按照域名配置填写</p>
<p>赋值dev的命名空间ID</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322170726241.png" alt="image-20210322170726241"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322170820161.png" alt="image-20210322170820161"></p>
<p>在dev命名空间内建配置文件</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322171151639.png" alt="image-20210322171151639"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322171851570.png" alt="image-20210322171851570"></p>
<p>此时配置文件加了dev的命名空间，指定了TEST_GROUP组，还有dev文件，访问得到的就是TEST组的dev文件</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210322172020169.png" alt="image-20210322172020169"></p>
<h2 id="5、Nacos集群和持久化配置"><a href="#5、Nacos集群和持久化配置" class="headerlink" title="5、Nacos集群和持久化配置"></a>5、Nacos集群和持久化配置</h2><p>官网：<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323103006802.png" alt="image-20210323103006802"></p>
<p>官网图翻译：</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323103853861.png" alt="image-20210323103853861"></p>
<p>说明：</p>
<p>默认的Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据是存在一致性问题的，为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323104659522.png" alt="image-20210323104659522"></p>
<h3 id="5-1-Nacos持久化配置解释"><a href="#5-1-Nacos持久化配置解释" class="headerlink" title="5.1 Nacos持久化配置解释"></a>5.1 Nacos持久化配置解释</h3><p>当我们在Nacos中注册服务或者添加配置文件，Nacos会将这些数据存储到自带的嵌入式数据库derby中，下次再重新启动Nacos会自动加载Derby数据库中的数据，这样就实现了Nacos数据持久化配置</p>
<p>如何将Nacos的自带数据库Derby切换到MySQL数据库</p>
<p><strong>第一步：</strong></p>
<p>打开安装目录下的conf文件，可以找到nacos-mysql.sql脚本</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323105746470.png" alt="image-20210323105746470"></p>
<p>将nacos-mysql.sql脚本中的内容复制粘贴到自己的MySQL数据库执行，先创建一个nacos_config的数据库，再执行sql语句</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323110235981.png" alt="image-20210323110235981"></p>
<p>执行完成后：</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323110355792.png" alt="image-20210323110355792"></p>
<p><strong>第二步：</strong></p>
<p>修改配置，application.properties</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323110603103.png" alt="image-20210323110603103"></p>
<p>将官网中的配置粘贴过来</p>
<pre><code>spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true
db.user=root
db.password=123456
</code></pre>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323111109416.png" alt="image-20210323111109416"></p>
<p>测试：</p>
<p>启动Nacos，登录进nacos，发现之前的数据消失</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323111407647.png" alt="image-20210323111407647"></p>
<p>添加一个测试配置</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323111505389.png" alt="image-20210323111505389"></p>
<p>查看MySQL，发现数据</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323111534594.png" alt="image-20210323111534594"></p>
<p>此时，Nacos嵌入式数据库已经被修改为MySQL数据库</p>
<h2 id="6、Linux版Nacos集群搭建"><a href="#6、Linux版Nacos集群搭建" class="headerlink" title="6、Linux版Nacos集群搭建"></a>6、Linux版Nacos集群搭建</h2><p>搭建Nacos集群需要1个Nginx+3个Nacos注册中心+1个MySQL数据库</p>
<p>注：Nginx搭建和MySQL数据库搭建参考之前的博客</p>
<h3 id="6-1-先搭建一个Nacos"><a href="#6-1-先搭建一个Nacos" class="headerlink" title="6.1 先搭建一个Nacos"></a>6.1 先搭建一个Nacos</h3><p>Nacos下载Linux版本nacos-server-1.1.4.tar.gz</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323120937944.png" alt="image-20210323120937944"></p>
<p>解压：tar -zxvf nacos-server-1.1.4.tar.gz</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323121059721.png" alt="image-20210323121059721"></p>
<p>将解压的nacos文件夹copy到mynacos文件夹</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323121650525.png" alt="image-20210323121650525"></p>
<p>启动Linux版的Nacos：./startup.sh </p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323121939349.png" alt="image-20210323121939349"></p>
<p>可以看到需要设置java路径</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323122104303.png" alt="image-20210323122104303"></p>
<p>找到java地址</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323122432822.png" alt="image-20210323122432822"></p>
<pre><code class="bash">[root@localhost bin]# which java
/usr/bin/java
[root@localhost bin]# ll /usr/bin/java
lrwxrwxrwx. 1 root root 22 1月  13 21:30 /usr/bin/java -&gt; /etc/alternatives/java
[root@localhost bin]# ll /etc/alternatives/java
lrwxrwxrwx. 1 root root 71 1月  13 21:30 /etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64/jre/bin/java
[root@localhost bin]# ll /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64/
总用量 0
drwxr-xr-x. 4 root root 28 1月  13 21:29 jre
[root@localhost bin]# vi /etc/profile
</code></pre>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323123529235.png" alt="image-20210323123529235"></p>
<p>在最后输入此代码块：</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64/
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
[root@localhost ~]# source /etc/profile
</code></pre>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323124452284.png" alt="image-20210323124452284"></p>
<p>以单机模式启动 ./startup.sh -m standalone</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323125020144.png" alt="image-20210323125020144"></p>
<p>启动成功</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323125051088.png" alt="image-20210323125051088"></p>
<h3 id="6-2-搭建集群"><a href="#6-2-搭建集群" class="headerlink" title="6.2 搭建集群"></a>6.2 搭建集群</h3><p>先将启动命令备份，避免改坏了可以回退</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323125833013.png" alt="image-20210323125833013"></p>
<h4 id="6-2-1-Linux上MySQL数据库的配置"><a href="#6-2-1-Linux上MySQL数据库的配置" class="headerlink" title="6.2.1 Linux上MySQL数据库的配置"></a>6.2.1 Linux上MySQL数据库的配置</h4><p>SQL脚本在哪？</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323130317617.png" alt="image-20210323130317617"></p>
<p>拷贝赋值SQL脚本，进入到自己的Linux的MySQL进行数据库创建</p>
<p>可以到window上连接Linux的MySQL进行操作</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323130709862.png" alt="image-20210323130709862"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323130901457.png" alt="image-20210323130901457"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323131041931.png" alt="image-20210323131041931"></p>
<h4 id="6-2-2-application-properties配置"><a href="#6-2-2-application-properties配置" class="headerlink" title="6.2.2 application.properties配置"></a>6.2.2 application.properties配置</h4><p>将Derby换成MySQL，表示以后Nacos以后用的库是MySQL数据库</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323131311829.png" alt="image-20210323131311829"></p>
<p>在application.properties下添加以下内容，其中192.168.127.7是linux本机地址</p>
<pre><code>spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://192.168.127.7:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true
db.user=root
db.password=123456
</code></pre>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323131748472.png" alt="image-20210323131748472"></p>
<h4 id="6-2-3-Linux服务器上nacos的集群配置cluster-conf"><a href="#6-2-3-Linux服务器上nacos的集群配置cluster-conf" class="headerlink" title="6.2.3 Linux服务器上nacos的集群配置cluster.conf"></a>6.2.3 Linux服务器上nacos的集群配置cluster.conf</h4><ul>
<li>要梳理出三台nacos集群的不同服务端口号</li>
<li>复制出cluster.conf，做备份</li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323132321260.png" alt="image-20210323132321260"></p>
<ul>
<li>vim编写内容，地址是自己Linux的地址</li>
</ul>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323132745113.png" alt="image-20210323132745113"></p>
<pre><code>192.168.127.7:3333
192.168.127.7:4444
192.168.127.7:5555
</code></pre>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323132529204.png" alt="image-20210323132529204"></p>
<h4 id="6-2-4-编辑Nacos的启动脚本startup-sh"><a href="#6-2-4-编辑Nacos的启动脚本startup-sh" class="headerlink" title="6.2.4 编辑Nacos的启动脚本startup.sh"></a>6.2.4 编辑Nacos的启动脚本startup.sh</h4><p>使Nacos能够接受不同的启动端口</p>
<p>startup.sh集群启动，我们希望可以类似其他软件的shell命令，传递不同的端口号启动不同的nacos实例。</p>
<p>例如 ./startup.sh -p 3333 启动端口号为3333的Nacos服务器</p>
<p>修改前还是要先备份startup.sh</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323133335215.png" alt="image-20210323133335215"></p>
<p><code>vim statrup.sh</code></p>
<p>注意：如果虚拟机内存较小，建议修改jvm参数，如下 默认xms和xmx都是2g</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323133942496.png" alt="image-20210323133942496"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323134232229.png" alt="image-20210323134232229"></p>
<p>增加个 -p 选项</p>
<p>修改前：</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323134420704.png" alt="image-20210323134420704"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323134826370.png" alt="image-20210323134826370"></p>
<p>修改后：</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323134642425.png" alt="image-20210323134642425"></p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323135423699.png" alt="image-20210323135423699"></p>
<p>此时：启动方式就为： ./startup.sh -p 3333</p>
<h4 id="6-2-5-Nginx的配置"><a href="#6-2-5-Nginx的配置" class="headerlink" title="6.2.5 Nginx的配置"></a>6.2.5 Nginx的配置</h4><p>由Nginx作为负载均衡器</p>
<p>修改nginx的配置文件</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323135950163.png" alt="image-20210323135950163"></p>
<p>备份一下nginx.conf</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323140105783.png" alt="image-20210323140105783"></p>
<p>vim修改</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323140744751.png" alt="image-20210323140744751"></p>
<p>至此，Nginx修改完成</p>
<h4 id="6-2-6-测试"><a href="#6-2-6-测试" class="headerlink" title="6.2.6 测试"></a>6.2.6 测试</h4><p>先启动nacos</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323141459767.png" alt="image-20210323141459767"></p>
<p>三个Nacos启动完成</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323141810162.png" alt="image-20210323141810162"></p>
<p>启动Nginx，依照哪个配置文件启动</p>
<p><img src="/2021/03/15/SpringCloud-09/image-20210323142014748.png" alt="image-20210323142014748"></p>
<p>测试通过Nginx能不能访问到nacos节点</p>
<h4 id="测试失败。。"><a href="#测试失败。。" class="headerlink" title="测试失败。。"></a>测试失败。。</h4>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-11(Seata分布式事务)</title>
    <url>/2021/03/25/SpringCloud-11/</url>
    <content><![CDATA[<h1 id="SpringCloud-11"><a href="#SpringCloud-11" class="headerlink" title="SpringCloud-11"></a>SpringCloud-11</h1><h2 id="1、分布式事务"><a href="#1、分布式事务" class="headerlink" title="1、分布式事务"></a>1、分布式事务</h2><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成，此时<strong>每个服务内部的数据一致性由本地事务保持</strong>，但是<strong>全局的数据一致性</strong>问题没法保证。</p>
<p>一次业务操作需要垮多个数据源或需要垮多个系统进行远程调用,就会产生分布式事务问题，例如</p>
<p>用户购买商品的业务逻辑，整个业务逻辑由三个微服务提供支持</p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量</li>
<li>订单服务：根据采购需求创建订单</li>
<li>账户服务：从用户账单中扣余额</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325084610369.png" alt="image-20210325084610369"></p>
<h2 id="2、Seata简介"><a href="#2、Seata简介" class="headerlink" title="2、Seata简介"></a>2、Seata简介</h2><p>是什么？</p>
<ul>
<li>Seata是一款开源的分布式事务解决方案,致力于在微服务架构下提供高性能和简单易用的分布式事务服务</li>
<li>官网：<a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></li>
</ul>
<p>能干嘛？</p>
<p>一个典型的分布式事物过程：分布式事务处理过程-ID+三组件模型</p>
<ul>
<li>Transaction ID(XID)：全局唯一的事务id</li>
<li>三组件概念：<ul>
<li>Transaction Coordinator(TC)：<strong>事务协调器</strong>，维护全局事务的运行状态,负责协调并驱动全局事务的提交或回滚</li>
<li>Transaction Manager(TM)：<strong>事务管理器</strong>，控制全局事务的边界,负责开启一个全局事务,并最终发起全局提交或全局回滚的决议</li>
<li>Resource Manager(RM)： <strong>资源管理器</strong>，控制分支事务,负责分支注册、状态汇报,并接受事务协调的指令,驱动分支(本地)事务的提交和回滚</li>
</ul>
</li>
</ul>
<p>事物处理过程：</p>
<ol>
<li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</li>
<li>XID在微服务调用链路的上下文中传播</li>
<li>RM向TC注册分支事务，将其纳入XID对应的全局事务的管辖</li>
<li>TM向TC发起针对XID的全局提交或回滚决议</li>
<li>TC调用XID下管辖的全部分支事务完成提交或回滚请求</li>
</ol>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325090115642.png" alt="image-20210325090115642"></p>
<p>如何使用：</p>
<ul>
<li>本地@Transational</li>
<li>全局@GlobalTranstional</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325091604167.png" alt="image-20210325091604167"></p>
<h2 id="3、Seata安装"><a href="#3、Seata安装" class="headerlink" title="3、Seata安装"></a>3、Seata安装</h2><p>seata-server-0.9.0.zip解压到指定目录并修改conf目录下的file.conf配置文件</p>
<ul>
<li><p>先备份原始file.conf文件</p>
</li>
<li><p>主要修改:自定义事务组名称+事务日志存储模式为db+数据库连接</p>
</li>
<li><p>file.conf</p>
<ul>
<li><p>service模块</p>
<pre><code class="json">service &#123;
  #vgroup-&gt;rgroup
  vgroup_mapping.my_test_tx_group = &quot;fsp_tx_group&quot;
  #only support single node
  default.grouplist = &quot;127.0.0.1:8091&quot;
  #degrade current not support
  enableDegrade = false
  #disable
  disable = false
  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent
  max.commit.retry.timeout = &quot;-1&quot;
  max.rollback.retry.timeout = &quot;-1&quot;
&#125;
</code></pre>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325093152581.png" alt="image-20210325093152581"></p>
</li>
<li><p>store模块</p>
<pre><code class="json">store &#123;
  ## store mode: file、db
  mode = &quot;db&quot;

  ## file store
  file &#123;
    dir = &quot;sessionStore&quot;

    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions
    max-branch-session-size = 16384
    # globe session size , if exceeded throws exceptions
    max-global-session-size = 512
    # file buffer size , if exceeded allocate new buffer
    file-write-buffer-cache-size = 16384
    # when recover batch read size
    session.reload.read_size = 100
    # async, sync
    flush-disk-mode = async
  &#125;

  ## database store
  db &#123;
    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
    datasource = &quot;dbcp&quot;
    ## mysql/oracle/h2/oceanbase etc.
    db-type = &quot;mysql&quot;
    driver-class-name = &quot;com.mysql.jdbc.Driver&quot;
    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;
    user = &quot;root&quot;
    password = &quot;123456&quot;
    min-conn = 1
    max-conn = 3
    global.table = &quot;global_table&quot;
    branch.table = &quot;branch_table&quot;
    lock-table = &quot;lock_table&quot;
    query-limit = 100
  &#125;
&#125;
</code></pre>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325093116719.png" alt="image-20210325093116719"></p>
</li>
</ul>
</li>
</ul>
<p>mysql5.7数据库新建库seata</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325093451243.png" alt="image-20210325093451243"></p>
<p>在seata库中建表</p>
<ul>
<li>建表db_store.sql在seata-server-0.9.0\seata\conf目录里面</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325093830966.png" alt="image-20210325093830966"></p>
<p>修改seata-server-0.9.0\seata\conf目录下的registry.conf目录下的registry.conf配置文件</p>
<ul>
<li>指明注册中心为nacos，修改nacos的连接信息</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325094252480.png" alt="image-20210325094252480"></p>
<p>先启动nacos端口号8848</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325094442053.png" alt="image-20210325094442053"></p>
<p>再启动seata，</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325094523845.png" alt="image-20210325094523845"></p>
<h2 id="4、数据库准备"><a href="#4、数据库准备" class="headerlink" title="4、数据库准备"></a>4、数据库准备</h2><p>以下演示都需要先启动Nacos后启动Seata,保证两个都OK ，Seata没启动报错no available server to connect</p>
<p>分布式业务说明：</p>
<ul>
<li>我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务</li>
<li>当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存</li>
<li>再通过远程调用账户服务来扣减用户账户里面的余额</li>
<li>最后在订单服务中修改订单状态为已完成</li>
<li>该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题</li>
<li>下订单—&gt;扣库存—–&gt; 减账户(余额)</li>
</ul>
<p>订单数据库准备：</p>
<ul>
<li>seata_order：存储订单的数据库<ul>
<li>create database seata_order;</li>
</ul>
</li>
<li>seata_storage：存储库存的数据库<ul>
<li>create database seata_storage;</li>
</ul>
</li>
<li>seata_account：存储账户信息的数据库<ul>
<li>create database seata_account;</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325100151865.png" alt="image-20210325100151865"></p>
<p>上述三个数据库分别建立业务表</p>
<ul>
<li><p>seata_order库下新建t_order表</p>
<pre><code class="sql">DROP TABLE IF EXISTS `t_order`;
CREATE TABLE `t_order`  (
  `id` BIGINT(11) NOT NULL AUTO_INCREMENT,
  `user_id` BIGINT(20) DEFAULT NULL COMMENT &#39;用户id&#39;,
  `product_id` BIGINT(11) DEFAULT NULL COMMENT &#39;产品id&#39;,
  `count` INT(11) DEFAULT NULL COMMENT &#39;数量&#39;,
  `money` DECIMAL(11, 0) DEFAULT NULL COMMENT &#39;金额&#39;,
  `status` INT(1) DEFAULT NULL COMMENT &#39;订单状态:  0:创建中 1:已完结&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = INNODB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;订单表&#39; ROW_FORMAT = DYNAMIC;
</code></pre>
</li>
<li><p>seata_storage库下新建t_storage表</p>
<pre><code class="sql">DROP TABLE IF EXISTS `t_storage`;
CREATE TABLE `t_storage`  (
  `id` BIGINT(11) NOT NULL AUTO_INCREMENT,
  `product_id` BIGINT(11) DEFAULT NULL COMMENT &#39;产品id&#39;,
  `total` INT(11) DEFAULT NULL COMMENT &#39;总库存&#39;,
  `used` INT(11) DEFAULT NULL COMMENT &#39;已用库存&#39;,
  `residue` INT(11) DEFAULT NULL COMMENT &#39;剩余库存&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = INNODB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;库存&#39; ROW_FORMAT = DYNAMIC;
INSERT INTO `t_storage` VALUES (1, 1, 100, 0, 100);
</code></pre>
</li>
<li><p>seata_account库下新建t_account表</p>
<pre><code class="sql">CREATE TABLE `t_account`  (
  `id` bigint(11) NOT NULL COMMENT &#39;id&#39;,
  `user_id` bigint(11) DEFAULT NULL COMMENT &#39;用户id&#39;,
  `total` decimal(10, 0) DEFAULT NULL COMMENT &#39;总额度&#39;,
  `used` decimal(10, 0) DEFAULT NULL COMMENT &#39;已用余额&#39;,
  `residue` decimal(10, 0) DEFAULT NULL COMMENT &#39;剩余可用额度&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;账户表&#39; ROW_FORMAT = Dynamic;
 
INSERT INTO `t_account` VALUES (1, 1, 1000, 0, 1000);
</code></pre>
</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325100437486.png" alt="image-20210325100437486"></p>
<p>按照上述3个库分别创建对应的回滚日志表</p>
<p>订单/库存/账户3个库下都需要建各自的回滚日志表，此sql语句在</p>
<p>seata-server-0.9.0\seata\conf\目录下的db_undo_log.sql</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325101911282.png" alt="image-20210325101911282"></p>
<h2 id="5、微服务准备"><a href="#5、微服务准备" class="headerlink" title="5、微服务准备"></a>5、微服务准备</h2><p>业务需求：下订单—&gt;减库存—-&gt;扣余额—-&gt;改(订单)状态</p>
<h3 id="5-1-新建订单Order-Module"><a href="#5-1-新建订单Order-Module" class="headerlink" title="5.1 新建订单Order-Module"></a>5.1 新建订单Order-Module</h3><h4 id="5-1-1-建Module：seata-order-service2001"><a href="#5-1-1-建Module：seata-order-service2001" class="headerlink" title="5.1.1 建Module：seata-order-service2001"></a>5.1.1 建Module：seata-order-service2001</h4><h4 id="5-1-2-改POM"><a href="#5-1-2-改POM" class="headerlink" title="5.1.2 改POM"></a>5.1.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;seata-order-service2001&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--nacos--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--seata--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;
                    &lt;groupId&gt;io.seata&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.seata&lt;/groupId&gt;
            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;
            &lt;version&gt;0.9.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--feign--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--web-actuator--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mysql-druid--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="5-1-3-改YML"><a href="#5-1-3-改YML" class="headerlink" title="5.1.3 改YML"></a>5.1.3 改YML</h4><pre><code class="yml">server:
  port: 2001

spring:
  application:
    name: seata-order-service
  cloud:
    alibaba:
      seata:
        #自定义事务组名称需要与seata-server中的对应
        tx-service-group: fsp_tx_group
    nacos:
      discovery:
        server-addr: localhost:8848
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/seata_order
    username: root
    password: 123456

feign:
  hystrix:
    enabled: false

logging:
  level:
    io:
      seata: info

mybatis:
  mapperLocations: classpath:mapper/*.xml
</code></pre>
<h4 id="5-1-4-加file-conf"><a href="#5-1-4-加file-conf" class="headerlink" title="5.1.4 加file.conf"></a>5.1.4 加file.conf</h4><pre><code class="json">transport &#123;
  # tcp udt unix-domain-socket
  type = &quot;TCP&quot;
  #NIO NATIVE
  server = &quot;NIO&quot;
  #enable heartbeat
  heartbeat = true
  #thread factory for netty
  thread-factory &#123;
    boss-thread-prefix = &quot;NettyBoss&quot;
    worker-thread-prefix = &quot;NettyServerNIOWorker&quot;
    server-executor-thread-prefix = &quot;NettyServerBizHandler&quot;
    share-boss-worker = false
    client-selector-thread-prefix = &quot;NettyClientSelector&quot;
    client-selector-thread-size = 1
    client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot;
    # netty boss thread size,will not be used for UDT
    boss-thread-size = 1
    #auto default pin or 8
    worker-thread-size = 8
  &#125;
  shutdown &#123;
    # when destroy server, wait seconds
    wait = 3
  &#125;
  serialization = &quot;seata&quot;
  compressor = &quot;none&quot;
&#125;

service &#123;

  vgroup_mapping.fsp_tx_group = &quot;default&quot; #修改自定义事务组名称

  default.grouplist = &quot;127.0.0.1:8091&quot;
  enableDegrade = false
  disable = false
  max.commit.retry.timeout = &quot;-1&quot;
  max.rollback.retry.timeout = &quot;-1&quot;
  disableGlobalTransaction = false
&#125;


client &#123;
  async.commit.buffer.limit = 10000
  lock &#123;
    retry.internal = 10
    retry.times = 30
  &#125;
  report.retry.count = 5
  tm.commit.retry.count = 1
  tm.rollback.retry.count = 1
&#125;

## transaction log store
store &#123;
  ## store mode: file、db
  mode = &quot;db&quot;

  ## file store
  file &#123;
    dir = &quot;sessionStore&quot;

    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions
    max-branch-session-size = 16384
    # globe session size , if exceeded throws exceptions
    max-global-session-size = 512
    # file buffer size , if exceeded allocate new buffer
    file-write-buffer-cache-size = 16384
    # when recover batch read size
    session.reload.read_size = 100
    # async, sync
    flush-disk-mode = async
  &#125;

  ## database store
  db &#123;
    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
    datasource = &quot;dbcp&quot;
    ## mysql/oracle/h2/oceanbase etc.
    db-type = &quot;mysql&quot;
    driver-class-name = &quot;com.mysql.jdbc.Driver&quot;
    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;
    user = &quot;root&quot;
    password = &quot;123456&quot;
    min-conn = 1
    max-conn = 3
    global.table = &quot;global_table&quot;
    branch.table = &quot;branch_table&quot;
    lock-table = &quot;lock_table&quot;
    query-limit = 100
  &#125;
&#125;
lock &#123;
  ## the lock store mode: local、remote
  mode = &quot;remote&quot;

  local &#123;
    ## store locks in user&#39;s database
  &#125;

  remote &#123;
    ## store locks in the seata&#39;s server
  &#125;
&#125;
recovery &#123;
  #schedule committing retry period in milliseconds
  committing-retry-period = 1000
  #schedule asyn committing retry period in milliseconds
  asyn-committing-retry-period = 1000
  #schedule rollbacking retry period in milliseconds
  rollbacking-retry-period = 1000
  #schedule timeout retry period in milliseconds
  timeout-retry-period = 1000
&#125;

transaction &#123;
  undo.data.validation = true
  undo.log.serialization = &quot;jackson&quot;
  undo.log.save.days = 7
  #schedule delete expired undo_log in milliseconds
  undo.log.delete.period = 86400000
  undo.log.table = &quot;undo_log&quot;
&#125;

## metrics settings
metrics &#123;
  enabled = false
  registry-type = &quot;compact&quot;
  # multi exporters use comma divided
  exporter-list = &quot;prometheus&quot;
  exporter-prometheus-port = 9898
&#125;

support &#123;
  ## spring
  spring &#123;
    # auto proxy the DataSource bean
    datasource.autoproxy = false
  &#125;
&#125;
</code></pre>
<h4 id="5-1-5-加registry-conf"><a href="#5-1-5-加registry-conf" class="headerlink" title="5.1.5 加registry.conf"></a>5.1.5 加registry.conf</h4><pre><code class="json">registry &#123;
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = &quot;nacos&quot;

  nacos &#123;
    serverAddr = &quot;localhost:8848&quot;
    namespace = &quot;&quot;
    cluster = &quot;default&quot;
  &#125;
  eureka &#123;
    serviceUrl = &quot;http://localhost:8761/eureka&quot;
    application = &quot;default&quot;
    weight = &quot;1&quot;
  &#125;
  redis &#123;
    serverAddr = &quot;localhost:6379&quot;
    db = &quot;0&quot;
  &#125;
  zk &#123;
    cluster = &quot;default&quot;
    serverAddr = &quot;127.0.0.1:2181&quot;
    session.timeout = 6000
    connect.timeout = 2000
  &#125;
  consul &#123;
    cluster = &quot;default&quot;
    serverAddr = &quot;127.0.0.1:8500&quot;
  &#125;
  etcd3 &#123;
    cluster = &quot;default&quot;
    serverAddr = &quot;http://localhost:2379&quot;
  &#125;
  sofa &#123;
    serverAddr = &quot;127.0.0.1:9603&quot;
    application = &quot;default&quot;
    region = &quot;DEFAULT_ZONE&quot;
    datacenter = &quot;DefaultDataCenter&quot;
    cluster = &quot;default&quot;
    group = &quot;SEATA_GROUP&quot;
    addressWaitTime = &quot;3000&quot;
  &#125;
  file &#123;
    name = &quot;file.conf&quot;
  &#125;
&#125;

config &#123;
  # file、nacos 、apollo、zk、consul、etcd3
  type = &quot;file&quot;

  nacos &#123;
    serverAddr = &quot;localhost&quot;
    namespace = &quot;&quot;
  &#125;
  consul &#123;
    serverAddr = &quot;127.0.0.1:8500&quot;
  &#125;
  apollo &#123;
    app.id = &quot;seata-server&quot;
    apollo.meta = &quot;http://192.168.1.204:8801&quot;
  &#125;
  zk &#123;
    serverAddr = &quot;127.0.0.1:2181&quot;
    session.timeout = 6000
    connect.timeout = 2000
  &#125;
  etcd3 &#123;
    serverAddr = &quot;http://localhost:2379&quot;
  &#125;
  file &#123;
    name = &quot;file.conf&quot;
  &#125;
&#125;
</code></pre>
<h4 id="5-1-6-加domain"><a href="#5-1-6-加domain" class="headerlink" title="5.1.6 加domain"></a>5.1.6 加domain</h4><p>CommonResult</p>
<pre><code>@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResult&lt;T&gt;
&#123;
    private Integer code;
    private String  message;
    private T       data;

    public CommonResult(Integer code, String message)
    &#123;
        this(code,message,null);
    &#125;
&#125;
</code></pre>
<p>Order</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Order
&#123;
    private Long id;

    private Long userId;

    private Long productId;

    private Integer count;

    private BigDecimal money;

    private Integer status; //订单状态：0：创建中；1：已完结
&#125;
</code></pre>
<h4 id="5-1-7-Dao接口的实现"><a href="#5-1-7-Dao接口的实现" class="headerlink" title="5.1.7  Dao接口的实现"></a>5.1.7  Dao接口的实现</h4><p>OrderDao</p>
<pre><code class="java">package com.practice.springcloud.alibaba.dao;

import com.practice.springcloud.alibaba.domain.Order;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface OrderDao &#123;

    //新建订单
    void create(Order order);

    //修改订单状态，从0改为1
    void update(@Param(&quot;userId&quot;) Long userId,@Param(&quot;status&quot;) Integer status);
&#125;
</code></pre>
<p>resources文件夹下新建mapper文件夹后添加OrderMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;

&lt;mapper namespace=&quot;com.practice.springcloud.alibaba.dao.OrderDao&quot;&gt;

    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.practice.springcloud.alibaba.domain.Order&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;
        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt;
        &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt;
        &lt;result column=&quot;count&quot; property=&quot;count&quot; jdbcType=&quot;INTEGER&quot;/&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot; jdbcType=&quot;DECIMAL&quot;/&gt;
        &lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;insert id=&quot;create&quot;&gt;
        insert into t_order (id,user_id,product_id,count,money,status)
        values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);
    &lt;/insert&gt;


    &lt;update id=&quot;update&quot;&gt;
        update t_order set status = 1
        where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;
    &lt;/update&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="5-1-8-Service接口及实现"><a href="#5-1-8-Service接口及实现" class="headerlink" title="5.1.8 Service接口及实现"></a>5.1.8 Service接口及实现</h4><p>OrderService</p>
<pre><code class="java">public interface OrderService &#123;
    void create(Order order);
&#125;
</code></pre>
<p>AccountService</p>
<pre><code class="java">@FeignClient(value = &quot;seata-account-service&quot;)
public interface AccountService &#123;

    @PostMapping(value = &quot;/account/decrease&quot;)
    CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);

&#125;
</code></pre>
<p>StorageService</p>
<pre><code class="java">@FeignClient(value = &quot;seata-storage-service&quot;)
public interface StorageService &#123;

    @PostMapping(value = &quot;/storage/decrease&quot;)
    CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId,@RequestParam(&quot;count&quot;) Integer count);
&#125;
</code></pre>
<p>OrderServiceImpl</p>
<pre><code class="java">@Service
@Slf4j
public class OrderServiceImpl implements OrderService &#123;

    @Resource
    private OrderDao orderDao;

    @Resource
    private StorageService storageService;

    @Resource
    private AccountService accountService;

    /**
     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态
     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态
     */
    /*业务逻辑*/
    @Override
    public void create(Order order) &#123;

        //新建订单
        log.info(&quot;-------------&gt;开始新建订单&quot;);
        orderDao.create(order);

        //扣减库存
        log.info(&quot;-------------&gt;订单微服务开始调用库存，做扣减Count&quot;);
        storageService.decrease(order.getProductId(),order.getCount());
        log.info(&quot;-------------&gt;订单微服务开始调用库存，做扣减end&quot;);

        //扣减账户
        log.info(&quot;-------------&gt;订单微服务开始调用账户，做扣减Money&quot;);
        accountService.decrease(order.getUserId(),order.getMoney());
        log.info(&quot;-------------&gt;订单微服务开始调用账户，做扣减end&quot;);

        //4 修改订单的状态，从0到1,1表示完成
        log.info(&quot;-------------&gt;开始修改订单状态&quot;);
        orderDao.update(order.getUserId(),0);
        log.info(&quot;-------------&gt;结束修改订单状态&quot;);

        log.info(&quot;-------------&gt;下订单结束&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="5-1-9-Controller配置"><a href="#5-1-9-Controller配置" class="headerlink" title="5.1.9 Controller配置"></a>5.1.9 Controller配置</h4><pre><code class="java">@RestController
public class OrderController &#123;

    @Resource
    private OrderService orderService;

    @GetMapping(&quot;/order/create&quot;)
    public CommonResult create(Order order)&#123;
        orderService.create(order);
        return new CommonResult(200,&quot;订单创建成功&quot;);

    &#125;

&#125;
</code></pre>
<h4 id="5-1-10-Config配置"><a href="#5-1-10-Config配置" class="headerlink" title="5.1.10 Config配置"></a>5.1.10 Config配置</h4><p>MyBatisConfig</p>
<pre><code class="java">@Configuration
@MapperScan(&#123;&quot;com.practice.springcloud.alibaba.dao&quot;&#125;)
public class MyBatisConfig &#123;
&#125;
</code></pre>
<p>DataSourceProxyConfig</p>
<pre><code class="java">package com.practice.springcloud.alibaba.config;


import com.alibaba.druid.pool.DruidDataSource;
import io.seata.rm.datasource.DataSourceProxy;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import javax.sql.DataSource;


/**
 * 使用Seata对数据源进行代理
 */
@Configuration
public class DataSourceProxyConfig &#123;

    @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)
    private String mapperLocations;

    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    public DataSource druidDataSource()&#123;
        return new DruidDataSource();
    &#125;

    @Bean
    public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123;
        return new DataSourceProxy(dataSource);
    &#125;

    @Bean
    public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123;
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSourceProxy);
        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());
        return sqlSessionFactoryBean.getObject();
    &#125;
&#125;
</code></pre>
<h4 id="5-1-11-主启动类"><a href="#5-1-11-主启动类" class="headerlink" title="5.1.11 主启动类"></a>5.1.11 主启动类</h4><pre><code class="java">@EnableDiscoveryClient
@EnableFeignClients
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)//取消数据源的自动创建
public class SeataOrderMainApp2001
&#123;

    public static void main(String[] args)
    &#123;
        SpringApplication.run(SeataOrderMainApp2001.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="5-2-新建库存Storage-Module"><a href="#5-2-新建库存Storage-Module" class="headerlink" title="5.2 新建库存Storage-Module"></a>5.2 新建库存Storage-Module</h3><ul>
<li>seata-storage-service2002</li>
<li>跟2001大致一样，不详细介绍</li>
</ul>
<h3 id="5-3-新建账户Account-Module"><a href="#5-3-新建账户Account-Module" class="headerlink" title="5.3 新建账户Account-Module"></a>5.3 新建账户Account-Module</h3><ul>
<li>seata-account-service2003</li>
<li>跟2001大致一样，不详细介绍</li>
</ul>
<h2 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h2><h3 id="6-1-数据库初始情况"><a href="#6-1-数据库初始情况" class="headerlink" title="6.1 数据库初始情况"></a>6.1 数据库初始情况</h3><p><img src="/2021/03/25/SpringCloud-11/image-20210325145919581.png" alt="image-20210325145919581"></p>
<p>正常下单：</p>
<p><a href="http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100">http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325150342827.png" alt="image-20210325150342827"></p>
<p>此时，数据库情况</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325150421019.png" alt="image-20210325150421019"></p>
<h3 id="6-2-超时异常"><a href="#6-2-超时异常" class="headerlink" title="6.2 超时异常"></a>6.2 超时异常</h3><p>没加@GlobalTransaction</p>
<ul>
<li>在AccountServiceImpl添加超时</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325150552484.png" alt="image-20210325150552484"></p>
<p>此时再测试下单情况</p>
<p><a href="http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100">http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p>
<p>出现error页面</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325151014190.png" alt="image-20210325151014190"></p>
<p>此时数据库页面</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325151112540.png" alt="image-20210325151112540"></p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325151131996.png" alt="image-20210325151131996"></p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325151155571.png" alt="image-20210325151155571"></p>
<p>说明：</p>
<ul>
<li>当库存和账户金额扣减后,订单状态并没有设置为已经完成,没有从零改为1</li>
<li>而且由于feign的重试机制,账户余额还有可能被多次扣减</li>
</ul>
<h3 id="6-3-添加-GlobalTransactional"><a href="#6-3-添加-GlobalTransactional" class="headerlink" title="6.3 添加@GlobalTransactional"></a>6.3 添加@GlobalTransactional</h3><ul>
<li>AccountServiceImpl添加超时</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325150552484.png" alt="image-20210325150552484"></p>
<ul>
<li>OrderServiceImpl添加@GlobalTransactional</li>
</ul>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325151517188.png" alt="image-20210325151517188"></p>
<p>此时再重新访问<a href="http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100">http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p>
<p>前台还是error页面，因为有异常</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325152058875.png" alt="image-20210325152058875"></p>
<p>但是此时数据库</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325152142650.png" alt="image-20210325152142650"></p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325152154341.png" alt="image-20210325152154341"></p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325152205560.png" alt="image-20210325152205560"></p>
<p>此时发现数据库没有任何变化，说明发生异常后，事务回滚了</p>
<h2 id="7、Seata原理"><a href="#7、Seata原理" class="headerlink" title="7、Seata原理"></a>7、Seata原理</h2><p>分布式事务执行流程</p>
<ul>
<li>TM开启分布式事务(TM向TC注册全局事务记录)</li>
<li>按业务场景,编排数据库、服务等事务内资源(RM向TC汇报资源准备状态)</li>
<li>TM结束分布式事务,事务一阶段结束(TM通知TC提交/回滚分布式事务)</li>
<li>TC汇报事务信息,决定分布式事务是提交还是回滚</li>
<li>TC通知所有RM提交/回滚资源,事务二阶段结束</li>
</ul>
<p>AT模式：</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325152822367.png" alt="image-20210325152822367"></p>
<h3 id="7-1-一阶段加载"><a href="#7-1-一阶段加载" class="headerlink" title="7.1 一阶段加载"></a>7.1 一阶段加载</h3><p>在第一阶段，Seata会拦截“业务SQL”</p>
<ol>
<li>解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”</li>
<li>执行“业务SQL”更新业务数据，在业务数据更新之后</li>
<li>将其保存成“after image”，最后生成行锁</li>
</ol>
<p>以上操作全部在一个数据事务内完成，这样保证了一阶段操作的原子性</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325153318122.png" alt="image-20210325153318122"></p>
<h3 id="7-2-二阶段提交"><a href="#7-2-二阶段提交" class="headerlink" title="7.2 二阶段提交"></a>7.2 二阶段提交</h3><p>二阶段如是顺利提交的话，因为“业务SQL”在一阶段已经提交到数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325153516595.png" alt="image-20210325153516595"></p>
<h3 id="7-3-二阶段回滚"><a href="#7-3-二阶段回滚" class="headerlink" title="7.3 二阶段回滚"></a>7.3 二阶段回滚</h3><p>二阶段回滚：</p>
<p>二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据，但在还原前要首先校验脏写，对比“数据库当前业务数据”和“after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理</p>
<p><img src="/2021/03/25/SpringCloud-11/image-20210325153829181.png" alt="image-20210325153829181"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC基本使用-上篇</title>
    <url>/2020/09/27/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<h2 id="SpringMVC基本使用-上篇"><a href="#SpringMVC基本使用-上篇" class="headerlink" title="SpringMVC基本使用-上篇"></a>SpringMVC基本使用-上篇</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 </p>
<ul>
<li>三层架构<ul>
<li><strong>表现层</strong>：WEB层，用来和客户端进行数据交互的。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</li>
<li><strong>业务层</strong>：也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制）</li>
<li><strong>持久层</strong>：也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库 中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。</li>
</ul>
</li>
<li>MVC模型 <ul>
<li>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 </li>
<li><strong>Model</strong>：数据模型，JavaBean的类，用来进行数据封装。</li>
<li><strong>View</strong>：指JSP、HTML用来展示数据给用户</li>
<li><strong>Controller</strong>：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li>
</ul>
</li>
</ul>
<p>Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。</p>
<p>支持 REST 风格的 URL 请求。 Restful </p>
<p>采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。</p>
<p>Spring MVC 的入口是 Servlet</p>
<p><strong>SpringMVC在三层架构中的位置</strong></p>
<p><img src="/2020/09/27/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8A%E7%AF%87/%E5%9B%BE1.jpg" alt="图1"></p>
<h3 id="1-2-常用组件"><a href="#1-2-常用组件" class="headerlink" title="1.2 常用组件"></a>1.2 常用组件</h3><p>SpringMVC将 Web 层进行了职责解耦，基于请求-响应模型</p>
<p>常用主要组件</p>
<ul>
<li><strong>DispatcherServlet</strong>：前端控制器</li>
<li><strong>Controller</strong>：处理器/页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移到 前端控制器了，用于对请求进行处理</li>
<li><strong>HandlerMapping</strong> ：请求映射到处理器，找谁来处理，如果映射成功，返回一个 HandlerExecutionChain 对象（包含一个 Handler 处理器(页面控制器)对象、多个 HandlerInterceptor 拦截器对象）</li>
<li><strong>HandlerAdapter</strong>：处理器适配器，作用是根据映射器找到的处理器 Handler 信息，按照特定的规则去执行相关的处理器 Handler。</li>
<li><strong>View Resolver</strong> : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体的 View,进行这种策略模式，很容易更换其他视图技术；  如 InternalResourceViewResolver 将逻辑视图名映射为 JSP 视图</li>
<li><strong>LocalResolver</strong>：本地化、国际化 </li>
<li><strong>MultipartResolver</strong>：文件上传解析器</li>
<li><strong>HandlerExceptionResolver</strong>：异常处理器</li>
</ul>
<p>在 SpringMVC 的各个组件中，<strong>处理器映射器</strong>HandlerMapping、<strong>处理器适配器</strong>HandlerAdapter、<strong>视图解析器</strong>View Resolver称为 SpringMVC 的三大组件。</p>
<h3 id="1-3-SpringMVC-入门案例"><a href="#1-3-SpringMVC-入门案例" class="headerlink" title="1.3 SpringMVC 入门案例"></a>1.3 SpringMVC 入门案例</h3><ol>
<li><p>新建web工程加入jar包（最后两个为SpringMVC所需要的jar包，前六个为Spring注解IOC的jar包）</p>
</li>
<li><p>SpringMVC是Spring的web模块，所有模块运行都是依赖核心模块（IOC模块）</p>
<ul>
<li>IOC模块</li>
<li>spring-aop-4.0.0.RELEASE.jar //支持注解的包</li>
<li>spring-beans-4.0.0.RELEASE.jar </li>
<li>spring-context-4.0.0.RELEASE.jar </li>
<li>spring-core-4.0.0.RELEASE.jar </li>
<li>spring-expression-4.0.0.RELEASE.jar </li>
<li>commons-logging-1.1.3.jar </li>
<li>web模块</li>
<li><code>spring-web-4.0.0.RELEASE.jar</code> </li>
<li><code>spring-webmvc-4.0.0.RELEASE.jar</code></li>
</ul>
</li>
<li><p>配置一个核心控制器web.xml</p>
<pre><code class="xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;!-- 配置 spring mvc 的核心控制器 --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.springframework.web.servlet.DispatcherServlet
        &lt;/servlet-class&gt;
        
        &lt;!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 
        解释配置文件的名称定义规则:
        实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认
        的.默认的配置文件为: /WEB-INF/&lt;servlet-name&gt;-servlet.xml，例如默认文件名为springMVC-servlet.xml
        --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。
        取值只能是非 0 正整数，表示启动顺序 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
</li>
<li><p>创建SpringMVC的配置文件，由于web.xml指定了SpringMVC配置文件，所以名字只能为SpringMVC.xml</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;

    &lt;!-- 扫描组件，将加上@Controller注解的类作为springMVC的控制层 --&gt;
    &lt;context:component-scan base-package=&quot;com.review.test&quot;&gt;&lt;/context:component-scan&gt;
    
    &lt;!-- 
        配置视图解析器:将控制器返回的结果字符串，转换为一个物理的视图文件
        作用：将prefix + 视图名称 + suffix 确定最终要跳转的页面
        /WEB-INF/view/success.jsp
     --&gt;
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
</li>
<li><p>编写控制器，测试代码</p>
<pre><code class="java">@Controller//声明 Bean 对象，为一个控制器组件
public class HelloController &#123;
    /**
     * 假设：localhost:8080/SpringMVC01/hello
     */
    @RequestMapping(&quot;/hello&quot;)
    public String hello(String username, String password) &#123;
        System.out.println(username + &quot;=====&quot; + password);
        System.out.println(&quot;Hello Word&quot;);
        return &quot;success&quot;;//视图名称
    &#125;    
&#125;
</code></pre>
<p><code>HelloController</code>类实现的就是servlet功能，不需要再创建servlet类，直接使用普通类加controller注解就能实现servlet功能</p>
</li>
</ol>
<p><strong>此案例的执行过程</strong></p>
<p><img src="/2020/09/27/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8A%E7%AF%87/image-20200925095553733.png" alt="image-20200925095553733"></p>
<ol>
<li>服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。从入门案例中可以看到的是：HelloController 和 InternalResourceViewResolver，但是远不 止这些。 </li>
<li>浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发 的路径是根据请求 URL，匹配@RequestMapping 中的内容。</li>
<li>匹配到了后，执行对应方法。该方法有一个返回值。 </li>
<li>根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。</li>
<li>渲染结果视图，响应浏览器。</li>
</ol>
<p><strong>此案例中涉及到的组件</strong></p>
<ol>
<li>DispatcherServlet：前端控制器<ul>
<li>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li>
</ul>
</li>
<li>HandlerMapping：处理器映射器<ul>
<li>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li>
</ul>
</li>
<li>Handler：处理器<ul>
<li>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</li>
</ul>
</li>
<li>HandlAdapter：处理器适配器<ul>
<li>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。</li>
</ul>
</li>
<li>View Resolver：视图解析器<ul>
<li>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li>
</ul>
</li>
<li>View：视图<ul>
<li>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li>
</ul>
</li>
</ol>
<h3 id="1-4-RequestMapping注解"><a href="#1-4-RequestMapping注解" class="headerlink" title="1.4 RequestMapping注解"></a>1.4 RequestMapping注解</h3><ol>
<li><p>作用：DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。用于建立请求 URL 和处理请求方法之间的对应关系。</p>
</li>
<li><p>出现的位置：</p>
<ol>
<li>类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的 URL 可以按照模块化管理，例如： <ul>
<li>账户模块： /account/add   /account为一级目录  /add为二级访问目录</li>
</ul>
</li>
<li>方法上：请求 URL 的第二级访问目录。</li>
</ol>
</li>
<li><p>属性：</p>
<ol>
<li><p>value：用于指定请求的 URL。它和 path 属性的作用是一样的。 </p>
</li>
<li><p>method：用于指定请求的方式。 </p>
</li>
<li><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。</p>
<ul>
<li><p>param1: 表示请求必须包含名为 param1 的请求参数 </p>
</li>
<li><p>!param1: 表示请求不能包含名为 param1 的请求参数 </p>
</li>
<li><p>param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1 </p>
</li>
<li><p>{“param1=value1”, “param2”}: 请求必须包含名为 param1 和 param2 的两个请求</p>
</li>
<li><p>例如： params = {“accountName”}，表示请求参数必须有 accountName </p>
</li>
<li><p>params = {“moeny!100”}，表示请求参数中 money 不能是 100。</p>
</li>
</ul>
</li>
<li><p>headers：用于指定限制请求消息头的条件。很少使用</p>
</li>
</ol>
<ul>
<li><strong>注意</strong>： 以上四个属性只要出现 2 个或以上时，他们的关系是<strong>与</strong>的关系</li>
</ul>
</li>
<li><p>各个参数使用示例</p>
<ol>
<li><p>value</p>
<pre><code class="java">@Controller(&quot;accountController&quot;)
@RequestMapping(&quot;/account&quot;)
public class AccountController &#123;
    @RequestMapping(&quot;/findAccount&quot;)
    public String findAccount() &#123;
        System.out.println(&quot;查询了账户。。。。&quot;);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<p>jsp访问方式</p>
<pre><code class="jsp">&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;requestmapping 的使用&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 第一种访问方式 --&gt;
&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;&gt;查询账户&lt;/a&gt;

&lt;!-- 第二种访问方式 --&gt;
&lt;a href=&quot;account/findAccount&quot;&gt;查询账户&lt;/a&gt; &lt;!--不要在访问 URL 前面加/，否则无法找到资源。--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意</p>
<pre><code class="java">java
@RequestMapping(&quot;/hello&quot;)
jsp
&lt;a href=&quot;hello&quot;&gt;Hello SpringMVC&lt;/a&gt;//可以找到资源（推荐这种写法）
&lt;a href=&quot;/hello&quot;&gt;Hello SpringMVC&lt;/a&gt;//无法找到资源   
java
@RequestMapping(&quot;hello&quot;)
jsp
&lt;a href=&quot;hello&quot;&gt;Hello SpringMVC&lt;/a&gt;//可以找到资源
&lt;a href=&quot;/hello&quot;&gt;Hello SpringMVC&lt;/a&gt;//无法找到资源   
</code></pre>
</li>
<li><p>method</p>
<pre><code class="java">@RequestMapping(value=&quot;/saveAccount&quot;,method= RequestMethod.POST)
    public String saveAccount() &#123;
        System.out.println(&quot;保存了账户&quot;);
        return &quot;success&quot;;
    &#125;
</code></pre>
<p>jsp代码</p>
<pre><code class="jsp">&lt;a href=&quot;account/saveAccount&quot;&gt;保存账户，get 请求&lt;/a&gt;
&lt;br/&gt;
&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;保存账户，post 请求&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>指定post请求，如果是get请求，会报405错误，错误信息是 方法不支持 get 方式请求</p>
<p><strong>注意</strong>：@RequestMapping 不写method，默认为get,post方式都支持</p>
</li>
<li><p>params</p>
<pre><code class="java">@RequestMapping(value=&quot;/removeAccount&quot;,params= &#123;&quot;accountName&quot;,&quot;money&gt;100&quot;&#125;)
public String removeAccount() &#123;
    System.out.println(&quot;删除了账户&quot;);
    return &quot;success&quot;;
&#125;
</code></pre>
<p>jsp</p>
<pre><code class="jsp">&lt;!-- 请求参数的示例 --&gt;
&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;100&quot;&gt;删除账户，金额 100&lt;/a&gt;&lt;!--可以成功--&gt;
&lt;br/&gt;
&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;150&quot;&gt;删除账户，金额 150&lt;/a&gt;
</code></pre>
<p>其中请求的参数accountName和money必须和params的参数一致，表示接受的参数必须含有accountName而且money&gt;100</p>
</li>
</ol>
</li>
<li><p>RequestMapping 支持 Ant 路径风格</p>
<ul>
<li><p>Ant 风格资源地址支持 3 种匹配符：【了解】 </p>
</li>
<li><p>?：匹配文件名中的一个字符 </p>
</li>
<li><p>*：匹配文件名中的任意字符 ，无论几个字符都可以</p>
</li>
<li><p>**：匹配多层路径</p>
<pre><code class="java">//Ant 风格资源地址支持 3 种匹配符
//@RequestMapping(value=&quot;/testAntPath/*/abc&quot;)
//@RequestMapping(value=&quot;/testAntPath/**/abc&quot;)
@RequestMapping(value=&quot;/testAntPath/abc??&quot;)
public String testAntPath()&#123;
    System.out.println(&quot;testAntPath...&quot;);
    return &quot;success&quot;;
&#125;
</code></pre>
<p>jsp</p>
<pre><code class="jsp">&lt;!-- Ant 风格资源地址支持 3 种匹配符 --&gt;
&lt;a href=&quot;springmvc/testAntPath/*/abc&quot;&gt;testAntPath&lt;/a&gt;
&lt;a href=&quot;springmvc/testAntPath/xxx/yyy/abc&quot;&gt;testAntPath&lt;/a&gt;
&lt;a href=&quot;springmvc/testAntPath/abcxx&quot;&gt;testAntPath&lt;/a&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-5-请求参数绑定"><a href="#1-5-请求参数绑定" class="headerlink" title="1.5 请求参数绑定"></a>1.5 请求参数绑定</h3><ul>
<li>我们都知道，表单中请求参数都是基于 key=value 的。 </li>
<li>SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。</li>
</ul>
<pre><code class="java">&lt;a href=&quot;findAccount?accountId=10&quot;&gt;查询账户&lt;/a&gt;
请求参数是：accountId=10
/**
* 查询账户
*/
@RequestMapping(&quot;/findAccount&quot;)
public String findAccount(Integer accountId) &#123;
    System.out.println(&quot;查询了账户。。。。&quot;+accountId);
    return &quot;success&quot;;
&#125;
//将请求参数中的accountId和方法中的参数accountId绑定，保持名字一致
</code></pre>
<ol>
<li><p>支持的数据类型</p>
<ol>
<li><strong>基本类型参数</strong>： 包括基本类型和 String 类型 </li>
<li><strong>POJO 类型参数</strong>： 包括实体类，以及关联的实体类 </li>
<li><strong>数组和集合类型参数</strong>： 包括 List 结构和 Map 结构的集合（包括数组）</li>
<li>SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求</li>
</ol>
</li>
<li><p>使用要求</p>
<ol>
<li>如果是基本类型或者 String 类型： 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) </li>
<li>如果是 POJO 类型，或者它的关联对象： 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。 </li>
<li>如果是集合类型,有两种方式：<ul>
<li>第一种： 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。 </li>
<li>第二种： 接收的请求参数是 json 格式数据。需要借助一个注解实现</li>
</ul>
</li>
</ol>
</li>
<li><p>使用演示</p>
<ol>
<li><p>基本类型和 String 类型作为参数：参数名称必须和控制器中方法的形参名称保持一致</p>
<pre><code class="java">jsp 代码：
&lt;!-- 基本类型示例 --&gt;
&lt;a href=&quot;findAccount?accountId=10&amp;accountName=zhangsan&quot;&gt;查询账户&lt;/a&gt;
控制器代码：
/**
* 查询账户
*/
@RequestMapping(&quot;/findAccount&quot;)
public String findAccount(Integer accountId,String accountName) &#123;
    System.out.println(&quot;查询了账户。。。。&quot;+accountId+&quot;,&quot;+accountName);
    return &quot;success&quot;;
&#125;
</code></pre>
</li>
<li><p>POJO 类型作为参数</p>
<pre><code class="java">/**
* 账户信息
*/
public class Account&#123;
    private Integer id;
    private String name;
    private Float money;
    private Address address;
//getters and setters
//toString()
&#125;
/**
* 地址的实体类
*/
public class Address&#123;
    private String provinceName;
    private String cityName;
//getters and setters
//toString()
&#125;
</code></pre>
<p>jsp代码</p>
<pre><code class="jsp">&lt;!-- pojo 类型演示 --&gt;
&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;
账户名称：&lt;input type=&quot;text&quot; name=&quot;name&quot; &gt;&lt;br/&gt;
账户金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; &gt;&lt;br/&gt;
账户省份：&lt;input type=&quot;text&quot; name=&quot;address.provinceName&quot; &gt;&lt;br/&gt;
账户城市：&lt;input type=&quot;text&quot; name=&quot;address.cityName&quot; &gt;&lt;br/&gt;
&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>conroller</p>
<pre><code class="java">/**
* 保存账户
*/
@RequestMapping(&quot;/saveAccount&quot;)
public String saveAccount(Account account) &#123;
    System.out.println(&quot;保存了账户。。。。&quot;+account);
    return &quot;success&quot;;
&#125;
//Account&#123;id=null, name=&#39;zhangsan&#39;, money=123.0, address=Address&#123;provinceName=&#39;zhans&#39;, cityName=&#39;dasasof&#39;&#125;&#125;
</code></pre>
</li>
</ol>
<ul>
<li><p>POJO 类中包含集合类型参数</p>
<pre><code class="java">public class User&#123;
    private String username;
    private String password;
    private Integer age;
    private List&lt;Account&gt; accounts;
    private Map&lt;String,Account&gt; accountMap;
    //getters and setters
    //toString()
&#125;
</code></pre>
<p>jsp格式</p>
<pre><code class="jsp">&lt;form action=&quot;account/updateAccount&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;
    用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;
    账户 1 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[0].name&quot; &gt;&lt;br/&gt;
    账户 1 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[0].money&quot; &gt;&lt;br/&gt;
    账户 2 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[1].name&quot; &gt;&lt;br/&gt;
    账户 2 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[1].money&quot; &gt;&lt;br/&gt;
    账户 3 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].name&quot; &gt;&lt;br/&gt;
    账户 3 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].money&quot; &gt;&lt;br/&gt;
    账户 4 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].name&quot; &gt;&lt;br/&gt;
    账户 4 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].money&quot; &gt;&lt;br/&gt;
&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@RequestMapping(&quot;/updateAccount&quot;)
public String updateAccount(User user) &#123;
    System.out.println(&quot;更新了账户。。。。&quot;+user);
    return &quot;success&quot;;
&#125;
//结果：更新了账户。。。。User&#123;username=&#39;bychai&#39;, password=&#39;123&#39;, age=123, 
//accounts=[Account&#123;id=null, name=&#39;hsnd&#39;, money=123.0, address=null&#125;, Account&#123;id=null, name=&#39;xjsdf&#39;, money=456.0, address=null&#125;], 
//accountMap=&#123;one=Account&#123;id=null, name=&#39;xchoa&#39;, money=13.0, address=null&#125;, two=Account&#123;id=null, name=&#39;zhjka&#39;, money=56.0, address=null&#125;&#125;&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-6-请求参数乱码问题"><a href="#1-6-请求参数乱码问题" class="headerlink" title="1.6 请求参数乱码问题"></a>1.6 请求参数乱码问题</h3><ul>
<li>如果中文有乱码，需要配置字符编码过滤器，且配置其他过滤器之前， 如（HiddenHttpMethodFilter），否则不起作用。</li>
</ul>
<pre><code class="xml">post 请求方式：
在 web.xml 中配置一个过滤器
&lt;!-- 配置 springMVC 编码过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; 
    &lt;!-- 设置过滤器中的属性值 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
         &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!-- 启动过滤器 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;!-- 过滤所有请求 --&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

get 请求方式：
tomacat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 tomcat 的 server.xml
配置文件，如下：
&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
改为：
&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;
如果遇到 ajax 请求仍然乱码，请把：useBodyEncodingForURI=&quot;true&quot;改为 URIEncoding=&quot;UTF-8&quot;即可。
</code></pre>
<h3 id="1-7-其他请求参数"><a href="#1-7-其他请求参数" class="headerlink" title="1.7 其他请求参数"></a>1.7 其他请求参数</h3><p>MVC 的 Handler 方法可以接受哪些 ServletAPI 类型的参数</p>
<ul>
<li>HttpServletRequest</li>
<li>HttpServletResponse</li>
<li>HttpSession</li>
<li>java.security.Principal </li>
<li>Locale</li>
<li>InputStream </li>
<li>OutputStream </li>
<li>Reader</li>
<li>Writer</li>
</ul>
<p>除了表单传进来的参数，还可以使用servlet中的参数</p>
<pre><code class="java">/**
* 可以使用 Serlvet 原生的 API 作为目标方法的参数 具体支持以下类型
* HttpServletRequest
* HttpServletResponse
* HttpSession
* java.security.Principal
* Locale InputStream
* OutputStream
* Reader
* Writer
* @throws IOException
*/
@RequestMapping(&quot;/testServletAPI&quot;)
public void testServletAPI(HttpServletRequest request,HttpServletResponse response, Writer out) throws IOException &#123;
    //1、使用 request 转向页面，如下：
    request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response);
    //2、也可以通过 response 页面重定向：
    response.sendRedirect(&quot;testRetrunString&quot;)
    //3、也可以通过 response 指定响应结果，例如响应 json 数据：
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;application/json;charset=utf-8&quot;);
    response.getWriter().write(&quot;json 串&quot;);

&#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC基本使用-下篇</title>
    <url>/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<h2 id="SpringMVC基本使用-下篇"><a href="#SpringMVC基本使用-下篇" class="headerlink" title="SpringMVC基本使用-下篇"></a>SpringMVC基本使用-下篇</h2><h3 id="1-1-数据响应"><a href="#1-1-数据响应" class="headerlink" title="1.1 数据响应"></a>1.1 数据响应</h3><h4 id="1-1-1-返回值分类"><a href="#1-1-1-返回值分类" class="headerlink" title="1.1.1 返回值分类"></a>1.1.1 返回值分类</h4><ul>
<li><p>字符串：controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 //指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp </p>
<pre><code class="java">@RequestMapping(&quot;/testReturnString&quot;) 
public String testReturnString() &#123; 
    System.out.println(&quot;AccountController 的 testReturnString 方法执行了。。。。&quot;); 
    return &quot;success&quot;; 
&#125;
</code></pre>
</li>
<li><p>void在：controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果：</p>
<pre><code class="java">@RequestMapping(&quot;/testServletAPI&quot;)
public void testServletAPI(HttpServletRequest request,HttpServletResponse response, Writer out) throws IOException &#123;
    //1、使用 request 转向页面，如下：
    request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response);
    //2、也可以通过 response 页面重定向：
    response.sendRedirect(&quot;testRetrunString&quot;)
    //3、也可以通过 response 指定响应结果，例如响应 json 数据：
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;application/json;charset=utf-8&quot;);
    response.getWriter().write(&quot;json 串&quot;);

&#125;
</code></pre>
</li>
<li><p>ModelAndView：ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p>
<ul>
<li>控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。</li>
<li>两个重要的成员变量: <ul>
<li>private Object view; 视图信息 </li>
<li>private ModelMap model; 模型数据</li>
</ul>
</li>
<li>添加模型数据: <ul>
<li><code>MoelAndView addObject(String attributeName, Object attributeValue)</code> 设置模型数据 </li>
<li>ModelAndView addAllObject(Map modelMap) </li>
</ul>
</li>
<li>设置视图: <ul>
<li>void setView(View view) 设置视图对象 </li>
<li><code>void setViewName(String viewName)</code>  设置视图名字</li>
</ul>
</li>
<li>获取模型数据<ul>
<li> protected Map getModelInternal() 获取模型数据 </li>
<li>public ModelMap getModelMap() </li>
<li>public Map getModel()</li>
</ul>
</li>
</ul>
<pre><code class="java">/**
* 目标方法的返回类型可以是 ModelAndView 类型
* 其中包含视图信息和模型数据信息
*/
@RequestMapping(&quot;/testModelAndView&quot;)
public ModelAndView testModelAndView()&#123;
    ModelAndView mv = new ModelAndView();
    mv.addObject(&quot;username&quot;, &quot;张三&quot;);//实质上存放到 request 域中
    mv.setViewName(&quot;success&quot;);
    return mv;
&#125;
</code></pre>
<p>jsp页面</p>
<pre><code class="xml">&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;执行成功&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    执行成功！
    $&#123;requestScope.username&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>注意</strong>： 我们在页面上上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏 览器跳转只能是请求转发。</p>
</li>
<li><p>逻辑视图和物理视图</p>
<ul>
<li>在控制器方法中直接通过 ModelAndView.setView(View v)方法设置视图对象，然后返回ModelAndView给前端控制器，这时的视图就是物理视图，因为它前端控制器不需要再使用视图解析器来解析它，直接讲视图内容响应给客户端</li>
<li>而通过 控制器方法返回一个字符串，或者是通过 ModelAndView.setViewName(String viewName) 方法设置一个视图名，此时的视图成为逻辑视图，因为前端控制器需要通过视图解析器来解析逻辑视图名，得到一个视图对象，然后才响应给客户端。</li>
</ul>
</li>
<li><p>Map和Model</p>
<ul>
<li><p>Spring MVC 在内部使用了一个 org.springframework.ui.Model 接口存储模型数据 </p>
</li>
<li><p>具体使用步骤 </p>
<ul>
<li>Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。</li>
<li>如果方法的形参为 Map 或 Model 类型，Spring MVC 会将隐含模型的引用传递给这些形参。</li>
<li>在方法体内，开发者可以通过这个形参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据</li>
</ul>
</li>
<li><p>代码示例</p>
<pre><code class="java">//目标方法的返回类型也可以是一个 Map 类型参数（也可以是 Model,或 ModelMap 类型）
@RequestMapping(&quot;/testMap&quot;)
public String testMap(Map&lt;String,Object&gt; map)&#123; //【重点】
    System.out.println(map.getClass().getName());
    //org.springframework.validation.support.BindingAwareModelMap
    map.put(&quot;names&quot;, Arrays.asList(&quot;Tom&quot;,&quot;Jerry&quot;,&quot;Kite&quot;));
    return &quot;success&quot;;
&#125;
</code></pre>
<p>success页面</p>
<pre><code class="xml">&lt;body&gt;
    names: $&#123;requestScope.names &#125;
&lt;/body&gt;
</code></pre>
<p>结果：names:[Tom,Jerry,Kite]</p>
<p>注意： Map 集合的泛型，key 为 String,Value 为 Object,而不是 String</p>
<pre><code class="java">/目标方法的返回类型也可以是一个 Map 类型参数（也可以是 Model,或 ModelMap 类型）
@RequestMapping(&quot;/testMap2&quot;)
public String testMap2(Map&lt;String,Object&gt; map,Model model,ModelMap modelMap)&#123;
    System.out.println(map.getClass().getName());
    map.put(&quot;names&quot;, Arrays.asList(&quot;Tom&quot;,&quot;Jerry&quot;,&quot;Kite&quot;));
    model.addAttribute(&quot;model&quot;, &quot;org.springframework.ui.Model&quot;);
    modelMap.put(&quot;modelMap&quot;, &quot;org.springframework.ui.ModelMap&quot;);
    System.out.println(map == model);
    System.out.println(map == modelMap);
    System.out.println(model == modelMap);
    System.out.println(map.getClass().getName());
    System.out.println(model.getClass().getName());
    System.out.println(modelMap.getClass().getName());
    /*
    true
    true
    true
    org.springframework.validation.support.BindingAwareModelMap
    org.springframework.validation.support.BindingAwareModelMap
    org.springframework.validation.support.BindingAwareModelMap
     */
    return &quot;success&quot;;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-2转发和重定向"><a href="#1-1-2转发和重定向" class="headerlink" title="1.1.2转发和重定向"></a>1.1.2转发和重定向</h4><ul>
<li><p>forward转发：controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p>
<pre><code class="java">/**
* 转发
*/
@RequestMapping(&quot;/testForward&quot;)
public String testForward() &#123;
    System.out.println(&quot;AccountController 的 testForward 方法执行了。。。。&quot;);
    return &quot;forward:/WEB-INF/pages/success.jsp&quot;;
&#125;
</code></pre>
<p>需要注意的是，如果用了 formward：则路径必须写成实际视图 url，不能写逻辑视图。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</p>
</li>
<li><p>Redirect 重定向：contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect:</p>
<pre><code class="java">/**
* 重定向
* @return
*/
@RequestMapping(&quot;/testRedirect&quot;)
public String testRedirect() &#123;
    System.out.println(&quot;AccountController 的 testRedirect 方法执行了。。。。&quot;);
    return &quot;redirect:testReturnModelAndView&quot;;
&#125;
</code></pre>
<p>它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不 能写在 WEB-INF 目录中，否则无法找到</p>
</li>
</ul>
<h3 id="1-2-ResponseBody注解响应-json-数据"><a href="#1-2-ResponseBody注解响应-json-数据" class="headerlink" title="1.2 ResponseBody注解响应 json 数据"></a>1.2 ResponseBody注解响应 json 数据</h3><h4 id="1-2-1-Json"><a href="#1-2-1-Json" class="headerlink" title="1.2.1 Json"></a>1.2.1 Json</h4><p>json三个知识点</p>
<ol>
<li><p>Json有两种格式</p>
<ol>
<li>json对象：{id:1,name:zhansan,age:23,gender:nan}</li>
<li>json数组：[value1,value2,value3…] value1是一个json对象</li>
<li>如果一个json数据是{}包起来的，一定是一个json对象</li>
<li>如果一个json数据是[]包起来的，一定是多个json对象组成的json数组</li>
</ol>
</li>
<li><p>json对象解析方式：data.key；json数组解析方式：for循环遍历</p>
</li>
<li><p>bean对象转换为json</p>
<ol>
<li>bean和map——&gt;json对象</li>
<li>list——-&gt;json数组</li>
</ol>
</li>
</ol>
<p>springMVC默认以jackSon处理json，不需要写转换json的过程，默认为jackSon</p>
<h4 id="1-2-2-使用示例"><a href="#1-2-2-使用示例" class="headerlink" title="1.2.2 使用示例"></a>1.2.2 使用示例</h4><p>ResponseBody作用： </p>
<ul>
<li>该注解用于将 Controller 的方法返回的对象，通过HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端</li>
<li>将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据</li>
</ul>
<p>使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。 </p>
<p>添加jar包： Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入 jackson 的包。</p>
<ul>
<li><p><code>jackson-annotations-2.9.0.jar</code> </p>
</li>
<li><p><code>jackson-core-2.9.0.jar</code> </p>
</li>
<li><p><code>jackson-databind-2.9.0.jar</code></p>
</li>
</ul>
<pre><code class="java">jsp 中的代码：
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        $(&quot;#testJson&quot;).click(function()&#123;
            $.ajax(&#123;
                type:&quot;post&quot;,
                url:&quot;$&#123;pageContext.request.contextPath&#125;/testResponseJson&quot;,
                contentType:&quot;application/json;charset=utf-8&quot;,
                data:&#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;money&quot;:999.0&#125;&#39;,
                dataType:&quot;json&quot;,
                success:function(data)&#123;
                    alert(data);
                &#125;
            &#125;);
        &#125;);
    &#125;)
&lt;/script&gt;
&lt;!-- 测试异步请求 --&gt;
&lt;input type=&quot;button&quot; value=&quot;测试 ajax 请求 json 和响应 json&quot; id=&quot;testJson&quot;/&gt;
控制器中的代码：
/**
* 响应 json 数据的控制器
* 客户端通过ajax发送&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;money&quot;:999.0&#125;格式的json数据，@RequestBody注解接收请求体，服务器也就接收到了
* &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;money&quot;:999.0&#125;，加上@ResponseBody则通过json数据格式返回给客户端，因为我们已经导入Jackson的包
*/
@Controller(&quot;jsonController&quot;)
public class JsonController &#123;
    /**
    * 测试响应 json 数据
    */
    @ResponseBody
    @RequestMapping(&quot;/testResponseJson&quot;)
    public Account testResponseJson(@RequestBody Account account) &#123;
        System.out.println(&quot;异步请求：&quot;+account);
        return account;
    &#125;
&#125;
</code></pre>
<h3 id="1-3-文件上传与下载"><a href="#1-3-文件上传与下载" class="headerlink" title="1.3 文件上传与下载"></a>1.3 文件上传与下载</h3><h4 id="1-3-1-文件上传"><a href="#1-3-1-文件上传" class="headerlink" title="1.3.1 文件上传"></a>1.3.1 文件上传</h4><ul>
<li><p> Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。</p>
</li>
<li><p>Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类： CommonsMultipartResolver </p>
</li>
<li><p>Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用Spring的文件上传功 能 ， 需现在上下文中配置MultipartResolver</p>
</li>
<li><p>配置 MultipartResolver defaultEncoding: </p>
<ul>
<li><p>必须和用户 JSP 的 pageEncoding 属性一致，以便正确解析表单的内 容 , 为了让 CommonsMultipartResolver 正确工作，必须先 Jakarta Commons FileUpload 及 Jakarta Commons io 的类包添加到类路径下。</p>
</li>
<li><p>加入这两个jar包：<code>commons-fileupload-1.2.1.jar</code> <code>commons-io-2.0.jar</code></p>
</li>
<li><p>配置文件上传解析器，在SpringMVC.xml中配置</p>
<pre><code class="jsp">&lt;!-- 
        处理文件，将客户端上传的File文件，处理为MultipartFile
        注意：文件解析器的bean中id必须设置为multipartResolver
     --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 设置文件解析的编码，注意：一定要和页面的pageEncoding保持一致 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;
    &lt;!-- 设置最大上传文件大小 --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;88888888&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>jsp页面要求：</p>
<ul>
<li><p>form 表单的 enctype 取值必须是：multipart/form-data (默认值是:application/x-www-form-urlencoded) enctype:是表单请求正文的类型</p>
</li>
<li><p> method 属性取值必须是 Post </p>
</li>
<li><p>提供一个文件选择域</p>
<pre><code class="jsp">&lt;body&gt;
&lt;form action=&quot;testUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    文件: &lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt;&lt;br&gt;&lt;br&gt;
    描述: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;&lt;br&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>控制器页面</p>
<pre><code class="java">@RequestMapping(value=&quot;/up&quot;, method=RequestMethod.POST)
    public String up(String desc, MultipartFile uploadFile, HttpSession session) throws IOException &#123;
        //获取上传文件的名称
        String fileName = uploadFile.getOriginalFilename();
        String finalFileName = UUID.randomUUID() + fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
        //UUID.randomUUID()生成的唯一识别码，再加上文件上传名称以.结尾的后缀名.jpg，构成唯一的文件名，不会重复
        
        //设置上传路径
        String path = session.getServletContext().getRealPath(&quot;photo&quot;) + File.separator + finalFileName;
        
        File file = new File(path);
        uploadFile.transferTo(file);
        //把uploadFile转化到file，把上传的文件转换到服务器里面的文件
        return &quot;success&quot;;
    &#125;
</code></pre>
</li>
</ul>
<h4 id="1-3-2-文件下载"><a href="#1-3-2-文件下载" class="headerlink" title="1.3.2 文件下载"></a>1.3.2 文件下载</h4><pre><code class="java">jsp页面
&lt;a href=&quot;dodwn&quot;&gt;下载图片&lt;/a&gt;
    
@RequestMapping(&quot;/down&quot;)
    public ResponseEntity&lt;byte[]&gt; down(HttpSession session) throws IOException&#123;
        
        //获取下载文件的路径（服务器下载文件路径，通过session获取）
        String realPath = session.getServletContext().getRealPath(&quot;img&quot;);
        //获得真实路径，服务器编译项目存放的路径，不是编译器的工作空间
        //getRealPath(&quot;&quot;):获取项目路径，getRealPath(&quot;img&quot;):获取项目下的img文件夹的路径
        
        String finalPath = realPath + File.separator + &quot;2.jpg&quot;;
        //最终路径，File.separator：文件分隔符：&quot;/&quot; 文件名称写死了2.jpg,
        
        InputStream is = new FileInputStream(finalPath);
        
        //available():获取输入流所读取的文件的最大字节数
        byte[] b = new byte[is.available()];
        is.read(b);
        //设置请求头
        HttpHeaders headers = new  HttpHeaders();
        headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=zzz.jpg&quot;);
        //设置响应状态
        HttpStatus statusCode = HttpStatus.OK;
        ResponseEntity&lt;byte[]&gt; entity = new ResponseEntity&lt;byte[]&gt;(b, headers, statusCode);
        return entity;
    &#125;
</code></pre>
<h3 id="1-4-拦截器"><a href="#1-4-拦截器" class="headerlink" title="1.4 拦截器"></a>1.4 拦截器</h3><h4 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h4><p>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 使用拦截器对请求进行拦截处理</p>
<p><strong>拦截器链（Interceptor Chain）</strong>。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 </p>
<p>拦截器和过滤器的区别： </p>
<ul>
<li><p>过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 </p>
</li>
<li><p>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 </p>
</li>
<li><p>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 </p>
</li>
<li><p>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。</p>
</li>
</ul>
<p>拦截器和过滤器的作用地点</p>
<p>​    <img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926102359619.png" alt="image-20200926102359619"></p>
<p><strong>拦截器也是 AOP 思想的具体应用</strong>。 </p>
<p>用户可以自定义拦截器来实现特定的功能 ，自定义的拦截器可以实现HandlerInterceptor接口 ，也可以继承HandlerInterceptorAdapter 适配器类 ，其中有三个方法：</p>
<ul>
<li>① <strong>preHandle()**：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他 的拦截器，或者是业务处理器去进行处理，</strong>则返回 true<strong>，</strong>放行**；如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。 </li>
<li>② **postHandle()**：这个方法在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求 request 进行处理。（ModelAndView中的Model装载成功，view也已经获取成功了，只是没有往客户端跳转或响应） </li>
<li>③ **afterCompletion()**：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以 在该方法中进行一些资源清理的操作。</li>
</ul>
<p><img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926102848496.png" alt="image-20200926102848496"></p>
<h4 id="1-4-2-单个拦截器"><a href="#1-4-2-单个拦截器" class="headerlink" title="1.4.2 单个拦截器"></a>1.4.2 单个拦截器</h4><pre><code class="java">/**
* 自定义拦截器
*/
public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception &#123;
        System.out.println(&quot;preHandle 拦截器拦截了&quot;);
        return true;
    &#125;
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,Objecthandler,ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;postHandle 方法执行了&quot;);
    &#125;
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;afterCompletion 方法执行了&quot;);
    &#125;
&#125;
</code></pre>
<p>配置SpringMVC配置文件</p>
<pre><code class="xml">&lt;!-- 配置拦截器 --&gt;
&lt;mvc:interceptors&gt;
    &lt;!-- 默认拦截所有请求 --&gt;
    &lt;bean class=&quot;com.review.interceptor.handlerInterceptorDemo1&quot;&gt;&lt;/bean&gt;
    &lt;!-- 此方式要求拦截器类上必须加注解@Component --&gt;
    &lt;!-- &lt;ref bean=&quot;handlerInterceptorDemo1&quot;/&gt; --&gt;

    &lt;!-- 设置自定义拦截方式 --&gt;
    &lt;!-- 
    &lt;mvc:interceptor&gt;
        &lt;bean id=&quot;handlerInterceptorDemo1&quot; class=&quot;com.review.interceptor.handlerInterceptorDemo1&quot;&gt;&lt;/bean&gt;
        &lt;mvc:mapping path=&quot;&quot;/&gt;  用于指定对拦截的 url
        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;  用于指定排除的 url
      &lt;/mvc:interceptor&gt; 
    --&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>测试文件</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/account&quot;)
public class TestController &#123;
    @RequestMapping(value=&quot;/saveAccount&quot;)
    public String hello() &#123;
        System.out.println(&quot;控制器中的代码&quot;);
        return &quot;success&quot;;//视图名称
    &#125;
&#125;
//结果：
preHandle 拦截器拦截了
控制器中的代码
postHandle 方法执行了
afterCompletion 方法执行了
</code></pre>
<h4 id="1-4-2-多个拦截器"><a href="#1-4-2-多个拦截器" class="headerlink" title="1.4.2 多个拦截器"></a>1.4.2 多个拦截器</h4><p>拦截器方法说明</p>
<pre><code class="java">public interface HandlerInterceptor &#123;
    /**
    * 如何调用：
    *     按拦截器定义顺序调用
    * 何时调用：
    *     只要配置了都会调用
    * 有什么用：
    *     如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去
    *     进行处理，则返回 true。
    *     如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。
    */
    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        return true;
    &#125;

    /**
    * 如何调用：
    *     按拦截器定义逆序调用
    * 何时调用：
    *     在拦截器链内所有拦截器返成功调用
    * 有什么用：
    *     在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，
    *     在该方法中对用户请求 request 进行处理。
    */
    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object                     handler,@Nullable ModelAndView modelAndView) throws Exception &#123;
    &#125;
    /**
    * 如何调用：
    *     按拦截器定义逆序调用
    * 何时调用：
    *     只有 preHandle 返回 true 才调用
    * 有什么用：
    *     在 DispatcherServlet 完全处理完请求后被调用，
    *     可以在该方法中进行一些资源清理的操作。
    */
    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object                 handler,@Nullable Exception ex) throws Exception &#123;
    &#125;
&#125;
</code></pre>
<p>多个拦截器是按照配置的顺序决定的。</p>
<p>例如springMVC.xml配置文件</p>
<pre><code class="xml">&lt;mvc:interceptors&gt;
        &lt;!-- 默认拦截所有请求 --&gt;
        &lt;bean class=&quot;com.review.interceptor.HandlerInterceptorDemo1&quot;&gt;&lt;/bean&gt;
        &lt;bean class=&quot;com.review.interceptor.HandlerInterceptorDemo2&quot;&gt;&lt;/bean&gt;
        
        &lt;!-- 设置自定义拦截方式 --&gt;
        &lt;!-- 
        &lt;mvc:interceptor&gt;
            &lt;bean class=&quot;com.review.interceptor.HandlerInterceptorDemo1&quot;&gt;&lt;/bean&gt;
            &lt;mvc:mapping path=&quot;&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;
        &lt;/mvc:interceptor&gt; 
        &lt;mvc:interceptor&gt;
            &lt;bean class=&quot;com.review.interceptor.HandlerInterceptorDemo2&quot;&gt;&lt;/bean&gt;
            &lt;mvc:mapping path=&quot;&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;
        &lt;/mvc:interceptor&gt;
        --&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<p>先执行HandlerInterceptorDemo1的preHandle(),以下是流程图</p>
<p><img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926111318305.png" alt="image-20200926111318305"></p>
<p>结果可以按照上图查看：</p>
<p>两个拦截器的preHandle方法都是返回 true : 结果</p>
<p><img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926112235782.png" alt="image-20200926112235782"></p>
<p>第二个拦截器的preHandle方法都是返回false : 结果</p>
<p><img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926112307605.png" alt="image-20200926112307605"></p>
<h3 id="1-5-异常处理"><a href="#1-5-异常处理" class="headerlink" title="1.5 异常处理"></a>1.5 异常处理</h3><p>系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 </p>
<p>Spring MVC 通过 <code>HandlerExceptionResolver</code> 处理程序的异常，包括 Handler 映射、数 据绑定以及目标方法执行时发生的异常。</p>
<p>系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端 控制器交由异常处理器进行异常处理，如下图：</p>
<p><img src="/2020/09/29/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%8B%E7%AF%87/image-20200926112724673.png" alt="image-20200926112724673"></p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>自定义异常</p>
<pre><code class="java">/**
* 自定义异常类
*/
public class CustomException extends Exception &#123;
    private String message;//存储异常信息
    //构造方法,新建此异常类必须传入异常信息
    public CustomException(String message) &#123;
        this.message = message;
    &#125;
    //get方法
    public String getMessage() &#123;
        return message;
    &#125;
&#125;
</code></pre>
<p>controller代码</p>
<pre><code class="java">@RequestMapping(&quot;/test&quot;)
    public String test() throws CustomException&#123;
        try &#123;
            int a=10/0
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            //抛出自定义的异常，上面已经声明此类
            throw new  CustomException(&quot;异常信息&quot;);
        &#125;
        return &quot;success&quot;;//没异常，返回正确页面
    &#125;
</code></pre>
<p>jsp页面</p>
<pre><code class="jsp">&lt;body&gt;
执行失败！
$&#123;message &#125;
&lt;/body&gt;
</code></pre>
<p>自定义异常处理器</p>
<pre><code class="java">/**
* 自定义异常处理器
*/
public class CustomExceptionResolver implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest request,HttpServletResponse response, Object handler, Exception ex) &#123;
        //获取异常对象，上面自定义的异常类
        CustomException customException = null;
        //如果抛出的是系统自定义异常则直接转换为自定义异常对象，ex是接收到的异常
        if(ex instanceof CustomException)&#123;
            customException = (CustomException)ex;
        &#125;else&#123;
            //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。
            customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;);
        &#125;
        //创建ModelAndView对象
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(&quot;message&quot;, customException.getMessage());//存入自定义类中的message信息
        modelAndView.setViewName(&quot;error&quot;);//跳转到error.jsp页面跳
        return modelAndView;
    &#125;
&#125;
</code></pre>
<p>在SpringMVC中配置异常处理器</p>
<pre><code class="xml">&lt;!-- 配置自定义异常处理器 id固定--&gt;
&lt;bean id=&quot;handlerExceptionResolver&quot;
class=&quot;com.review.exception.CustomExceptionResolver&quot;/&gt;
</code></pre>
<h4 id="默认处理异常"><a href="#默认处理异常" class="headerlink" title="默认处理异常"></a>默认处理异常</h4><p>上面是自定义异常处理器来处理异常，我们还可以使用默认的异常处理器来处理异常</p>
<p><code>SimpleMappingExceptionResolver</code></p>
<p>如果希望对所有异常进行统一处理，可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常</p>
<p>例如：springMVC.xml配置的是空指针异常NullPointerException，出现此异常就返回到<code>error.jsp</code>页面</p>
<pre><code class="xml">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
        &lt;property name=&quot;exceptionMappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;error&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<p>控制器代码出现空指针异常</p>
<pre><code class="java">@Controller
public class TestExceptionController &#123;

    @RequestMapping(value=&quot;/testException&quot;, method=RequestMethod.GET)
    public String testException() &#123;
        int a=10/0;
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC基本使用-中篇</title>
    <url>/2020/09/28/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%AD%E7%AF%87/</url>
    <content><![CDATA[<h2 id="SpringMVC基本使用-中篇"><a href="#SpringMVC基本使用-中篇" class="headerlink" title="SpringMVC基本使用-中篇"></a>SpringMVC基本使用-中篇</h2><h3 id="1-1-REST"><a href="#1-1-REST" class="headerlink" title="1.1 REST"></a>1.1 REST</h3><h4 id="1-1-1-概述：："><a href="#1-1-1-概述：：" class="headerlink" title="1.1.1 概述：："></a>1.1.1 概述：：</h4><ul>
<li>REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用</li>
<li>资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。 它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一 资源定位符）指向它，每种资源对应一个特定的 URI 。要 获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。 </li>
<li>表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。 比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二 进制格式。 </li>
<li>状态转化（State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。 HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以 就是 “表现层状态转化”。</li>
<li>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT、 DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来 删除资源。</li>
</ul>
<h4 id="1-1-2-HiddenHttpMethodFilter-过滤器"><a href="#1-1-2-HiddenHttpMethodFilter-过滤器" class="headerlink" title="1.1.2 HiddenHttpMethodFilter 过滤器"></a>1.1.2 HiddenHttpMethodFilter 过滤器</h4><ol>
<li><p>浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不 支持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使 得支持 GET、POST、PUT 与 DELETE 请求。</p>
</li>
<li><p>使用方法： </p>
<ul>
<li>在 web.xml 中配置HiddenHttpMethodFilter过滤器。 </li>
</ul>
<p>web.xml配置文件</p>
<pre><code class="xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
</li>
</ol>
<h4 id="1-1-3PathVariable-注解"><a href="#1-1-3PathVariable-注解" class="headerlink" title="1.1.3PathVariable 注解"></a>1.1.3PathVariable 注解</h4><ul>
<li>作用： 用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。 </li>
<li>属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。</li>
</ul>
<h4 id="1-1-4-REST实现过程"><a href="#1-1-4-REST实现过程" class="headerlink" title="1.1.4 REST实现过程"></a>1.1.4 REST实现过程</h4><ul>
<li><p>第一步：在 web.xml 中配置HiddenHttpMethodFilter过滤器。 </p>
</li>
<li><p>第二步：请求方式必须使用 post 请求。 </p>
</li>
<li><p>第三步：按照要求提供带有_method 请求参数隐藏域，该参数的取值就是我们需要的请求方式（PUT或DELETE）。</p>
<p>JSP文件</p>
<pre><code class="jsp">&lt;!-- 保存 POST--&gt;
&lt;form action=&quot;springmvc/testRestPOST&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    &lt;!-- &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;POST&quot;&gt; --&gt;
    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
&lt;hr/&gt;
&lt;!-- 更新 PUT--&gt;
&lt;form action=&quot;springmvc/testRestPUT/1&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;更新&quot;&gt;
&lt;/form&gt;
&lt;!-- 删除 DELETE--&gt;
&lt;form action=&quot;springmvc/testRestDELETE/1&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;删除&quot;&gt;
&lt;/form&gt;
&lt;hr/&gt;
&lt;!-- 查询一个 GET，也可以直接使用超链接--&gt;
&lt;form action=&quot;springmvc/testRestGET/1&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;GET&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;
&lt;/form&gt; 
</code></pre>
<p>控制器代码</p>
<pre><code class="java">/**
* post 请求：保存
*/
@RequestMapping(value=&quot;/testRestPOST&quot;,method=RequestMethod.POST)
public String testRestfulURLPOST(User user)&#123;
    System.out.println(&quot;rest post&quot;+user);
    return &quot;success&quot;;
&#125;
/**
* put请求：更新，通过@PathVariable(&quot;id&quot;)获取URL中传递过来的&#123;id&#125;
*/
@RequestMapping(value=&quot;/testRestPUT/&#123;id&#125;&quot;,method=RequestMethod.PUT)
public String testRestfulURLPUT(@PathVariable(&quot;id&quot;)Integer id,User user)&#123;
    System.out.println(&quot;rest put &quot;+id+&quot;,&quot;+user);
    return &quot;success&quot;;
&#125;
/**
* post 请求：删除
*/
@RequestMapping(value=&quot;/testRestDELETE/&#123;id&#125;&quot;,method=RequestMethod.DELETE)
public String testRestfulURLDELETE(@PathVariable(&quot;id&quot;)Integer id)&#123;
    System.out.println(&quot;rest delete &quot;+id);
    return &quot;success&quot;;
&#125;
/**
* post 请求：查询
*/
@RequestMapping(value=&quot;/testRestGET/&#123;id&#125;&quot;,method=RequestMethod.GET)
public String testRestfulURLGET(@PathVariable(&quot;id&quot;)Integer id)&#123;
    System.out.println(&quot;rest get &quot;+id);
    return &quot;success&quot;;
&#125; 
</code></pre>
</li>
</ul>
<h3 id="1-2-SpringMVC常用注解"><a href="#1-2-SpringMVC常用注解" class="headerlink" title="1.2 SpringMVC常用注解"></a>1.2 SpringMVC常用注解</h3><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h4><ul>
<li><p>作用： 把请求中指定名称的参数给控制器中的形参赋值。 </p>
</li>
<li><p>属性： </p>
<ul>
<li>value：请求参数中的名称。 </li>
<li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</li>
<li>defaultValue: 默认值，当没有传递参数时使用该值</li>
</ul>
</li>
<li><p>使用示例</p>
<pre><code class="java">jsp 中的代码：
&lt;!-- requestParams 注解的使用 --&gt;
&lt;a href=&quot;springmvc/useRequestParam?name=test&amp;age=0&quot;&gt;requestParam 注解&lt;/a&gt;
控制器中的代码：
/**
* requestParams 注解的使用,
* 其中请求的参数的名称为name，方法中的参数为username，不匹配，可以使用@RequestParam注解将
* name的值赋值给username，
*/
@RequestMapping(&quot;/useRequestParam&quot;)
public String useRequestParam(@RequestParam(&quot;name&quot;)String username,
@RequestParam(value=&quot;age&quot;,required=false,defaultValue=&quot;0&quot;)Integer age)&#123;
System.out.println(username+&quot;,&quot;+age);
return &quot;success&quot;;
&#125;
</code></pre>
</li>
</ul>
<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h4><ul>
<li><p>作用： 用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。 <strong>get 请求方式不适用</strong>。 </p>
</li>
<li><p>属性： required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值 为 false，get 请求得到是 null。</p>
</li>
<li><p>使用示例</p>
<pre><code class="java">post 请求 jsp 代码：
&lt;!-- requestBody 注解 --&gt;
&lt;form action=&quot;springmvc/useRequestBody&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;
    用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;
&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
get 请求 jsp 代码：
&lt;a href=&quot;springmvc/useRequestBody?body=test&quot;&gt;requestBody 注解 get 请求&lt;/a&gt;
控制器代码：
/**
* RequestBody 注解
*/
@RequestMapping(&quot;/useRequestBody&quot;)
public String useRequestBody(@RequestBody(required=false) String body)&#123;
    System.out.println(body);
    return &quot;success&quot;;
&#125;
//结果：请求体的key为body
//post请求结果:username=admin&amp;password=123&amp;age=23
//get请求结果:null
</code></pre>
</li>
</ul>
<h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="RequestHeader"></a>RequestHeader</h4><ul>
<li><p>作用： 用于获取请求消息头。 </p>
</li>
<li><p>属性： value：提供消息头名称 required：是否必须有此消息头 注： 在实际开发中一般不怎么用。</p>
</li>
<li><p>使用示例</p>
<pre><code class="java">jsp 中代码：
&lt;!-- RequestHeader 注解 --&gt;
&lt;a href=&quot;springmvc/useRequestHeader&quot;&gt;获取请求消息头&lt;/a&gt;
控制器中代码：
/**
* RequestHeader 注解
* @param user
* @return
*/
@RequestMapping(&quot;/useRequestHeader&quot;)
public String useRequestHeader(@RequestHeader(value=&quot;Accept-Language&quot;,required=false)String requestHeader)&#123;
    System.out.println(requestHeader);
    return &quot;success&quot;;
&#125;
</code></pre>
</li>
</ul>
<h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h4><ul>
<li><p>作用： 用于把指定 cookie 名称的值传入控制器方法参数。 </p>
</li>
<li><p>属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。</p>
</li>
<li><p>使用示例：</p>
<pre><code class="java">jsp 中的代码：
&lt;!-- CookieValue 注解 --&gt;
&lt;a href=&quot;springmvc/useCookieValue&quot;&gt;绑定 cookie 的值&lt;/a&gt;
控制器中的代码：
/**
* Cookie 注解注解
*/
@RequestMapping(&quot;/useCookieValue&quot;)
public String useCookieValue(@CookieValue(value=&quot;JSESSIONID&quot;,required=false) String cookieValue)&#123;
    System.out.println(cookieValue);
    return &quot;success&quot;;
&#125;
</code></pre>
</li>
</ul>
<h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h4><ul>
<li><p>作用： 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 </p>
<ul>
<li>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 </li>
<li>出现在参数上，获取指定的数据给参数赋值。 </li>
</ul>
</li>
<li><p>属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。 </p>
</li>
<li><p>应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 </p>
<ul>
<li>例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。</li>
</ul>
</li>
<li><p>使用示例1：基于 POJO 属性的基本使用，加了此注解的方法会在控制器方法之前执行</p>
<pre><code class="java">jps 代码：
&lt;!-- ModelAttribute 注解的基本使用 --&gt;
&lt;a href=&quot;springmvc/testModelAttribute?username=test&quot;&gt;测试 modelattribute&lt;/a&gt;
控制器代码：
/**
* 接收请求的方法，未被ModelAttribute修饰的方法
*/
@RequestMapping(&quot;/testModelAttribute&quot;)
public String testModelAttribute(User user) &#123;
    System.out.println(&quot;执行了控制器的方法&quot;+user.getUsername());
    return &quot;success&quot;;
&#125;
/**
* 被 ModelAttribute 修饰的方法
*/
@ModelAttribute
public void showModel(User user) &#123;
    System.out.println(&quot;执行了 showModel 方法&quot;+user.getUsername());
&#125;
结果：
执行了 showModel 方法test
执行了控制器的方法test
</code></pre>
</li>
<li><p>使用示例2：基于 Map 的应用场景示例 ：ModelAttribute 修饰方法带返回值</p>
<pre><code class="java">需求： 修改用户信息，要求用户的密码不能修改
User类有三个属性，用户名，密码和年龄，表单提交了两个属性，没有提交密码，默认为null，在第一次执行showModel方法中，从数据库拿到user信息，其中包含的有密码，返回User对象，然后再传入testModelAttribute，这样传入的值就是表单传入的username和age外加数据库查到的密码

jsp 的代码：
&lt;!-- 修改用户信息 --&gt;
&lt;form action=&quot;springmvc/updateUser&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
控制的代码：
/**
* 查询数据库中用户信息,加了@ModelAttribute优先执行，在数据库查到user对象后传入testModelAttribute中修改用户
*/
@ModelAttribute
public User showModel(String username) &#123;
    //模拟去数据库查询
    User user = findUserByName(username);
    System.out.println(&quot;执行了 showModel 方法&quot;+user);
    return user;
&#125;
/**
* 模拟修改用户方法
*/
@RequestMapping(&quot;/updateUser&quot;)
public String testModelAttribute(User user) &#123;
    System.out.println(&quot;控制器中处理请求的方法：修改用户：&quot;+user);
    return &quot;success&quot;;
&#125;
/**
* 模拟去数据库查询
*/
private User findUserByName(String username) &#123;
    User user = new User();
    user.setUsername(username);
    user.setAge(19);
    user.setPassword(&quot;123456&quot;);
    return user;
&#125;
</code></pre>
</li>
<li><p>使用示例3：基于 Map 的应用场景示例 ：ModelAttribute 修饰方法不带返回值</p>
<pre><code class="java">需求：修改用户信息，要求用户的密码不能修改
User类有三个属性，用户名，密码和年龄，表单提交了两个属性，没有提交密码，默认为null，在第一次执行showModel方法中，从数据库拿到user信息，其中包含的有密码，因为没有返回值，所以保存在key为abc的map集合中，然后再通过在属性上加ModelAttribute注解，将key为abc的map集合中的值，赋值给user对象，再传入testModelAttribute，这样传入的值就是表单传入的username和age外加数据库查到的密码
jsp中的代码：
&lt;!-- 修改用户信息 --&gt;
&lt;form action=&quot;springmvc/updateUser&quot; method=&quot;post&quot;&gt;
    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;
&lt;/form&gt;
控制器中的代码：
/**
* 查询数据库中用户信息
*/
@ModelAttribute
public void showModel(String username,Map&lt;String,User&gt; map) &#123;
    //模拟去数据库查询
    User user = findUserByName(username);
    System.out.println(&quot;执行了 showModel 方法&quot;+user);
    map.put(&quot;abc&quot;,user);
&#125;
/**
* 模拟修改用户方法
*/
@RequestMapping(&quot;/updateUser&quot;)
public String testModelAttribute(@ModelAttribute(&quot;abc&quot;)User user) &#123;
    System.out.println(&quot;控制器中处理请求的方法：修改用户：&quot;+user);
    return &quot;success&quot;;
&#125;
/**
* 模拟去数据库查询
*/
private User findUserByName(String username) &#123;
    User user = new User();
    user.setUsername(username);
    user.setAge(19);
    user.setPassword(&quot;123456&quot;);
    return user;
&#125;
</code></pre>
</li>
</ul>
<h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="SessionAttribute"></a>SessionAttribute</h4><ul>
<li><p>作用： 用于多次执行控制器方法间的参数共享。 只能用在类上面</p>
</li>
<li><p>属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型。</p>
</li>
<li><p>使用示例：</p>
<pre><code class="java">jsp 中的代码：
&lt;!-- SessionAttribute 注解的使用 --&gt;
&lt;a href=&quot;springmvc/testPut&quot;&gt;存入 SessionAttribute&lt;/a&gt;
&lt;hr/&gt;
&lt;a href=&quot;springmvc/testGet&quot;&gt;取出 SessionAttribute&lt;/a&gt;
&lt;hr/&gt;
&lt;a href=&quot;springmvc/testClean&quot;&gt;清除 SessionAttribute&lt;/a&gt;
控制器中的代码：
/**
* SessionAttribute 注解的使用
*/
@Controller(&quot;sessionAttributeController&quot;)
@RequestMapping(&quot;/springmvc&quot;)
@SessionAttributes(value =&#123;&quot;username&quot;,&quot;password&quot;,&quot;age&quot;&#125;,types=&#123;String.class,String.class,Integer.class&#125;)//向Session中存值
public class SessionAttributeController &#123;
/**
* 把数据存入 SessionAttribute
* @param model
* @return
* Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap
* 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类
* 使用model可以直接将数据以键值对方式存入request域中，不需要定义HttpServletRequest，降低耦合
* 在类上加上SessionAttribute注解可以将数据再存入一份到Session中
*/
@RequestMapping(&quot;/testPut&quot;)
public String testPut(Model model)&#123;
     model.addAttribute(&quot;username&quot;, &quot;泰斯特&quot;);
     model.addAttribute(&quot;password&quot;,&quot;123456&quot;);
     model.addAttribute(&quot;age&quot;, 31);
     //跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有这几个参数
     return &quot;success&quot;;
 &#125;

 @RequestMapping(&quot;/testGet&quot;)
 public String testGet(ModelMap model)&#123;
    System.out.println(model.get(&quot;username&quot;)+&quot;;&quot;+model.get(&quot;password&quot;)+&quot;;&quot;+model.get(&quot;age&quot;));
     return &quot;success&quot;;//ModelMap中的get()方法时获取值
 &#125;

 @RequestMapping(&quot;/testClean&quot;)
 public String complete(SessionStatus sessionStatus)&#123;
     sessionStatus.setComplete();//SessionStatus类中的setComplete()是删除session中的值
     return &quot;success&quot;;
 &#125;
&#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 事务，连接池及DBUtils</title>
    <url>/2020/09/21/JDBC%20%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8F%8ADBUtils/</url>
    <content><![CDATA[<h2 id="一：-数据库事务"><a href="#一：-数据库事务" class="headerlink" title="一： 数据库事务"></a>一： 数据库事务</h2><h3 id="1-1-数据库事务介绍"><a href="#1-1-数据库事务介绍" class="headerlink" title="1.1 数据库事务介绍"></a>1.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都<strong>被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="1-2-JDBC事务处理"><a href="#1-2-JDBC事务处理" class="headerlink" title="1.2 JDBC事务处理"></a>1.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<pre><code class="java">public void testJDBCTransaction() &#123;
    Connection conn = null;
    try &#123;
        // 1.获取数据库连接
        conn = JDBCUtils.getConnection();
        // 2.开启事务
        conn.setAutoCommit(false);
        // 3.进行数据库操作
        String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;
        update(conn, sql1, &quot;AA&quot;);

        // 模拟网络异常
        //System.out.println(10 / 0);

        String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;
        update(conn, sql2, &quot;BB&quot;);
        // 4.若没有异常，则提交事务
        conn.commit();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
        // 5.若有异常，则回滚事务
        try &#123;
            conn.rollback();
        &#125; catch (SQLException e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125; finally &#123;
        try &#123;
            //6.恢复每次DML操作的自动提交功能
            conn.setAutoCommit(true);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //7.关闭连接
        JDBCUtils.closeResource(conn, null, null); 
    &#125;  
&#125;
</code></pre>
<p>其中，对数据库操作的方法为：</p>
<pre><code class="java">//使用事务以后的通用的增删改操作（version 2.0）
public void update(Connection conn ,String sql, Object... args) &#123;
    PreparedStatement ps = null;
    try &#123;
        // 1.获取PreparedStatement的实例 (或：预编译sql语句)
        ps = conn.prepareStatement(sql);
        // 2.填充占位符
        for (int i = 0; i &lt; args.length; i++) &#123;
            ps.setObject(i + 1, args[i]);
        &#125;
        // 3.执行sql语句
        ps.execute();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        // 4.关闭资源
        JDBCUtils.closeResource(null, ps);

    &#125;
&#125;
</code></pre>
<h3 id="1-3-事务的ACID属性"><a href="#1-3-事务的ACID属性" class="headerlink" title="1.3 事务的ACID属性"></a>1.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="1-3-1-数据库的并发问题"><a href="#1-3-1-数据库的并发问题" class="headerlink" title="1.3.1 数据库的并发问题"></a>1.3.1 数据库的并发问题</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h4 id="1-3-2-四种隔离级别"><a href="#1-3-2-四种隔离级别" class="headerlink" title="1.3.2 四种隔离级别"></a>1.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<p>![1555586275271](./JDBC 事务，连接池及DBUtils/1555586275271.png)</p>
</li>
<li><p>第一个什么都没解决，第二个解决了脏读，第三个解决了脏读和不可重复读，第四个全都解决了</p>
</li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="1-3-3-在MySql中设置隔离级别"><a href="#1-3-3-在MySql中设置隔离级别" class="headerlink" title="1.3.3 在MySql中设置隔离级别"></a>1.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>通过命令行方式启动mysql，登录进去输入命令</p>
</li>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<pre><code class="mysql">SELECT @@tx_isolation;
</code></pre>
</li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<pre><code class="mysql">set  transaction isolation level read committed;
</code></pre>
</li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<pre><code class="mysql">set global transaction isolation level read committed;
</code></pre>
</li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<pre><code class="mysql">create user tom identified by &#39;abc123&#39;;
</code></pre>
</li>
<li><p>授予权限</p>
<pre><code class="mysql">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.
grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;; 

 #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。
grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; 
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-4-java代码实现设置隔离级别"><a href="#1-3-4-java代码实现设置隔离级别" class="headerlink" title="1.3.4 java代码实现设置隔离级别"></a>1.3.4 java代码实现设置隔离级别</h4><pre><code class="java">@Test
    public void testTransactionSelect() throws Exception&#123;
        
        Connection conn = JDBCUtils.getConnection();
        //获取当前连接的隔离级别
        System.out.println(conn.getTransactionIsolation());
        //设置数据库的隔离级别：
        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        //取消自动提交数据
        conn.setAutoCommit(false);
        
        String sql = &quot;select user,password,balance from user_table where user = ?&quot;;
        User user = getInstance(conn, User.class, sql, &quot;CC&quot;);
        
        System.out.println(user);
        
    &#125;
    
    @Test
    public void testTransactionUpdate() throws Exception&#123;
        Connection conn = JDBCUtils.getConnection();
        
        //取消自动提交数据
        conn.setAutoCommit(false);
        String sql = &quot;update user_table set balance = ? where user = ?&quot;;
        update(conn, sql, 5000,&quot;CC&quot;);
        
        Thread.sleep(15000);
        System.out.println(&quot;修改结束&quot;);
    &#125;
    
    //通用的查询操作，用于返回数据表中的一条记录（version 2.0：考虑上事务）
    public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql, Object... args) &#123;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try &#123;
            ps = conn.prepareStatement(sql);
            for (int i = 0; i &lt; args.length; i++) &#123;
                ps.setObject(i + 1, args[i]);
            &#125;
            rs = ps.executeQuery();
            // 获取结果集的元数据 :ResultSetMetaData
            ResultSetMetaData rsmd = rs.getMetaData();
            // 通过ResultSetMetaData获取结果集中的列数
            int columnCount = rsmd.getColumnCount();

            if (rs.next()) &#123;
                T t = clazz.newInstance();
                // 处理结果集一行数据中的每一个列
                for (int i = 0; i &lt; columnCount; i++) &#123;
                    // 获取列值
                    Object columValue = rs.getObject(i + 1);

                    // 获取每个列的列名
                    // String columnName = rsmd.getColumnName(i + 1);
                    String columnLabel = rsmd.getColumnLabel(i + 1);

                    // 给t对象指定的columnName属性，赋值为columValue：通过反射
                    Field field = clazz.getDeclaredField(columnLabel);
                    field.setAccessible(true);
                    field.set(t, columValue);
                &#125;
                return t;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtils.closeResource(null, ps, rs);

        &#125;

        return null;
    &#125;
</code></pre>
<h2 id="二：数据库连接池"><a href="#二：数据库连接池" class="headerlink" title="二：数据库连接池"></a>二：数据库连接池</h2><h3 id="2-1-JDBC数据库连接池的必要性"><a href="#2-1-JDBC数据库连接池的必要性" class="headerlink" title="2.1 JDBC数据库连接池的必要性"></a>2.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。何为Java的内存泄漏？</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="2-2-数据库连接池技术"><a href="#2-2-数据库连接池技术" class="headerlink" title="2.2 数据库连接池技术"></a>2.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p>![1555593464033](./JDBC 事务，连接池及DBUtils/1555593464033.png)</p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p>![1555593598606](./JDBC 事务，连接池及DBUtils/1555593598606.png)</p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="2-3-多种开源的数据库连接池"><a href="#2-3-多种开源的数据库连接池" class="headerlink" title="2.3 多种开源的数据库连接池"></a>2.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 <code>javax.sql.DataSource</code> 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-C3P0数据库连接池"><a href="#2-3-1-C3P0数据库连接池" class="headerlink" title="2.3.1 C3P0数据库连接池"></a>2.3.1 C3P0数据库连接池</h4><ul>
<li>获取连接方式一</li>
</ul>
<pre><code class="java">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐
public static Connection getConnection1() throws Exception&#123;
    ComboPooledDataSource cpds = new ComboPooledDataSource();
    cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); 
    cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
    cpds.setUser(&quot;root&quot;);
    cpds.setPassword(&quot;abc123&quot;);
        
//    cpds.setMaxPoolSize(100);
    
    Connection conn = cpds.getConnection();
    return conn;
&#125;
</code></pre>
<ul>
<li>获取连接方式二</li>
</ul>
<pre><code class="java">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐
private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);
public static Connection getConnection2() throws SQLException&#123;
    Connection conn = cpds.getConnection();
    return conn;
&#125;
</code></pre>
<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
    &lt;named-config name=&quot;helloc3p0&quot;&gt;
        &lt;!-- 获取连接的4个基本信息 --&gt;
        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt;
        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        
        &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;
        &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;
        &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt;
        &lt;!-- 初始化数据库连接池时连接的数量 --&gt;
        &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt;
        &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;
        &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt;
        &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;
        &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt;
        &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;
        &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt;
        &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;
        &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;

    &lt;/named-config&gt;
&lt;/c3p0-config&gt;
</code></pre>
<h4 id="2-3-2-DBCP数据库连接池"><a href="#2-3-2-DBCP数据库连接池" class="headerlink" title="2.3.2 DBCP数据库连接池"></a>2.3.2 DBCP数据库连接池</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<pre><code class="java">public static Connection getConnection3() throws Exception &#123;
    BasicDataSource source = new BasicDataSource();
        
    source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    source.setUrl(&quot;jdbc:mysql:///test&quot;);
    source.setUsername(&quot;root&quot;);
    source.setPassword(&quot;abc123&quot;);
        
    //
    source.setInitialSize(10);
        
    Connection conn = source.getConnection();
    return conn;
&#125;
</code></pre>
<ul>
<li>获取连接方式二：</li>
</ul>
<pre><code class="java">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐
private static DataSource source = null;
static&#123;
    try &#123;
        Properties pros = new Properties();
        
        InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);
            
        pros.load(is);
        //根据提供的BasicDataSourceFactory创建对应的DataSource对象
        source = BasicDataSourceFactory.createDataSource(pros);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
        
&#125;
public static Connection getConnection4() throws Exception &#123;
        
    Connection conn = source.getConnection();
    
    return conn;
&#125;
</code></pre>
<p>其中，src下的配置文件为：【dbcp.properties】</p>
<pre><code class="properties">driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false
username=root
password=abc123

initialSize=10
#...
</code></pre>
<h4 id="2-3-3-Druid（德鲁伊）数据库连接池"><a href="#2-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="2.3.3 Druid（德鲁伊）数据库连接池"></a>2.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<pre><code class="java">package com.atguigu.druid;

import java.sql.Connection;
import java.util.Properties;

import javax.sql.DataSource;

import com.alibaba.druid.pool.DruidDataSourceFactory;

public class TestDruid &#123;
    public static void main(String[] args) throws Exception &#123;
        Properties pro = new Properties();         pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        Connection conn = ds.getConnection();
        System.out.println(conn);
    &#125;
&#125;
</code></pre>
<p>其中，src下的配置文件为：【druid.properties】</p>
<p><code>rewriteBatchedStatements=true</code>：开启批处理</p>
<pre><code class="java">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true
username=root
password=123456
driverClassName=com.mysql.jdbc.Driver

initialSize=10
maxActive=20
maxWait=1000
filters=wall
</code></pre>
<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="三：Apache-DBUtils实现CRUD操作"><a href="#三：Apache-DBUtils实现CRUD操作" class="headerlink" title="三：Apache-DBUtils实现CRUD操作"></a>三：Apache-DBUtils实现CRUD操作</h2><h3 id="3-1-Apache-DBUtils简介"><a href="#3-1-Apache-DBUtils简介" class="headerlink" title="3.1 Apache-DBUtils简介"></a>3.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<p>![1555595163263](./JDBC 事务，连接池及DBUtils/1555595163263.png)</p>
<p>![1555595198644](./JDBC 事务，连接池及DBUtils/1555595198644.png)</p>
<h3 id="3-2-主要API的使用"><a href="#3-2-主要API的使用" class="headerlink" title="3.2 主要API的使用"></a>3.2 主要API的使用</h3><h4 id="3-2-1-DbUtils"><a href="#3-2-1-DbUtils" class="headerlink" title="3.2.1 DbUtils"></a>3.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="3-2-2-QueryRunner类"><a href="#3-2-2-QueryRunner类" class="headerlink" title="3.2.2 QueryRunner类"></a>3.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li> ……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</T></T></li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</T></T></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<pre><code class="java">// 测试添加
@Test
public void testInsert() throws Exception &#123;
    QueryRunner runner = new QueryRunner();
    Connection conn = JDBCUtils.getConnection3();
    String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;
    int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);

    System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);
        
    JDBCUtils.closeResource(conn, null);

&#125;
</code></pre>
<pre><code class="java">// 测试删除
@Test
public void testDelete() throws Exception &#123;
    QueryRunner runner = new QueryRunner();
    Connection conn = JDBCUtils.getConnection3();
    String sql = &quot;delete from customers where id &lt; ?&quot;;
    int count = runner.update(conn, sql,3);

    System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);
        
    JDBCUtils.closeResource(conn, null);

&#125;
</code></pre>
<h4 id="3-2-3-ResultSetHandler接口及实现类"><a href="#3-2-3-ResultSetHandler接口及实现类" class="headerlink" title="3.2.3 ResultSetHandler接口及实现类"></a>3.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<pre><code class="java">/*
 * 测试查询:查询一条记录
 * 
 * 使用ResultSetHandler的实现类：BeanHandler
 */
@Test
public void testQueryInstance() throws Exception&#123;
    QueryRunner runner = new QueryRunner();

    Connection conn = JDBCUtils.getConnection3();
        
    String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;
        
    //
    BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);
    Customer customer = runner.query(conn, sql, handler, 23);
    System.out.println(customer);    
    JDBCUtils.closeResource(conn, null);
&#125;
</code></pre>
<pre><code class="java">/*
 * 测试查询:查询多条记录构成的集合
 * 
 * 使用ResultSetHandler的实现类：BeanListHandler
 */
@Test
public void testQueryList() throws Exception&#123;
    QueryRunner runner = new QueryRunner();

    Connection conn = JDBCUtils.getConnection3();
        
    String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;;
        
    //
    BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);
    List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);
    list.forEach(System.out::println);
        
    JDBCUtils.closeResource(conn, null);
&#125;
</code></pre>
<pre><code class="java">/*
 * 自定义ResultSetHandler的实现类
 */
@Test
public void testQueryInstance1() throws Exception&#123;
    QueryRunner runner = new QueryRunner();

    Connection conn = JDBCUtils.getConnection3();
        
    String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;
        
    ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;

        @Override
        public Customer handle(ResultSet rs) throws SQLException &#123;
            System.out.println(&quot;handle&quot;);
//            return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));
                
            if(rs.next())&#123;
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String email = rs.getString(&quot;email&quot;);
                Date birth = rs.getDate(&quot;birth&quot;);
                    
                return new Customer(id, name, email, birth);
            &#125;
            return null;
                
        &#125;
    &#125;;
        
    Customer customer = runner.query(conn, sql, handler, 23);
        
    System.out.println(customer);
        
    JDBCUtils.closeResource(conn, null);
&#125;
</code></pre>
<pre><code class="java">/*
 * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，
 * 使用ScalarHandler
 * 
 */
@Test
public void testQueryValue() throws Exception&#123;
    QueryRunner runner = new QueryRunner();

    Connection conn = JDBCUtils.getConnection3();
        
    //测试一：
//    String sql = &quot;select count(*) from customers where id &lt; ?&quot;;
//    ScalarHandler handler = new ScalarHandler();
//    long count = (long) runner.query(conn, sql, handler, 20);
//    System.out.println(count);
        
    //测试二：
    String sql = &quot;select max(birth) from customers&quot;;
    ScalarHandler handler = new ScalarHandler();
    Date birth = (Date) runner.query(conn, sql, handler);
    System.out.println(birth);
        
    JDBCUtils.closeResource(conn, null);
&#125;
</code></pre>
<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><pre><code class="java">总结
@Test
public void testUpdateWithTx() &#123;
        
    Connection conn = null;
    try &#123;
        //1.获取连接的操作（
        //① 手写的连接：JDBCUtils.getConnection();
        //② 使用数据库连接池：C3P0;DBCP;Druid
        //2.对数据表进行一系列CRUD操作
        //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)
//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;
//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;
        //② 使用dbutils提供的jar包中提供的QueryRunner类
            
        //提交数据
        conn.commit();
            
    
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
            
            
        try &#123;
            //回滚数据
            conn.rollback();
        &#125; catch (SQLException e1) &#123;
            e1.printStackTrace();
        &#125;
            
    &#125;finally&#123;
        //3.关闭连接等操作
        //① JDBCUtils.closeResource();
        //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作
            
    &#125;
&#125;
</code></pre>
<h2 id="四：JDBC使用：DAO及相关实现类"><a href="#四：JDBC使用：DAO及相关实现类" class="headerlink" title="四：JDBC使用：DAO及相关实现类"></a>四：JDBC使用：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是JavaWeb项目中DAO使用的体现：</li>
</ul>
<p>![1566726681515](./JDBC 事务，连接池及DBUtils/JDBC1.jpg)</p>
<ul>
<li>层次结构：</li>
</ul>
<p>![1566745811244](./JDBC 事务，连接池及DBUtils/1566745811244.png)</p>
<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><pre><code class="java">package com.atguigu.bookstore.dao;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;


/**
 * 定义一个用来被继承的对数据库进行基本操作的Dao
 * 
 * @author HanYanBing
 *
 * @param &lt;T&gt;
 */
public abstract class BaseDao&lt;T&gt; &#123;
    private QueryRunner queryRunner = new QueryRunner();
    
    // 定义一个变量来接收泛型的类型
    private Class&lt;T&gt; type;

    // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定
    public BaseDao() &#123;
        // 获取子类的类型
        Class clazz = this.getClass();
        // 获取父类的类型
        // getGenericSuperclass()用来获取当前类的父类的类型
        // ParameterizedType表示的是带泛型的类型
        ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();
        // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型
        // 这个方法会返回一个Type的数组
        Type[] types = parameterizedType.getActualTypeArguments();
        // 获取具体的泛型的类型·
        this.type = (Class&lt;T&gt;) types[0];
    &#125;

    /**
     * 通用的增删改操作
     * 
     * @param sql
     * @param params
     * @return
     */
    public int update(Connection conn,String sql, Object... params) &#123;
        int count = 0;
        try &#123;
            count = queryRunner.update(conn, sql, params);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; 
        return count;
    &#125;

    /**
     * 查，获取一个对象
     * 
     * @param sql
     * @param params
     * @return
     */
    public T getBean(Connection conn,String sql, Object... params) &#123;
        T t = null;
        try &#123;
            t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; 
        return t;
    &#125;

    /**
     * 获取所有对象
     * 
     * @param sql
     * @param params
     * @return
     */
    public &lt;T&gt; List&lt;T&gt; queryForOne(Class&lt;T&gt; clazz,String sql, Object...args)&#123;
        List&lt;T&gt; list=null;
        Connection connection=DruidUtils.getConnection();
        BeanListHandler&lt;T&gt; listHandler = new BeanListHandler&lt;&gt;(clazz);
        try &#123;
            return queryRunner.query(connection, sql, listHandler, args);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            DruidUtils.close(connection);
        &#125;
        return null;
    &#125;

    /**
     * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句
     * 
     * @param sql
     * @param params
     * @return
     */
    public Object getValue(Connection conn,String sql, Object... params) &#123;
        Object count = null;
        try &#123;
            // 调用queryRunner的query方法获取一个单一的值
            count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; 
        return count;
    &#125;
&#125;
</code></pre>
<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><pre><code class="java">package com.atguigu.bookstore.dao;

import java.sql.Connection;
import java.util.List;

import com.atguigu.bookstore.beans.Book;
import com.atguigu.bookstore.beans.Page;

public interface BookDao &#123;

    /**
     * 从数据库中查询出所有的记录
     * 
     * @return
     */
    List&lt;Book&gt; getBooks(Connection conn);

    /**
     * 向数据库中插入一条记录
     * 
     * @param book
     */
    void saveBook(Connection conn,Book book);

    /**
     * 从数据库中根据图书的id删除一条记录
     * 
     * @param bookId
     */
    void deleteBookById(Connection conn,String bookId);

    /**
     * 根据图书的id从数据库中查询出一条记录
     * 
     * @param bookId
     * @return
     */
    Book getBookById(Connection conn,String bookId);

    /**
     * 根据图书的id从数据库中更新一条记录
     * 
     * @param book
     */
    void updateBook(Connection conn,Book book);

    /**
     * 获取带分页的图书信息
     * 
     * @param page：是只包含了用户输入的pageNo属性的page对象
     * @return 返回的Page对象是包含了所有属性的Page对象
     */
    Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page);

    /**
     * 获取带分页和价格范围的图书信息
     * 
     * @param page：是只包含了用户输入的pageNo属性的page对象
     * @return 返回的Page对象是包含了所有属性的Page对象
     */
    Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);

&#125;
</code></pre>
<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><pre><code class="java">package com.atguigu.bookstore.dao;

import java.sql.Connection;

import com.atguigu.bookstore.beans.User;

public interface UserDao &#123;

    /**
     * 根据User对象中的用户名和密码从数据库中获取一条记录
     * 
     * @param user
     * @return User 数据库中有记录 null 数据库中无此记录
     */
    User getUser(Connection conn,User user);

    /**
     * 根据User对象中的用户名从数据库中获取一条记录
     * 
     * @param user
     * @return true 数据库中有记录 false 数据库中无此记录
     */
    boolean checkUsername(Connection conn,User user);

    /**
     * 向数据库中插入User对象
     * 
     * @param user
     */
    void saveUser(Connection conn,User user);
&#125;
</code></pre>
<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><pre><code class="java">package com.atguigu.bookstore.dao.impl;

import java.sql.Connection;
import java.util.List;

import com.atguigu.bookstore.beans.Book;
import com.atguigu.bookstore.beans.Page;
import com.atguigu.bookstore.dao.BaseDao;
import com.atguigu.bookstore.dao.BookDao;

public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123;

    @Override
    public List&lt;Book&gt; getBooks(Connection conn) &#123;
        // 调用BaseDao中得到一个List的方法
        List&lt;Book&gt; beanList = null;
        // 写sql语句
        String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;;
        beanList = getBeanList(conn,sql);
        return beanList;
    &#125;

    @Override
    public void saveBook(Connection conn,Book book) &#123;
        // 写sql语句
        String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;
        // 调用BaseDao中通用的增删改的方法
        update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());
    &#125;

    @Override
    public void deleteBookById(Connection conn,String bookId) &#123;
        // 写sql语句
        String sql = &quot;DELETE FROM books WHERE id = ?&quot;;
        // 调用BaseDao中通用增删改的方法
        update(conn,sql, bookId);
            
    &#125;

    @Override
    public Book getBookById(Connection conn,String bookId) &#123;
        // 调用BaseDao中获取一个对象的方法
        Book book = null;
        // 写sql语句
        String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;
        book = getBean(conn,sql, bookId);
        return book;
    &#125;

    @Override
    public void updateBook(Connection conn,Book book) &#123;
        // 写sql语句
        String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;;
        // 调用BaseDao中通用的增删改的方法
        update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());
    &#125;

    @Override
    public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123;
        // 获取数据库中图书的总记录数
        String sql = &quot;select count(*) from books&quot;;
        // 调用BaseDao中获取一个单一值的方法
        long totalRecord = (long) getValue(conn,sql);
        // 将总记录数设置都page对象中
        page.setTotalRecord((int) totalRecord);

        // 获取当前页中的记录存放的List
        String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;;
        // 调用BaseDao中获取一个集合的方法
        List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);
        // 将这个List设置到page对象中
        page.setList(beanList);
        return page;
    &#125;

    @Override
    public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123;
        // 获取数据库中图书的总记录数
        String sql = &quot;select count(*) from books where price between ? and ?&quot;;
        // 调用BaseDao中获取一个单一值的方法
        long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);
        // 将总记录数设置都page对象中
        page.setTotalRecord((int) totalRecord);

        // 获取当前页中的记录存放的List
        String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;;
        // 调用BaseDao中获取一个集合的方法
        List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);
        // 将这个List设置到page对象中
        page.setList(beanList);
        
        return page;
    &#125;

&#125;
</code></pre>
<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><pre><code class="java">package com.atguigu.bookstore.dao.impl;

import java.sql.Connection;

import com.atguigu.bookstore.beans.User;
import com.atguigu.bookstore.dao.BaseDao;
import com.atguigu.bookstore.dao.UserDao;

public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123;

    @Override
    public User getUser(Connection conn,User user) &#123;
        // 调用BaseDao中获取一个对象的方法
        User bean = null;
        // 写sql语句
        String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;;
        bean = getBean(conn,sql, user.getUsername(), user.getPassword());
        return bean;
    &#125;

    @Override
    public boolean checkUsername(Connection conn,User user) &#123;
        // 调用BaseDao中获取一个对象的方法
        User bean = null;
        // 写sql语句
        String sql = &quot;select id,username,password,email from users where username = ?&quot;;
        bean = getBean(conn,sql, user.getUsername());
        return bean != null;
    &#125;

    @Override
    public void saveUser(Connection conn,User user) &#123;
        //写sql语句
        String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;
        //调用BaseDao中通用的增删改的方法
        update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());
    &#125;

&#125;
</code></pre>
<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><pre><code class="java">package com.atguigu.bookstore.beans;
/**
 * 图书类
 * @author songhongkang
 *
 */
public class Book &#123;

    private Integer id;
    private String title; // 书名
    private String author; // 作者
    private double price; // 价格
    private Integer sales; // 销量
    private Integer stock; // 库存
    private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径
    //构造器，get()，set()，toString()方法略
&#125;
</code></pre>
<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><pre><code class="java">package com.atguigu.bookstore.beans;

import java.util.List;
/**
 * 页码类
 * @author songhongkang
 *
 */
public class Page&lt;T&gt; &#123;

    private List&lt;T&gt; list; // 每页查到的记录存放的集合
    public static final int PAGE_SIZE = 4; // 每页显示的记录数
    private int pageNo; // 当前页
//    private int totalPageNo; // 总页数，通过计算得到
    private int totalRecord; // 总记录数，通过查询数据库得到
</code></pre>
<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><pre><code class="java">package com.atguigu.bookstore.beans;
/**
 * 用户类
 * @author songhongkang
 *
 */
public class User &#123;

    private Integer id;
    private String username;
    private String password;
    private String email;
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基本使用</title>
    <url>/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="JDBC基本使用"><a href="#JDBC基本使用" class="headerlink" title="JDBC基本使用"></a>JDBC基本使用</h1><hr>
<h2 id="一：JDBC概述"><a href="#一：JDBC概述" class="headerlink" title="一：JDBC概述"></a>一：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566741430592.png" alt="1566741430592"> </p>
</li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555575760234.png" alt="1555575760234"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555575981203.png" alt="1555575981203"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566741692804.png" alt="1566741692804"></p>
<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1565969323908.png" alt="1565969323908"></p>
<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="二：获取数据库连接"><a href="#二：获取数据库连接" class="headerlink" title="二：获取数据库连接"></a>二：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555576157618.png" alt="1555576157618"></p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555576170074.png" alt="1555576170074"></p>
<ul>
<li><p>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566134718955.png" alt="1566134718955"></p>
</li>
</ul>
<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p>
<p> <img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566134781682.png" alt="1566134781682"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p> <img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566135290460.png" alt="1566135290460"></p>
<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver类的对象)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566136831283.png" alt="1566136831283"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li><p>举例：</p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555576477107.png" alt="1555576477107"></p>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/test</li>
<li>jdbc:mysql://localhost:3306/test**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/test?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:test</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=test</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><pre><code class="java">    @Test
    public void testConnection1() &#123;
        try &#123;
            //1.导入jar包
            //2.注册驱动(MySql 5.0 之后可以省略)
            //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            
            //1.提供java.sql.Driver接口实现类的对象
            Driver driver = null;
            driver = new com.mysql.jdbc.Driver();

            //2.提供url，指明具体操作的数据
            String url = &quot;jdbc:mysql://localhost:3306/test&quot;;

            //3.提供Properties的对象，指明用户名和密码
            Properties info = new Properties();
            info.setProperty(&quot;user&quot;, &quot;root&quot;);
            info.setProperty(&quot;password&quot;, &quot;abc123&quot;);

            //4.调用driver的connect()，获取连接
            Connection conn = driver.connect(url, info);
            System.out.println(conn);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API：com.mysql.jdbc.Driver()</p>
</blockquote>
<h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><pre><code class="java">    @Test
    public void testConnection2() &#123;
        try &#123;
            //1.实例化Driver
            String className = &quot;com.mysql.jdbc.Driver&quot;;
            Class clazz = Class.forName(className);
            Driver driver = (Driver) clazz.newInstance();

            //2.提供url，指明具体操作的数据
            String url = &quot;jdbc:mysql://localhost:3306/test&quot;;

            //3.提供Properties的对象，指明用户名和密码
            Properties info = new Properties();
            info.setProperty(&quot;user&quot;, &quot;root&quot;);
            info.setProperty(&quot;password&quot;, &quot;abc123&quot;);

            //4.调用driver的connect()，获取连接
            Connection conn = driver.connect(url, info);
            System.out.println(conn);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><pre><code class="java">    @Test
    public void testConnection3() &#123;
        try &#123;
            //1.数据库连接的4个基本要素：
            String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
            String user = &quot;root&quot;;
            String password = &quot;abc123&quot;;
            String driverName = &quot;com.mysql.jdbc.Driver&quot;;

            //2.实例化Driver
            Class clazz = Class.forName(driverName);
            Driver driver = (Driver) clazz.newInstance();
            //3.注册驱动
            DriverManager.registerDriver(driver);
            //4.获取连接
            Connection conn = DriverManager.getConnection(url, user, password);
            System.out.println(conn);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
</code></pre>
<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><pre><code class="java">    @Test
    public void testConnection4() &#123;
        try &#123;
            //1.数据库连接的4个基本要素：
            String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
            String user = &quot;root&quot;;
            String password = &quot;abc123&quot;;
            String driverName = &quot;com.mysql.jdbc.Driver&quot;;

            //2.加载驱动 （①实例化Driver ②注册驱动）
            Class.forName(driverName);

            //Class clazz = Class.forName(driverName);
            //Driver driver = (Driver) clazz.newInstance();
            //3.注册驱动
            //DriverManager.registerDriver(driver);
            /*
            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：
            static &#123;
                try &#123;
                    DriverManager.registerDriver(new Driver());
                &#125; catch (SQLException var1) &#123;
                    throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);
                &#125;
            &#125;

             */


            //3.获取连接
            Connection conn = DriverManager.getConnection(url, user, password);
            System.out.println(conn);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
</code></pre>
<blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><pre><code class="java">    @Test
    public  void testConnection5() throws Exception &#123;
        //1.加载配置文件
        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
        Properties pros = new Properties();
        pros.load(is);
        
        //2.读取配置信息
        String user = pros.getProperty(&quot;user&quot;);
        String password = pros.getProperty(&quot;password&quot;);
        String url = pros.getProperty(&quot;url&quot;);
        String driverClass = pros.getProperty(&quot;driverClass&quot;);

        //3.加载驱动
        Class.forName(driverClass);

        //4.获取连接
        Connection conn = DriverManager.getConnection(url,user,password);
        System.out.println(conn);

    &#125;
</code></pre>
<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<pre><code class="properties">user=root
password=abc123
url=jdbc:mysql://localhost:3306/test
driverClass=com.mysql.jdbc.Driver
</code></pre>
<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h2 id="三：使用PreparedStatement实现CRUD操作"><a href="#三：使用PreparedStatement实现CRUD操作" class="headerlink" title="三：使用PreparedStatement实现CRUD操作"></a>三：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个<strong>接口</strong>分别定义了对数据库的调用的不同方式：</p>
<ul>
<li><code>Statemen</code>t：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li><code>PrepatedStatement</code>：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li><code>CallableStatement</code>：用于执行 SQL 存储过程</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566573842140.png" alt="1566573842140"></p>
</li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端：SQL注入"><a href="#3-2-使用Statement操作数据表的弊端：SQL注入" class="headerlink" title="3.2 使用Statement操作数据表的弊端：SQL注入"></a>3.2 使用Statement操作数据表的弊端：SQL注入</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<pre><code class="sql">int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE
ResultSet executeQuery(String sql)：执行查询操作SELECT
</code></pre>
</li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<pre><code class="java">public class StatementTest &#123;

    // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题
    @Test
    public void testLogin() &#123;
        Scanner scan = new Scanner(System.in);

        System.out.print(&quot;用户名：&quot;);
        String userName = scan.nextLine();
        System.out.print(&quot;密   码：&quot;);
        String password = scan.nextLine();
        
        //SELECT * FROM customers WHERE id=1 AND NAME = &#39;汪峰&#39;
        // SELECT user,password FROM user_table WHERE USER = &#39;1&#39; or &#39; AND PASSWORD = &#39;=&#39;1&#39; or &#39;1&#39; = &#39;1&#39;;
        String sql = &quot;SELECT user,password FROM user_table WHERE user = &#39;&quot; + userName + &quot;&#39; AND password = &#39;&quot; + password + &quot;&#39;&quot;;//需要拼串，繁琐
        User user = get(sql, User.class);
        if (user != null) &#123;
            System.out.println(&quot;登陆成功!&quot;);
        &#125; else &#123;
            System.out.println(&quot;用户名或密码错误！&quot;);
        &#125;
    &#125;

    // 使用Statement实现对数据表的查询操作
    public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123;
        T t = null;

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try &#123;
            // 1.加载配置文件
            InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
            Properties pros = new Properties();
            pros.load(is);

            // 2.读取配置信息
            String user = pros.getProperty(&quot;user&quot;);
            String password = pros.getProperty(&quot;password&quot;);
            String url = pros.getProperty(&quot;url&quot;);
            String driverClass = pros.getProperty(&quot;driverClass&quot;);

            // 3.加载驱动
            Class.forName(driverClass);

            // 4.获取连接
            conn = DriverManager.getConnection(url, user, password);

            st = conn.createStatement();

            rs = st.executeQuery(sql);

            // 获取结果集的元数据
            ResultSetMetaData rsmd = rs.getMetaData();

            // 获取结果集的列数
            int columnCount = rsmd.getColumnCount();

            if (rs.next()) &#123;
                t = clazz.newInstance();
                for (int i = 0; i &lt; columnCount; i++) &#123;
                    // //1. 获取列的名称
                    // String columnName = rsmd.getColumnName(i+1);

                    // 1. 获取列的别名
                    String columnName = rsmd.getColumnLabel(i + 1);

                    // 2. 根据列名获取对应数据表中的数据
                    Object columnVal = rs.getObject(columnName);

                    // 3. 将数据表中得到的数据，封装进对象
                    Field field = clazz.getDeclaredField(columnName);
                    field.setAccessible(true);
                    field.set(t, columnVal);
                &#125;
                return t;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 关闭资源
            if (rs != null) &#123;
                try &#123;
                    rs.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (st != null) &#123;
                try &#123;
                    st.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p>综上：</p>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1566569819744.png" alt="1566569819744"></p>
<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 </p>
</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-创建数据库工具类JDBCUtils"><a href="#3-3-4-创建数据库工具类JDBCUtils" class="headerlink" title="3.3.4 创建数据库工具类JDBCUtils"></a>3.3.4 创建数据库工具类JDBCUtils</h4><ul>
<li>方式一</li>
</ul>
<pre><code class="java">public class JDBCUtils &#123;
    /*
     获取数据库的连接
     */
    public static Connection getConnection() throws Exception &#123;
        // 1.读取配置文件中的4个基本信息
        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
        //两种方式均可
        //InputStream is = JDBCUtils.class.ClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
        Properties pros = new Properties();
        pros.load(is);

        String user = pros.getProperty(&quot;user&quot;);
        String password = pros.getProperty(&quot;password&quot;);
        String url = pros.getProperty(&quot;url&quot;);
        String driverClass = pros.getProperty(&quot;driverClass&quot;);

        // 2.加载驱动
        Class.forName(driverClass);

        // 3.获取连接
        Connection conn = DriverManager.getConnection(url, user, password);
        return conn;
    &#125;
    /*
     * 关闭连接和Statement的操作，方法的重载
     */
    public static void closeResource(Connection conn,Statement ps)&#123;
        try &#123;
            if(ps != null)
                ps.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if(conn != null)
                conn.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    /*
     *关闭资源操作，方法的重载
     */
    public static void closeResource(Connection conn,Statement ps,ResultSet rs)&#123;
        try &#123;
            if(ps != null)
                ps.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if(conn != null)
                conn.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if(rs != null)
                rs.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>方式二：</p>
<pre><code class="java">public class JDBCUtils &#123;
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /*
    文件的读取，只需要读取一次即可拿到这些值，静态代码快
     */
    static &#123;
        //读取资源文件，获取值
        try &#123;
            //1.创建properties对象
            Properties pro=new Properties();

            //获取src路径下文件的方式：classloader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res = classLoader.getResource(&quot;jdbc.properties&quot;);
            String path = res.getPath();
            //2.加载文件
//            pro.load(new FileReader(&quot;src/jdbc.properties&quot;));
            pro.load(new FileReader(path));
            //3.获取数据，赋值
            url=pro.getProperty(&quot;url&quot;);
            user = pro.getProperty(&quot;user&quot;);
            password = pro.getProperty(&quot;password&quot;);
            driver = pro.getProperty(&quot;driver&quot;);
            //4.注册驱动
            Class.forName(driver);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
    /*
    获取连接，返回连接对象
     */
    public static Connection getConnection() throws SQLException &#123;
        return DriverManager.getConnection(url,user,password);
    &#125;

    /*
    释放资源,close()
     */
    public static void close(ResultSet rs, Connection conn, Statement stmt)&#123;
        if (rs != null)&#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (conn!=null)&#123;
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    public static void close(Connection conn, Statement stmt)&#123;
        if (stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (conn!=null)&#123;
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="3-3-5-使用PreparedStatement实现增、删、改操作"><a href="#3-3-5-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.5 使用PreparedStatement实现增、删、改操作"></a>3.3.5 使用PreparedStatement实现增、删、改操作</h4><ul>
<li>单独的增删改</li>
</ul>
<pre><code class="java">//增：insert 用execute()方法
    @Test
    public void test1()&#123;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try &#123;
            connection = JDBCUtils.getConnection();
            String sql= &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;
            preparedStatement = connection.prepareStatement(sql);
            //设置值
            preparedStatement.setString(1,&quot;哪吒&quot;);//表示第一个？设置String类型的名字
            preparedStatement.setString(2,&quot;nezha@163.com&quot;);
            //转换Date
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            java.util.Date parse = simpleDateFormat.parse(&quot;1000-01-01&quot;);
            preparedStatement.setDate(3,new Date(parse.getTime()));//毫秒值一样
            //执行，execute()方法返回一个boolean值，executeUpdate()有返回int值，返回更新了几条数据
            preparedStatement.execute();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //资源关闭
            JDBCUtils.closeResource(connection,preparedStatement);
        &#125;

    &#125;
//改 update，修改customers表的一条记录
    @Test
    public void testUpdate()&#123;
        Connection conn = null;
        PreparedStatement ps = null;
        try &#123;
            //1.获取数据库的连接
            conn = JDBCUtils.getConnection();
            //2.预编译sql语句，返回PreparedStatement的实例
            String sql = &quot;update customers set name = ? where id = ?&quot;;
            ps = conn.prepareStatement(sql);
            //3.填充占位符
            ps.setObject(1,&quot;莫扎特&quot;);
            ps.setObject(2, 18);
            //4.执行
            ps.execute();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally&#123;
            //5.资源的关闭
            JDBCUtils.closeResource(conn, ps);
            
        &#125;
    &#125;
</code></pre>
<ul>
<li>通用的增删改操作：就sql语句不一样，占位符？数量不一样，参数类型不一样，统一为object</li>
</ul>
<pre><code class="java">    //通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）
    public void update(String sql,Object ... args)&#123;//可变形参的个数与占位符一致
        Connection conn = null;
        PreparedStatement ps = null;
        try &#123;
            //1.获取数据库的连接
            conn = JDBCUtils.getConnection();
            
            //2.获取PreparedStatement的实例 (或：预编译sql语句)
            ps = conn.prepareStatement(sql);
            //3.填充占位符
            for(int i = 0;i &lt; args.length;i++)&#123;
                ps.setObject(i + 1, args[i]);
            &#125;
            
            //4.执行sql语句
            ps.execute();
        &#125; catch (Exception e) &#123;
            
            e.printStackTrace();
        &#125;finally&#123;
            //5.关闭资源
            JDBCUtils.closeResource(conn, ps);
            
        &#125;
    &#125;
//使用
@Test
    public void testCommonUpdate()&#123;
        //增删改均可，不需要获取连接，直接在update中定义了，后面处理事务则需要把连接放在外面定义
//        String sql = &quot;delete from customers where id = ?&quot;;
//        update(sql,3);
        
        String sql = &quot;update `order` set order_name = ? where order_id = ?&quot;;//表order是关键字，需要用``包裹(1旁边的按键)
        update(sql,&quot;DD&quot;,&quot;2&quot;);
    &#125;
</code></pre>
<h4 id="3-3-6-使用PreparedStatement实现查询操作"><a href="#3-3-6-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.6 使用PreparedStatement实现查询操作"></a>3.3.6 使用PreparedStatement实现查询操作</h4><p>查找会返回一个结果集，executeQuery查询之后返回的是ResultSet接口的对象</p>
<pre><code class="java">@Test
    public void testQuery1() &#123;
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet resultSet = null;
        try &#123;
            conn = JDBCUtils.getConnection();
            String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;
            ps = conn.prepareStatement(sql);
            ps.setObject(1, 1);
            
            //执行,并返回结果集
            resultSet = ps.executeQuery();
            //处理结果集
            if(resultSet.next())&#123;
                //next():判断结果集的下一条是否有数据，如果有数据返回true,
                //并指针下移；如果返回false,指针不会下移。
                
                //获取当前这条数据的各个字段值
                int id = resultSet.getInt(1);
                String name = resultSet.getString(2);
                String email = resultSet.getString(3);
                Date birth = resultSet.getDate(4);
                
            //方式一：
//            System.out.println(&quot;id = &quot; + id + &quot;,name = &quot; + name + &quot;,email = &quot; + email + &quot;,birth = &quot; + birth);
                
            //方式二：
//            Object[] data = new Object[]&#123;id,name,email,birth&#125;;
                //方式三：将数据封装为一个对象（推荐）
                Customer customer = new Customer(id, name, email, birth);
                System.out.println(customer);
                
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally&#123;
            //关闭资源
            JDBCUtils.closeResource(conn, ps, resultSet);
            
        &#125;
        
    &#125;
/*
 * ORM编程思想  （object relational mapping）
 * 对象关系映射
 * 一个数据表对应一个java类
 * 表中的一条记录对应java类的一个对象
 * 表中的一个字段对应java类的一个属性
 * 
 */
public class Customer &#123;
    
    private int id;
    private String name;
    private String email;
    private Date birth;
    //构造方法 略
    //getter,setter方法 略
    // toString方法   略
&#125;
</code></pre>
<ul>
<li>通用操作</li>
</ul>
<pre><code class="java">    // 通用的针对于不同表的查询:返回一个对象 (version 1.0)
    public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try &#123;
            // 1.获取数据库连接
            conn = JDBCUtils.getConnection();
            // 2.预编译sql语句，得到PreparedStatement对象
            ps = conn.prepareStatement(sql);
            // 3.填充占位符
            for (int i = 0; i &lt; args.length; i++) &#123;
                ps.setObject(i + 1, args[i]);
            &#125;
            // 4.执行executeQuery(),得到结果集：ResultSet
            rs = ps.executeQuery();
            // 5.得到结果集的元数据：ResultSetMetaData
            ResultSetMetaData rsmd = rs.getMetaData();//通过ResultSetMetaData获取列值
            // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值
            int columnCount = rsmd.getColumnCount();//得到列数，每一列表示一种数据类型
            if (rs.next()) &#123;
                T t = clazz.newInstance();
                for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列
                    // 获取列值columnVal
                    Object columnVal = rs.getObject(i + 1);
                    //很难的一块，两种方式一种造对象在构造器中将列值填入，一种造好之后用set方法填入
                    //用第二种，第一种构造器不一定有
                    
                    // 获取列的别名:列的别名，使用类的属性名充当columnLabel
                    String columnLabel = rsmd.getColumnLabel(i + 1);
                    // 6.2使用反射，给对象的相应属性赋值getDeclaredField获取属性的方法，不考虑权限修饰符
                    Field field = clazz.getDeclaredField(columnLabel);
                    field.setAccessible(true);//设置可以获取私有属性
                    field.set(t, columnVal);
                &#125;
                return t;
            &#125;
        &#125; catch (Exception e) &#123;

            e.printStackTrace();
        &#125; finally &#123;
            // 7.关闭资源
            JDBCUtils.closeResource(conn, ps, rs);
        &#125;

        return null;

    &#125;
//使用
@Test
    public void testGetInstance()&#123;
        String sql = &quot;select id,name,email from customers where id = ?&quot;;
        Customer customer = getInstance(Customer.class,sql,12);
        System.out.println(customer);
        
        String sql1 = &quot;select order_id orderId,order_name orderName from `order` where order_id = ?&quot;;
        Order order = getInstance(Order.class, sql1, 1);
        System.out.println(order);
    &#125;
</code></pre>
<p>通用操作</p>
<pre><code class="java">//针对于不同的表的通用的查询操作，返回表中的多条记录，所以对象用List集合
public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz,String sql, Object... args)&#123;
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try &#123;
            conn = JDBCUtils.getConnection();

            ps = conn.prepareStatement(sql);
            for (int i = 0; i &lt; args.length; i++) &#123;
                ps.setObject(i + 1, args[i]);
            &#125;

            rs = ps.executeQuery();
            // 获取结果集的元数据 :ResultSetMetaData
            ResultSetMetaData rsmd = rs.getMetaData();
            // 通过ResultSetMetaData获取结果集中的列数
            int columnCount = rsmd.getColumnCount();
            //创建集合对象
            ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;();
            while (rs.next()) &#123;
                T t = clazz.newInstance();
                // 处理结果集一行数据中的每一个列:给t对象指定的属性赋值
                for (int i = 0; i &lt; columnCount; i++) &#123;
                    // 获取列值
                    Object columValue = rs.getObject(i + 1);

                    // 获取每个列的列名
                    // String columnName = rsmd.getColumnName(i + 1);
                    String columnLabel = rsmd.getColumnLabel(i + 1);

                    // 给t对象指定的columnName属性，赋值为columValue：通过反射
                    Field field = clazz.getDeclaredField(columnLabel);
                    field.setAccessible(true);
                    field.set(t, columValue);
                &#125;
                list.add(t);//添加对象到集合
            &#125;
            
            return list;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtils.closeResource(conn, ps, rs);

        &#125;

        return null;
    &#125;
//使用
@Test
    public void testGetForList()&#123;
        
        String sql = &quot;select id,name,email from customers where id &lt; ?&quot;;
        List&lt;Customer&gt; list = getForList(Customer.class,sql,12);
        list.forEach(System.out::println);//java8新特性
        
        String sql1 = &quot;select order_id orderId,order_name orderName from `order`&quot;;
        List&lt;Order&gt; orderList = getForList(Order.class, sql1);
        orderList.forEach(System.out::println);
    &#125;
</code></pre>
<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555580152530.png" alt="1555580152530"></p>
</li>
</ul>
<h4 id="3-4-2-ResultSetMetaData元数据"><a href="#3-4-2-ResultSetMetaData元数据" class="headerlink" title="3.4.2 ResultSetMetaData元数据"></a>3.4.2 ResultSetMetaData元数据</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p> isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555579494691.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555579816884.png" alt="1555579816884"></p>
<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="四：-操作BLOB类型字段"><a href="#四：-操作BLOB类型字段" class="headerlink" title="四： 操作BLOB类型字段"></a>四： 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型-图片操作等"><a href="#4-1-MySQL-BLOB类型-图片操作等" class="headerlink" title="4.1 MySQL BLOB类型(图片操作等)"></a>4.1 MySQL BLOB类型(图片操作等)</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="/2020/09/20/JDBC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1555581069798.png" alt="1555581069798"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><pre><code class="java">//获取连接
Connection conn = JDBCUtils.getConnection();
        
String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;
PreparedStatement ps = conn.prepareStatement(sql);

// 填充占位符
ps.setString(1, &quot;徐海强&quot;);
ps.setString(2, &quot;xhq@126.com&quot;);
ps.setDate(3, new Date(new java.util.Date().getTime()));
// 操作Blob类型的变量
FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);
ps.setBlob(4, fis);
//执行
ps.execute();
        
fis.close();
JDBCUtils.closeResource(conn, ps);
</code></pre>
<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><pre><code class="java">Connection conn = JDBCUtils.getConnection();
String sql = &quot;update customers set photo = ? where id = ?&quot;;
PreparedStatement ps = conn.prepareStatement(sql);

// 填充占位符
// 操作Blob类型的变量
FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);
ps.setBlob(1, fis);
ps.setInt(2, 25);

ps.execute();

fis.close();
JDBCUtils.closeResource(conn, ps);
</code></pre>
<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><pre><code class="java">String sql = &quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;;
conn = getConnection();
ps = conn.prepareStatement(sql);
ps.setInt(1, 8);
rs = ps.executeQuery();
if(rs.next())&#123;
    Integer id = rs.getInt(1);
    String name = rs.getString(2);
    String email = rs.getString(3);
    Date birth = rs.getDate(4);
    Customer cust = new Customer(id, name, email, birth);
    System.out.println(cust); 
    //读取Blob类型的字段
    Blob photo = rs.getBlob(5);
    InputStream is = photo.getBinaryStream();
    OutputStream os = new FileOutputStream(&quot;c.jpg&quot;);
    byte [] buffer = new byte[1024];
    int len = 0;
    while((len = is.read(buffer)) != -1)&#123;
        os.write(buffer, 0, len);
    &#125;
    JDBCUtils.closeResource(conn, ps, rs);
        
    if(is != null)&#123;
        is.close();
    &#125;
        
    if(os !=  null)&#123;
        os.close();
    &#125;
    
&#125;
</code></pre>
<h2 id="五：-批量插入Insert"><a href="#五：-批量插入Insert" class="headerlink" title="五： 批量插入Insert"></a>五： 批量插入Insert</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>使用PreparedStatement实现批量数据的操作，update、delete本身就具有批量操作的效果。</p>
<p>此时的批量操作，主要指的是批量插入。</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<pre><code class="sql">CREATE TABLE goods(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20)
);
</code></pre>
<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><pre><code class="java">Connection conn = JDBCUtils.getConnection();
Statement st = conn.createStatement();
for(int i = 1;i &lt;= 20000;i++)&#123;
    String sql = &quot;insert into goods(name) values(&#39;name_&#39; + &quot;+ i +&quot;)&quot;;
    st.executeUpdate(sql);
&#125;
</code></pre>
<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><pre><code class="java">long start = System.currentTimeMillis();
        
Connection conn = JDBCUtils.getConnection();
        
String sql = &quot;insert into goods(name)values(?)&quot;;
PreparedStatement ps = conn.prepareStatement(sql);
for(int i = 1;i &lt;= 20000;i++)&#123;
    ps.setString(1, &quot;name_&quot; + i);
    ps.executeUpdate();
&#125;
        
long end = System.currentTimeMillis();
System.out.println(&quot;花费的时间为：&quot; + (end - start));//82340
        
        
JDBCUtils.closeResource(conn, ps);
</code></pre>
<p>层次二相比于层次一，preparedStatement有预编译功能，层次一sql语句在循环中，循环两万次有两万个String对象在内存中，preparedStatement性能提升详见3.32</p>
<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><pre><code class="java">/*
 * 修改1： 使用 addBatch() / executeBatch() / clearBatch()
 * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。
 *          ?rewriteBatchedStatements=true 写在配置文件的url后面
 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar
 * 
 */
@Test
public void testInsert1() throws Exception&#123;
    long start = System.currentTimeMillis();
        
    Connection conn = JDBCUtils.getConnection();
        
    String sql = &quot;insert into goods(name)values(?)&quot;;
    PreparedStatement ps = conn.prepareStatement(sql);
        
    for(int i = 1;i &lt;= 1000000;i++)&#123;
        ps.setString(1, &quot;name_&quot; + i);
            
        //1.“攒”sql，攒够一定数量，再一起执行
        ps.addBatch();
        if(i % 500 == 0)&#123;
            //2.执行
            ps.executeBatch();
            //3.清空，清空之后再攒
            ps.clearBatch();
        &#125;
    &#125;
        
    long end = System.currentTimeMillis();
    System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625                                                                         //1000000条:14733  
        
    JDBCUtils.closeResource(conn, ps);
&#125;
</code></pre>
<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><pre><code class="java">/*
* 层次四：在层次三的基础上操作
* 使用Connection 的 setAutoCommit(false)  /  commit()
* 每次执行完不自动提交数据
*/
@Test
public void testInsert2() throws Exception&#123;
    long start = System.currentTimeMillis();
        
    Connection conn = JDBCUtils.getConnection();
        
    //1.设置为不自动提交数据
    conn.setAutoCommit(false);
        
    String sql = &quot;insert into goods(name)values(?)&quot;;
    PreparedStatement ps = conn.prepareStatement(sql);
        
    for(int i = 1;i &lt;= 1000000;i++)&#123;
        ps.setString(1, &quot;name_&quot; + i);
            
        //1.“攒”sql
        ps.addBatch();
            
        if(i % 500 == 0)&#123;
            //2.执行
            ps.executeBatch();
            //3.清空
            ps.clearBatch();
        &#125;
    &#125;
        
    //2.提交数据，最后提交数据
    conn.commit();
        
    long end = System.currentTimeMillis();
    System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 
        
    JDBCUtils.closeResource(conn, ps);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本使用</title>
    <url>/2020/09/13/JavaScript/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li><p>Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。</p>
</li>
<li><p>JS是Netscape网景公司的产品，最早取名为LiveScript;为了吸引更多java程序员。更名为JavaScript。</p>
</li>
<li><p>JS是弱类型，Java是强类型。</p>
<p>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p>
<p>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p>
</li>
<li><p>JS特点： </p>
<ol>
<li>交互性（它可以做的就是信息的动态交互）</li>
<li>安全性（不允许直接访问本地硬盘） </li>
<li>跨平台性（只要是可以解释JS的浏览器都可以执行，和平台无关）</li>
</ol>
</li>
<li><p>java和JavaScript关系：</p>
</li>
</ul>
<p><img src="/2020/09/13/JavaScript/java%E5%92%8Cjs%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="java和js的关系"></p>
<h3 id="1-2-JavaScript与Html结合方式"><a href="#1-2-JavaScript与Html结合方式" class="headerlink" title="1.2 JavaScript与Html结合方式"></a>1.2 JavaScript与Html结合方式</h3><ul>
<li>方式1：只需要在 head 标签中，或者在 body 标签中， 使用 script 标签 来书写 JavaScript 代码</li>
</ul>
<pre><code class="html">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // alert是JavaScript语言提供的一个警告框函数。
        // 它可以接收任意类型的参数，这个参数就是警告框的提示信息
        alert(&quot;hello javaScript!&quot;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>方式2 ：使用 script 标签引入 单独的 JavaScript 代码文件</li>
</ul>
<pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="1-3-JavaScript变量"><a href="#1-3-JavaScript变量" class="headerlink" title="1.3 JavaScript变量"></a>1.3 JavaScript变量</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>原始数据类型(基本数据类型)：</p>
<ul>
<li>number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)</li>
<li>string：字符串。 字符串 “abc” “a” ‘abc’</li>
<li>boolean: true和false</li>
<li>null：一个对象为空的占位符</li>
<li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li>
</ul>
<pre><code class="javascript">//NaN是number类型
var a=NaN;
alert(typeof (a));//number

//不带有值的变量，它的值将是 undefined。类型将是undefined类型
var i;
alert(typeof (i));//undefined

var a = 12;
var b = &quot;abc&quot;;
alert( a * b ); // NaN是非数字，非数值。
alert(typeof (b*a));//number
</code></pre>
<p>引用数据类型：object(对象)</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>语法：var 变量名 = 初始化值;</p>
<p>typeof运算符：获取变量的类型。</p>
<p><strong>注：null运算后得到的是<code>object</code></strong></p>
<p><strong>注：NaN != NaN</strong></p>
<pre><code class="javascript">var obj=null;
var obj2=undefined;
var obj3;
document.write(typeof (obj)+&quot;&lt;br&gt;&quot;);//object类型
document.write(obj+&quot;&lt;br&gt;&quot;);//null
document.write(obj2+&quot;&lt;br&gt;&quot;);//undefined
document.write(obj3+&quot;&lt;br&gt;&quot;);//undefined
</code></pre>
<blockquote>
<p> JS特殊语法：语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)</p>
<p>变量的定义使用var关键字，也可以不使用 </p>
<p>用： 定义的变量是局部变量</p>
<p>不用：定义的变量是全局变量(不建议)</p>
</blockquote>
<h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h3><p><strong>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</strong></p>
<ul>
<li><p>其他类型转number： </p>
<p>  string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</p>
<p>  boolean转number：true转为1，false转为0</p>
</li>
</ul>
<p>在JavaScript语言中，所有的变量，都可以做为一个boolean类型的变量去使用。0 、null、 undefined、””(空串) 都认为是 false；</p>
<ul>
<li><p>其他类型转boolean：<br>  number：0或NaN为false，其他为true<br>  string：除了空字符串(“”)，其他都是true<br>  null&amp;undefined:都是false<br>  对象：所有对象都为true</p>
</li>
<li><p><strong>比较运算符</strong></p>
<p>  比较运算符<code>&lt;</code>  <code>&gt;=</code>  <code>&lt;=</code>  <code>==</code>  <code>===</code>(全等于)</p>
<p>  比较方式 类型相同：直接比较 </p>
<p>  字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。</p>
<p>  类型不同：先进行类型转换，再比较 </p>
<p>  ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p>
</li>
<li><p>一元运算符，算数运算符，逻辑运算符，三元运算符，赋值运算符都和java语法差不多</p>
</li>
</ul>
<h3 id="1-5-流程控制语句"><a href="#1-5-流程控制语句" class="headerlink" title="1.5 流程控制语句"></a>1.5 流程控制语句</h3><ul>
<li><p>if…else…</p>
</li>
<li><p>switch: 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) </p>
<p>switch(变量):</p>
<p>case 值:</p>
</li>
<li><p>在JS中,switch语句可以接受任意的原始数据类型</p>
</li>
<li><p>while</p>
</li>
<li><p>do…while</p>
</li>
<li><p>for</p>
</li>
</ul>
<h3 id="1-6-基本对象"><a href="#1-6-基本对象" class="headerlink" title="1.6 基本对象"></a>1.6 基本对象</h3><h4 id="Function：函数-方法-对象"><a href="#Function：函数-方法-对象" class="headerlink" title="Function：函数(方法)对象"></a><code>Function</code>：函数(方法)对象</h4><ul>
<li><p>创建：<br>var fun = new Function(形式参数列表,方法体); (不建议使用)</p>
<p><strong>function 方法名称(形式参数列表){方法体}</strong></p>
<p><strong>var 方法名 = function(形式参数列表){方法体}</strong></p>
</li>
<li><p>特点：<br>方法定义时，形参的类型不用写,返回值类型也不写。<br><strong>方法是一个对象，如果定义名称相同的方法，会覆盖(无重载)</strong><br>在JS中，方法的调用只与方法的名称有关，和参数列表无关<br>在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数</p>
</li>
<li><p>调用：<br>方法名称(实际参数列表);</p>
</li>
<li><p>在 JavaScript 语言中，如何定义带有返回值的函数？ </p>
<p>只需要在函数体内直接使用 return 语句返回值即可！</p>
</li>
</ul>
<pre><code class="JavaScript">    function fun2(a ,b) &#123;
        alert(&quot;有参函数fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot;+b);
    &#125;
    
    fun2(12,&quot;abc&quot;);
    
    // 定义带有返回值的函数
    var fun3 = function (num1,num2) &#123;
        return num1 + num2;
    &#125;
    alert( fun3(100,200) );
</code></pre>
<ul>
<li>隐形参数：是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。 隐形参数特别像 java中的可变长参数一样。 public void fun(Object…args); 可变长参数其实是一个数组。那么 js 中的隐形参数也跟 java 的可变长参数一样。操作类似数组。</li>
</ul>
<pre><code class="JavaScript">    &lt;script type=&quot;text/javascript&quot;&gt;
            function fun(a) &#123;
                alert( arguments.length );//3 可看参数个数
                alert( arguments[0] );//1
                alert( arguments[1] );//ad
                alert( arguments[2] );//true
                alert(&quot;a = &quot; + a);
                for (var i = 0; i &lt; arguments.length; i++)&#123;
                    alert( arguments[i] );
                &#125;
                alert(&quot;无参函数fun()&quot;);
            &#125;
            fun(1,&quot;ad&quot;,true);
    
            // 需求：要求 编写 一个函数。用于计算所有参数相加的和并返回
            function sum(num1,num2) &#123;
                var result = 0;
                for (var i = 0; i &lt; arguments.length; i++) &#123;
                    if (typeof(arguments[i]) == &quot;number&quot;) &#123;
                        result += arguments[i];
                    &#125;
                &#125;
                return result;
            &#125;
            alert( sum(1,2,3,4,&quot;abc&quot;,5,6,7,8,9) );
        &lt;/script&gt;
</code></pre>
<h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a><code>Array</code>:数组对象</h4><ul>
<li><p>创建：</p>
<p>var arr = new Array(元素列表);</p>
<p>var arr = new Array(默认长度);</p>
<p>var arr = [元素列表];</p>
</li>
<li><p>方法</p>
<p>join(参数):将数组中的元素按照指定的分隔符拼接为字符串</p>
<p>push()    向数组的末尾添加一个或更多元素，并返回新的长度。</p>
</li>
<li><p>属性</p>
<p>  length:数组的长度</p>
</li>
<li><p>特点：</p>
<p>JS中，数组元素的类型可变的。</p>
<p>JS中，数组长度可变的。</p>
<h4 id="Date：日期对象"><a href="#Date：日期对象" class="headerlink" title="Date：日期对象"></a><code>Date</code>：日期对象</h4></li>
<li><p>创建：</p>
<p>  var date = new Date();</p>
</li>
<li><p>方法：</p>
<p>toLocaleString()：返回当前date对象对应的时间本地字符串格式</p>
<p>getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p>
<h4 id="Math：数学对象"><a href="#Math：数学对象" class="headerlink" title="Math：数学对象"></a><code>Math</code>：数学对象</h4></li>
<li><p>创建：Math对象不用创建，直接使用。  Math.方法名();</p>
</li>
<li><p>方法：</p>
<p>random():返回 0 ~ 1 之间的随机数。 含0不含1</p>
<p>ceil(x)：对数进行上舍入。</p>
<p>floor(x)：对数进行下舍入。</p>
<p>round(x)：把数四舍五入为最接近的整数。</p>
<h4 id="RegExp：正则表达式对象"><a href="#RegExp：正则表达式对象" class="headerlink" title="RegExp：正则表达式对象"></a><code>RegExp</code>：正则表达式对象</h4></li>
<li><p>创建<br>var reg = new RegExp(“正则表达式”);<br>var reg = /正则表达式/;<br>正则表达式：定义字符串的组成规则。<br>单个字符:[]<br>如： [a] [ab] [a-zA-Z0-9]<br>正则对象：</p>
</li>
<li><p>方法<br>test(参数):验证指定的字符串是否符合正则定义的规范    </p>
<pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;
    // 表示要求字符串中，是否包含字母e
    // var patt = new RegExp(&quot;e&quot;);
    // var patt = /e/; // 也是正则表达式对象
    // 表示要求字符串中，是否包含字母a或b或c
    // var patt = /[abc]/;
    // 表示要求字符串，是否包含小写字母
    // var patt = /[a-z]/;
    // 表示要求字符串，是否包含任意大写字母
    // var patt = /[A-Z]/;
    // 表示要求字符串，是否包含任意数字
    // var patt = /[0-9]/;
    // 表示要求字符串，是否包含字母，数字，下划线
    // var patt = /\w/;
    // 表示要求 字符串中是否包含至少一个a
    // var patt = /a+/;
    // 表示要求 字符串中是否 *包含* 零个 或 多个a
    // var patt = /a*/;
    // 表示要求 字符串是否包含一个或零个a
    // var patt = /a?/;
    // 表示要求 字符串是否包含连续三个a
    // var patt = /a&#123;3&#125;/;
    // 表示要求 字符串是否包 至少3个连续的a，最多5个连续的a
    // var patt = /a&#123;3,5&#125;/;
    // 表示要求 字符串是否包 至少3个连续的a，
    // var patt = /a&#123;3,&#125;/;
    // 表示要求 字符串必须以a结尾
    // var patt = /a$/;
    // 表示要求 字符串必须以a打头
    // var patt = /^a/;
    // 要求字符串中是否*包含* 至少3个连续的a
    // var patt = /a&#123;3,5&#125;/;
    // 要求字符串，从头到尾都必须完全匹配
    // var patt = /^a&#123;3,5&#125;$/;
    var patt = /^\w&#123;5,12&#125;$/;
    var str = &quot;wzg168[[[&quot;;
    alert( patt.test(str) );
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h4 id="Global"><a href="#Global" class="headerlink" title="Global"></a><code>Global</code></h4><ul>
<li>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</li>
<li>方法：<br>encodeURI():url编码<br>decodeURI():url解码<br>encodeURIComponent():url编码,编码的字符更多<br>decodeURIComponent():url解码<br>parseInt():将字符串转为数字 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number<br>isNaN():判断一个值是否是NaN<br>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false，包括和自己<br>eval():将JavaScript 字符串转成脚本，并把它作为脚本运行</li>
</ul>
<h3 id="1-7-事件"><a href="#1-7-事件" class="headerlink" title="1.7 事件"></a>1.7 事件</h3><ul>
<li><p>概念：某些组件被执行了某些操作后，触发某些代码的执行。    </p>
<ul>
<li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li>
<li>事件源：组件。如： 按钮 文本输入框…</li>
<li>监听器：代码。</li>
<li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li>
</ul>
</li>
<li><p>事件的注册又分为静态注册和动态注册两种：</p>
<ul>
<li><p>什么是事件的注册（绑定）？ 其实就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。</p>
</li>
<li><p>静态注册事件：通过 html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>动态注册事件：是指先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 =function(){} 这种形式赋于事件</p>
<pre><code>响应后的代码，叫动态注册。
</code></pre>
<ul>
<li>动态注册基本步骤： 1、获取标签对象 2、标签对象.事件名 =fucntion(){}</li>
</ul>
<pre><code class="JavaScript">  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;Title&lt;/title&gt;
      &lt;script type=&quot;text/javascript&quot;&gt;
          // onload事件的方法
          function onloadFun() &#123;
              alert(&#39;静态注册onload事件，所有代码&#39;);
          &#125;
  
          // onload事件动态注册。是固定写法
          window.onload = function () &#123;
              alert(&quot;动态注册的onload事件&quot;);
          &#125;
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;!--静态注册onload事件
          onload事件是浏览器解析完页面之后就会自动触发的事件
         &lt;body onload=&quot;onloadFun();&quot;&gt;
  --&gt;
  &lt;body onload=&quot;onloadFun();&quot;&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
</li>
</ul>
<ul>
<li>常见的事件：</li>
</ul>
<ol>
<li>点击事件：<ol>
<li>onclick：单击事件</li>
<li>ondblclick：双击事件<pre><code class="javascript"> &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Title&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         function onclickFun() &#123;
             alert(&quot;静态注册onclick事件&quot;);
         &#125;
 
         // 动态注册onclick事件
         ///加载完成事件,要先加载完再执行此代码
         window.onload = function () &#123;
             // 1 获取标签对象
             /*
             * document 是JavaScript语言提供的一个对象（文档）&lt;br/&gt;
             * get           获取
             * Element       元素（就是标签）
             * By            通过。。   由。。经。。。
             * Id            id属性
             * getElementById通过id属性获取标签对象
             **/
             var btnObj = document.getElementById(&quot;btn01&quot;);
             // alert( btnObj );
             // 2 通过标签对象.事件名 = function()&#123;&#125;
             btnObj.onclick = function () &#123;
                 alert(&quot;动态注册的onclick事件&quot;);
             &#125;
         &#125;
 
     &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!--静态注册onClick事件--&gt;
     &lt;button onclick=&quot;onclickFun();&quot;&gt;按钮1&lt;/button&gt;
     &lt;button id=&quot;btn01&quot;&gt;按钮2&lt;/button&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
<li>焦点事件<ol>
<li>onblur：失去焦点</li>
<li>onfocus:元素获得焦点。</li>
</ol>
</li>
</ol>
<pre><code class="JavaScript">    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 静态注册失去焦点事件
            function onblurFun() &#123;
                // console是控制台对象，是由JavaScript语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用
                // log() 是打印的方法
                console.log(&quot;静态注册失去焦点事件&quot;);
            &#125;
    
            // 动态注册 onblur事件
            window.onload = function () &#123;
                //1 获取标签对象
               var passwordObj = document.getElementById(&quot;password&quot;);
               // alert(passwordObj);
                //2 通过标签对象.事件名 = function()&#123;&#125;;
                passwordObj.onblur = function () &#123;
                    console.log(&quot;动态注册失去焦点事件&quot;);
                &#125;
            &#125;
    
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        用户名:&lt;input type=&quot;text&quot; onblur=&quot;onblurFun();&quot;&gt;&lt;br/&gt;
        密码:&lt;input id=&quot;password&quot; type=&quot;text&quot; &gt;&lt;br/&gt;
    &lt;/body&gt;
</code></pre>
<ol start="2">
<li><p>加载事件：</p>
<ol>
<li>onload：页面或一幅图像完成加载。</li>
</ol>
</li>
<li><p>鼠标事件：</p>
<ol>
<li>onmousedown    鼠标按钮被按下。</li>
<li>onmouseup    鼠标按键被松开。</li>
<li>onmousemove    鼠标被移动。</li>
<li>onmouseover    鼠标移到某元素之上。</li>
<li>onmouseout    鼠标从某元素移开。</li>
</ol>
</li>
<li><p>键盘事件：</p>
<ol>
<li>onkeydown    某个键盘按键被按下。    </li>
<li>onkeyup        某个键盘按键被松开。</li>
<li>onkeypress    某个键盘按键被按下并松开。</li>
</ol>
</li>
<li><p>选择和改变</p>
<ol>
<li>onchange    域的内容被改变。</li>
<li>onselect    文本被选中。</li>
</ol>
</li>
</ol>
<pre><code class="JavaScript">    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;事件&lt;/title&gt;
        &lt;script&gt;
            var btn = document.getElementById(&quot;btn&quot;);//获取不到,body中没加载到
            //2，加载完成事件
            window.onload=function () &#123;
                //3、鼠标事件：
                document.getElementById(&quot;btn&quot;).onmouseover=function () &#123;
                    alert(&quot;鼠标移动到元素之上&quot;);
                &#125;;
                document.getElementById(&quot;btn&quot;).onmousedown=function (event) &#123;
                    //alert(&quot;鼠标点击了&quot;);
                    alert(event.button);//鼠标左键，弹出0，右键弹出2，滚轮弹1
                &#125;;
               //键盘事件
                document.getElementById(&quot;btn&quot;).onkeydown=function (event) &#123;
                    //alert(&quot;键盘点击了&quot;);
                    if(event.keyCode==13)&#123;//13对应回车键
                        alert(&quot;表单提交&quot;)
                    &#125;
                &#125;;
    
                //选中和改变：
                document.getElementById(&quot;city&quot;).onchange=function (event) &#123;
                    alert(&quot;数据改变&quot;);
                &#125;;
    
                document.getElementById(&quot;from&quot;).onsubmit=function () &#123;
                    //校验用户名格式是否正确
                    var flag = true;
                    return flag;//返回值为true或没有，则提交表单，返回false则不提交表单
                &#125;
            &#125;;
            function checkfrom() &#123;
                return true;
            &#125;
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;!--&lt;input type=&quot;text&quot; id=&quot;btn&quot;&gt;--&gt;
    &lt;form action=&quot;#&quot; id=&quot;from&quot; onsubmit=&quot;return  checkfrom()&quot;&gt;
        &lt;input name=&quot;username&quot; id=&quot;username&quot;&gt;
        &lt;select id=&quot;city&quot;&gt;
            &lt;option&gt;--请选择--&lt;/option&gt;
            &lt;option&gt;--北京--&lt;/option&gt;
            &lt;option&gt;--上海--&lt;/option&gt;
            &lt;option&gt;--广州--&lt;/option&gt;
        &lt;/select&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<ol start="6">
<li>表单事件：<ol>
<li><p>onsubmit    确认按钮被点击。</p>
</li>
<li><p>onreset    重置按钮被点击。</p>
<pre><code class="JavaScript">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;Title&lt;/title&gt;
 &lt;script type=&quot;text/javascript&quot; &gt;
     // 静态注册表单提交事务
     function onsubmitFun()&#123;
         // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交
         alert(&quot;静态注册表单提交事件----发现不合法&quot;);

         return flase;
     &#125;

     window.onload = function () &#123;
         //1 获取标签对象
         var formObj = document.getElementById(&quot;form01&quot;);
         //2 通过标签对象.事件名 = function()&#123;&#125;
         formObj.onsubmit = function () &#123;
             // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交
             alert(&quot;动态注册表单提交事件----发现不合法&quot;);

             return false;
         &#125;
     &#125;

 &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;!--return false 可以阻止 表单提交 --&gt;
 &lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot; onsubmit=&quot;return onsubmitFun();&quot;&gt;
     &lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&gt;
 &lt;/form&gt;
 &lt;form action=&quot;http://localhost:8080&quot; id=&quot;form01&quot;&gt;
     &lt;input type=&quot;submit&quot; value=&quot;动态注册&quot;/&gt;
 &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<p>​    </p>
<h3 id="1-8-DOM"><a href="#1-8-DOM" class="headerlink" title="1.8 DOM"></a>1.8 DOM</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>DOM 全称是 Document Object Model 文档对象模型，就是把文档中的标签，属性，文本，转换成为对象来管理。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p>
<p>图解：</p>
<img src="/2020/09/13/JavaScript/image-20200906195323580.png" alt="image-20200906195323580">

<p>DOM - 针对任何结构化文档的标准模型 </p>
<ul>
<li>Document：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment:注释对象</li>
<li>Node：节点对象，其他5个的父对象</li>
</ul>
<p><strong>Document 对象的理解</strong>： </p>
<ul>
<li>第一点：Document 它管理了所有的 HTML 文档内容。 </li>
<li>第二点：document 它是一种树结构的文档。有层级关系。 </li>
<li>第三点：它让我们把所有的标签 都 对象化 </li>
<li>第四点：我们可以通过 document 访问所有的标签对象。</li>
</ul>
<p><strong>html文档如何对象化</strong></p>
<pre><code class="java">&lt;body&gt; 
    &lt;div id=&quot;div01&quot;&gt;div01&lt;/div&gt; 
&lt;/body&gt; 

class Dom&#123; 
    private String id; //id 属性 
    private String tagName;//表示标签名 
    private Dom parentNode;//父亲 
    private List&lt;Dom&gt; children;// 孩子结点 
    private String innerHTML;// 起始标签和结束标签中间的内容 
&#125;
</code></pre>
<blockquote>
<p>首先，div标签整个为dom对象，有id属性，有div标签，有 <body> 父节点，也有可能有多个子节点所以定义为List，节点类型都为dom类型，所以父节点定义为Dom 子节点也定义为Dom，<div>中有内容，定义innerHTML</div></body></p>
</blockquote>
<h4 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h4><ol>
<li><p>创建(获取)：在html dom模型中可以使用window对象来获取</p>
<p> window.document</p>
</li>
<li><p>方法：</p>
<ol>
<li><p>获取Element对象：</p>
<p> getElementById()： 根据id属性值获取元素对象。id属性值一般唯一</p>
<p> getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组</p>
<p> getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组</p>
<p> getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组</p>
<blockquote>
<p>注：document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象(元素对象)。</p>
</blockquote>
</li>
<li><p>创建其他DOM对象：<br> createAttribute(name)创建拥有指定名称的属性节点，并返回新的 Attr 对象。<br> createComment()    创建注释节点。<br> createElement()    创建元素节点。<br> createTextNode()创建文本节点。</p>
</li>
</ol>
</li>
<li><p>属性：很多(略)</p>
</li>
</ol>
<pre><code class="JavaScript">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;文档对象&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;
&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;
&lt;div class=&quot;cls1&quot;&gt;div4&lt;/div&gt;
&lt;div class=&quot;cls1&quot;&gt;div5&lt;/div&gt;
&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;script&gt;
    //getElementsByTagName()
    var divs = document.getElementsByTagName(&quot;div&quot;);
    alert(divs.length);//数组长度为5

    //getElementsByClassName()
    var clss = document.getElementsByClassName(&quot;cls1&quot;);
    alert(clss.length);//数组长度为2

    //getElementsByName()
    var use = document.getElementsByName(&quot;username&quot;);
    alert(use.length);//数组长度为1

    //createElement()
    var tab = document.createElement(&quot;table&quot;);
    alert(tab);//HTML的table对象
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h4><ol>
<li>获取/创建：通过document来获取和创建</li>
<li>方法：<br> removeAttribute()：删除属性<br> setAttribute()：设置属性</li>
</ol>
<pre><code class="html">&lt;body&gt;
    &lt;input type= &quot;button&quot; value= &quot;设置属性&quot; id= &quot;btn&quot; &gt;
    &lt;input type= &quot;button&quot;  value=&quot;删除属性&quot; id=&quot;bt&quot;&gt;
    &lt;a&gt; 点我 &lt;/a&gt;
    &lt;script&gt;
        //获取a标签
        var ele = document.getElementsByTagName(&quot;a&quot;)[0];
        //给a标签加一个属性
        var btn = document.getElementById(&quot;btn&quot;);
        btn.onclick=function () &#123;
            ele.setAttribute(&quot;href&quot;,&quot;https://www.baidu.com&quot;);
        &#125;
        var bt = document.getElementById(&quot;bt&quot;);
        bt.onclick=function () &#123;
            ele.removeAttribute(&quot;href&quot;);
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="Node：节点对象"><a href="#Node：节点对象" class="headerlink" title="Node：节点对象"></a>Node：节点对象</h4><ol>
<li><p>特点：所有dom对象都可以被认为是一个节点</p>
</li>
<li><p>方法：</p>
<p> CRUD dom树：</p>
<ul>
<li><p><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点。</p>
</li>
<li><p><code>removeChild()</code>：删除（并返回）当前节点的指定子节点。</p>
</li>
<li><p> <code>replaceChild()</code>：用新节点替换一个子节点。</p>
</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li><code>childNodes</code> 属性，获取当前节点的所有子节点 </li>
<li><code>firstChild</code> 属性，获取当前节点的第一个子节点 </li>
<li><code>lastChild</code> 属性，获取当前节点的最后一个子节点 </li>
<li><code>parentNode</code> 属性，获取当前节点的父节点 </li>
<li><code>nextSibling</code> 属性，获取当前节点的下一个节点 </li>
<li><code>previousSibling</code> 属性，获取当前节点的上一个节点 </li>
<li><code>className</code> 用于获取或设置标签的 class 属性值 </li>
<li><code>innerHTML</code> 属性，表示获取/设置起始标签和结束标签中的内容 </li>
<li><code>innerText</code> 属性，表示获取/设置起始标签和结束标签中的文本</li>
<li><code>value</code>属性，它可以设置和获取表单项的 value 属性值。 跟 JQuery的<code>val()</code>方法 一样</li>
</ul>
</li>
</ol>
<pre><code class="JavaScript">&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;dom查询&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function()&#123;
        //1.查找#bj节点
        document.getElementById(&quot;btn01&quot;).onclick = function () &#123;
            var bjObj = document.getElementById(&quot;bj&quot;);
            alert(bjObj.innerHTML);
        &#125;
        //2.查找所有li节点
        var btn02Ele = document.getElementById(&quot;btn02&quot;);
        btn02Ele.onclick = function()&#123;
            var lis = document.getElementsByTagName(&quot;li&quot;);
            alert(lis.length)
        &#125;;
        //3.查找name=gender的所有节点
        var btn03Ele = document.getElementById(&quot;btn03&quot;);
        btn03Ele.onclick = function()&#123;
            var genders = document.getElementsByName(&quot;gender&quot;);
            alert(genders.length)
        &#125;;
        //4.查找#city下所有li节点
        var btn04Ele = document.getElementById(&quot;btn04&quot;);
        btn04Ele.onclick = function()&#123;
            //1 获取id为city的节点
            //2 通过city节点.getElementsByTagName按标签名查子节点
            var lis = document.getElementById(&quot;city&quot;).getElementsByTagName(&quot;li&quot;);
            alert(lis.length)
        &#125;;
        //5.返回#city的所有子节点
        var btn05Ele = document.getElementById(&quot;btn05&quot;);
        btn05Ele.onclick = function()&#123;
            //1 获取id为city的节点
            //2 通过city获取所有子节点
            alert(document.getElementById(&quot;city&quot;).childNodes.length);
        &#125;;
        //6.返回#phone的第一个子节点
        var btn06Ele = document.getElementById(&quot;btn06&quot;);
        btn06Ele.onclick = function()&#123;
            // 查询id为phone的节点
            alert( document.getElementById(&quot;phone&quot;).firstChild.innerHTML );
        &#125;;
        //7.返回#bj的父节点
        var btn07Ele = document.getElementById(&quot;btn07&quot;);
        btn07Ele.onclick = function()&#123;
            //1 查询id为bj的节点
            var bjObj = document.getElementById(&quot;bj&quot;);
            //2 bj节点获取父节点
            alert( bjObj.parentNode.innerHTML );
        &#125;;
        //8.返回#android的前一个兄弟节点
        var btn08Ele = document.getElementById(&quot;btn08&quot;);
        btn08Ele.onclick = function()&#123;
            // 获取id为android的节点
            // 通过android节点获取前面兄弟节点
            alert( document.getElementById(&quot;android&quot;).previousSibling.innerHTML );
        &#125;;
        //9.读取#username的value属性值
        var btn09Ele = document.getElementById(&quot;btn09&quot;);
        btn09Ele.onclick = function()&#123;
            alert(document.getElementById(&quot;username&quot;).value);
        &#125;;
        //10.设置#username的value属性值
        var btn10Ele = document.getElementById(&quot;btn10&quot;);
        btn10Ele.onclick = function()&#123;
            document.getElementById(&quot;username&quot;).value = &quot;hello DOM&quot;;
        &#125;;
        //11.返回#bj的文本值
        var btn11Ele = document.getElementById(&quot;btn11&quot;);
        btn11Ele.onclick = function()&#123;
            alert(document.getElementById(&quot;city&quot;).innerHTML);
            // alert(document.getElementById(&quot;city&quot;).innerText);
        &#125;;
    &#125;;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;total&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;
        &lt;p&gt;
            你喜欢哪个城市?
        &lt;/p&gt;
        &lt;ul id=&quot;city&quot;&gt;
            &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt;
            &lt;li&gt;上海&lt;/li&gt;
            &lt;li&gt;东京&lt;/li&gt;
            &lt;li&gt;首尔&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br&gt;
        &lt;p&gt;
            你喜欢哪款单机游戏?
        &lt;/p&gt;
        &lt;ul id=&quot;game&quot;&gt;
            &lt;li id=&quot;rl&quot;&gt;红警&lt;/li&gt;
            &lt;li&gt;实况&lt;/li&gt;
            &lt;li&gt;极品飞车&lt;/li&gt;
            &lt;li&gt;魔兽&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br /&gt;
        &lt;p&gt;
            你手机的操作系统是?
        &lt;/p&gt;
        &lt;ul id=&quot;phone&quot;&gt;&lt;li&gt;IOS&lt;/li&gt;&lt;li id=&quot;android&quot;&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt;
    &lt;/div&gt;

    &lt;div class=&quot;inner&quot;&gt;
        gender:
        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt;
        Male
        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt;
        Female
        &lt;br&gt;
        &lt;br&gt;
        name:
        &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;username&quot; value=&quot;abcde&quot;/&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;btnList&quot;&gt;
    &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;查找#city 下所有li节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;返回#city 的所有子节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;返回#phone 的第一个子节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;返回#bj 的父节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn08&quot;&gt;返回#android 的前一个兄弟节点&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn09&quot;&gt;返回#username 的value属性值&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn10&quot;&gt;设置#username 的value属性值&lt;/button&gt;&lt;/div&gt;
    &lt;div&gt;&lt;button id=&quot;btn11&quot;&gt;返回#bj 的文本值&lt;/button&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-9-BOM"><a href="#1-9-BOM" class="headerlink" title="1.9 BOM"></a>1.9 BOM</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ul>
<li>Browser Object Model 浏览器对象模型</li>
<li>将浏览器的各个组成部分封装成对象。</li>
</ul>
<h4 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h4><ul>
<li>Window：窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象</li>
<li>Location：地址栏对象</li>
</ul>
<h4 id="Window：窗口对象"><a href="#Window：窗口对象" class="headerlink" title="Window：窗口对象"></a>Window：窗口对象</h4><ol>
<li>方法</li>
</ol>
<pre><code class="JavaScript">&lt;script&gt;
        /*
                与弹出框有关的方法：
                    alert();显示带有一段消息和一个确认按钮的警告框
                    confirm();显示带有一段消息以及确认按钮和取消按钮的对话框。
                        如果点击确定按钮，方法返回true
                        如果点击取消按钮，方法返回false
                    prompt();显示可提示用户输入的对话框。
                        返回值，获取用户输入的值
                 与打开关闭有关的方法
                    open();打开一个新的窗口
                        返回值是一个window
                    close();关闭浏览器窗口
                        谁调用我，我关谁
                  与定时器有关的方法
                    setTimeout()    在指定的毫秒数后调用函数或计算表达式。
                        参数：
                            js代码或者方法对象
                            毫秒值
                         返回值：返回唯一标识，用于取消定时器
                    clearTimeout()    取消由 setTimeout() 方法设置的 timeout。

                    setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。
                    clearInterval()    取消由 setInterval() 设置的 timeout。
         */
        //方法
        alert(&quot;Hello&quot;);
        window.alert(&quot;world&quot;);

        var bool = confirm(&quot;你确定退出吗？&quot;);
        if (bool)&#123;
            //退出操作
        &#125;else&#123;
            //提示
        &#125;
        document.write(bool);

        prompt();
        prompt(&quot;请输入用户名&quot;);
        var result=prompt(&quot;请输入用户名&quot;);
        document.write(result);

        //打开一个新窗口
        // open();

        //一次性的定时器
        setTimeout(&quot;alert(&#39;boom....&#39;)&quot;,3000);//3秒之后执行alert

        function fun() &#123;
            alert(&#39;boom....&#39;);
        &#125;
        setTimeout(&quot;fun()&quot;,3000);
        var id=setTimeout(fun,3000);
        //取消定时器
        clearTimeout(id);

        //循环定时器
        var t=setInterval(fun,3000);//每隔三秒执行一次
        //取消定时器
        clearInterval(t);

        //获取当前页面的历史记录
        var h1 = window.history;
        var h2=history;
        document.write(h1);

        //获取Dom对象
        window.document.write(h2);
    &lt;/script&gt;
    &lt;input type=&quot;button&quot; value=&quot;打开窗口&quot; id=&quot;open_btn&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;关闭窗口&quot; id=&quot;close_btn&quot;&gt;
    &lt;script&gt;
        //打开新窗口
        var btn = document.getElementById(&quot;open_btn&quot;);
        var newwindow;
        btn.onclick=function () &#123;
            newwindow=open(&quot;https://www.baidu.com&quot;);
        &#125;;
        //关闭新窗口
        var bt = document.getElementById(&quot;close_btn&quot;);
        bt.onclick=function () &#123;
            // close();
            newwindow.close();
        &#125;;
    &lt;/script&gt;
</code></pre>
<ol start="3">
<li><p>属性：</p>
<p>获取其他BOM对象：</p>
<pre><code>history
location
Navigator
Screen:
</code></pre>
<p>获取DOM对象</p>
<pre><code>document
</code></pre>
</li>
<li><p>特点</p>
</li>
</ol>
<ul>
<li>Window对象不需要创建可以直接使用 window使用。 window.方法名();</li>
<li>window引用可以省略。  方法名();</li>
</ul>
<h4 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h4><p><strong>代码演示</strong></p>
<pre><code class="JavaScript">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;地址栏对象&lt;/title&gt;
    &lt;script&gt;
        /*
        地址栏对象：
            创建：
                window.location
                location
            方法：
                reload()    重新加载当前文档。
            属性：
                href    设置或返回完整的 URL。
         */
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;刷新&quot;&gt;
&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;百度&quot;&gt;

&lt;script&gt;
    //reload方法，点击按钮，刷新当前页面
    var bt = document.getElementById(&quot;btn&quot;);
    bt.onclick=function () &#123;
        location.reload();
    &#125;;

    //获取href
    var hr=location.href;
    alert(hr);

    //点击按钮，访问百度
    var bt1 = document.getElementById(&quot;btn1&quot;);
    bt1.onclick=function () &#123;
        location.href=&quot;https://www.baidu.com&quot;;
    &#125;;
&lt;/script&gt;
</code></pre>
<h4 id="History：历史记录对象"><a href="#History：历史记录对象" class="headerlink" title="History：历史记录对象"></a>History：历史记录对象</h4><ol>
<li>创建(获取)：window.history       history</li>
<li>方法：</li>
</ol>
<ul>
<li><p>back()    加载 history 列表中的前一个 URL。</p>
</li>
<li><p>forward()    加载 history 列表中的下一个 URL。</p>
</li>
<li><p>go(参数)    加载 history 列表中的某个具体页面。</p>
<p>参数：</p>
<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
<ol start="3">
<li>属性：</li>
</ol>
<ul>
<li>length    返回当前窗口历史列表中的 URL 数量。</li>
</ul>
<pre><code class="JavaScript">&lt;body&gt;
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;历史记录&quot;&gt;
&lt;a href=&quot;08_Bom_History对象2.html&quot;&gt;08历史记录页面2&lt;/a&gt;
&lt;input type=&quot;button&quot; id=&quot;forward&quot; value=&quot;前进&quot;&gt;
&lt;script&gt;
    var btn = document.getElementById(&quot;btn&quot;);
    btn.onclick=function () &#123;
        //获取当前历史记录个数
        var length = history.length;
        alert(length);
    &#125;;

    //前进
    var fd=document.getElementById(&quot;forward&quot;);
    fd.onclick=function () &#123;
        // history.forward();
        history.go(1);
    &#125;
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><strong>轮播图案例</strong></p>
<pre><code class="JavaScript">&lt;body&gt;
&lt;img src=&quot;img/banner_1.jpg&quot; id=&quot;pic1&quot;&gt;
&lt;input type=&quot;button&quot; id=&quot;back&quot; value=&quot;后退&quot;&gt;
&lt;script&gt;
    /*
    在页面上使用img标签展示图片
    定义一个方法，修改图片src属性
    定义一个定时器，每隔两秒调用一次
     */
    var num=1;
    function fun() &#123;
        num++;
        if (num&gt;3)&#123;
            num=1;
        &#125;
        var pic = document.getElementById(&quot;pic1&quot;);
        pic.src=&quot;img/banner_&quot;+num+&quot;.jpg&quot;;

    &#125;

    setInterval(fun,2000);

    //后退操作
    var bk=document.getElementById(&quot;back&quot;);
    bk.onclick=function () &#123;
        // history.back();
        history.go(-1);
    &#125;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-10(Sentinel服务熔断，降级，限流)</title>
    <url>/2021/03/20/SpringCloud-10/</url>
    <content><![CDATA[<h1 id="SpringCloud-10"><a href="#SpringCloud-10" class="headerlink" title="SpringCloud-10"></a>SpringCloud-10</h1><h2 id="1、SpringCloud-Alibaba-Sentinel"><a href="#1、SpringCloud-Alibaba-Sentinel" class="headerlink" title="1、SpringCloud Alibaba Sentinel"></a>1、SpringCloud Alibaba Sentinel</h2><h3 id="1-1-Sentinel概述"><a href="#1-1-Sentinel概述" class="headerlink" title="1.1 Sentinel概述"></a>1.1 Sentinel概述</h3><p>官网：</p>
<ul>
<li><a href="https://github.com/alibaba/Sentinel/wiki">https://github.com/alibaba/Sentinel/wiki</a></li>
</ul>
<p>是什么？</p>
<ul>
<li>轻量级的流量控制，熔断降级java库</li>
<li>就跟Hystrix功能一样</li>
</ul>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324083510525.png" alt="image-20210324083510525"></p>
<p>主要特性：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324083741442.png" alt="image-20210324083741442"></p>
<p>服务使用中的各种问题</p>
<ul>
<li>服务雪崩</li>
<li>服务降级</li>
<li>服务熔断</li>
<li>服务限流</li>
</ul>
<h3 id="1-2-Sentinel的下载安装"><a href="#1-2-Sentinel的下载安装" class="headerlink" title="1.2 Sentinel的下载安装"></a>1.2 Sentinel的下载安装</h3><p>Sentinel由后台和前台8080组成</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324090840460.png" alt="image-20210324090840460"></p>
<p>下载好Sentinel的jar包之后，直接<code>java -jar sentinel-dashboard-1.7.0.jar</code>运行。</p>
<p>前提是有java环境以及8080端口不能被占用<img src="/2021/03/20/SpringCloud-10/image-20210324091400897.png" alt="image-20210324091400897"></p>
<p>访问Sentinel管理界面：localhost:8080，账号密码均为sentinel</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324091510395.png" alt="image-20210324091510395"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324091543018.png" alt="image-20210324091543018"></p>
<h3 id="1-3-初始化演示工程"><a href="#1-3-初始化演示工程" class="headerlink" title="1.3 初始化演示工程"></a>1.3 初始化演示工程</h3><p><strong>新建Module：</strong>cloudalibaba-sentinel-server8401</p>
<p>POM：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-sentinel-server8401&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--SpringCloud ailibaba nacos --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringCloud ailibaba sentinel --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--openfeign--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringBoot整合Web组件+actuator --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--日常通用jar包配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;4.6.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>yml：</p>
<pre><code class="yml">server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard地址
        port: 8719

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<p>主启动类：</p>
<pre><code class="java">package com.practice.springcloud.alibaba;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class MainApp8401
&#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MainApp8401.class, args);
    &#125;
&#125;
</code></pre>
<p>业务类：controller</p>
<pre><code>@RestController
@Slf4j
public class FlowLimitController
&#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA()
    &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB()
    &#123;
        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);
        return &quot;------testB&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><p>启动Nacos</p>
<p>在Nacos解压目录下用cmd启动startup.cmd</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324093807089.png" alt="image-20210324093807089"></p>
<p>在Sentinel的jar包目录下启动Sentinel的jar包</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324093917245.png" alt="image-20210324093917245"></p>
<p>然后启动8401项目</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324094105085.png" alt="image-20210324094105085"></p>
<p>此时刷新Sentinel网页端页面，发现什么也没有</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324094142605.png" alt="image-20210324094142605"></p>
<p>因为Sentinel采用的是懒加载，需要访问一次才有显示</p>
<ul>
<li><a href="http://localhost:8401/testA">http://localhost:8401/testA</a></li>
<li><a href="http://localhost:8401/testB">http://localhost:8401/testB</a></li>
</ul>
<p>此时再查看网页端页面，发现有内容</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324094334537.png" alt="image-20210324094334537"></p>
<h2 id="2、流控规则"><a href="#2、流控规则" class="headerlink" title="2、流控规则"></a>2、流控规则</h2><p><img src="/2021/03/20/SpringCloud-10/image-20210324094851901.png" alt="image-20210324094851901"></p>
<p>资源名：唯一名称，默认请求路径</p>
<p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）</p>
<p>阈值类型/单机阈值：</p>
<ul>
<li>QPS（每秒钟请求数量）：当调用改api的QPS达到阈值的时候，进行限流</li>
<li>线程数：当调用该api的线程数达到阈值的时候，进行限流</li>
</ul>
<p>是否集群：不需要集群</p>
<p>流控模式：</p>
<ul>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】</li>
</ul>
<p>流控效果：</p>
<ul>
<li>快速失败：直接失败，抛异常</li>
<li>Warm Up：根据codeFactor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值</li>
<li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须要设置为QPS，否则无效</li>
</ul>
<h3 id="2-1-流控模式"><a href="#2-1-流控模式" class="headerlink" title="2.1 流控模式"></a>2.1 流控模式</h3><p>直接（默认）：直接 -&gt; 快速失败</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324100546541.png" alt="image-20210324100546541"></p>
<p>此时表示1秒钟查询一次可以，若一秒钟查询次数超过1次，就直接-快速失败，报默认错误</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324100717609.png" alt="image-20210324100717609"></p>
<p>关联：当关联的资源达到阈值时，就限流自己</p>
<ul>
<li>当与A关联的资源B达到阈值后，就限流自己</li>
<li>(支付接口达到阈值后,就限流下订单的接口,防止连坐效应)</li>
</ul>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324102258489.png" alt="image-20210324102258489"></p>
<p>此时表示当B 1秒钟超过阈值1，就会将A挂掉。</p>
<p>测试，用postman模拟并发密集访问testB，此时再访问testA，发现A挂掉了</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324103152037.png" alt="image-20210324103152037"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324103056164.png" alt="image-20210324103056164"></p>
<p>链路：多个请求调用了同一个微服务</p>
<h3 id="2-2-流控效果"><a href="#2-2-流控效果" class="headerlink" title="2.2 流控效果"></a>2.2 流控效果</h3><p><strong>直接-&gt;快速失败</strong>(默认的流控处理)：直接失败，抛出异常</p>
<p><strong>预热：</strong></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324103936005.png" alt="image-20210324103936005"></p>
<p>公式:</p>
<ul>
<li>阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值</li>
<li>默认coldFactory为3，即请求QPS从threshold/3开始，经预热时长逐渐升至设定的QPS阈值</li>
</ul>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324104409676.png" alt="image-20210324104409676"></p>
<p>此时表示A的阈值为10，指最终效果是1秒钟最大访问次数为10，冷加载因子codeFactory默认为3，则最开始阈值为 10/3=3，通过预热时长5s慢慢增长到阈值10</p>
<p><strong>排队等待：</strong></p>
<p>匀速排队，让请求以均匀的速度通过，阈值类型必须设成QPS，否则无效</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324105319560.png" alt="image-20210324105319560"></p>
<p>此时表示A每秒10次请求，超过的话就排队等待，等待的超时时间为50000毫秒</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324105607787.png" alt="image-20210324105607787"></p>
<h2 id="3、降级规则"><a href="#3、降级规则" class="headerlink" title="3、降级规则"></a>3、降级规则</h2><p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其他的资源而导致级联错误。</p>
<p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException）</p>
<p>Sentinel的断路器<strong>没有半开</strong>状态的：</p>
<ul>
<li>半开的状态系统自动去检测是否请求异常, 没有异常就关闭断路器恢复使用,有异常则继续打开断路器不可用.具体可以参考Hystrix</li>
</ul>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324110440987.png" alt="image-20210324110440987"></p>
<p>RT（平均响应时间，秒级）</p>
<ul>
<li>平均响应时间 超出阈值 且 在时间窗口内通过的请求&gt;=5 ，两个条件同时满足后出发降级</li>
<li>窗口期过后关闭断路器</li>
<li>RT最大4900（更大需要通过-Dcsp.sentinel.statistic.max.rt=xxx才能生效）</li>
</ul>
<p>异常比例（秒级）</p>
<ul>
<li>QPS&gt;=5且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</li>
</ul>
<p>异常数（分钟级）</p>
<ul>
<li>异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</li>
</ul>
<h3 id="3-1-RT测试"><a href="#3-1-RT测试" class="headerlink" title="3.1 RT测试"></a>3.1 RT测试</h3><p>代码：</p>
<pre><code class="java">@RestController
@Slf4j
public class FlowLimitController
&#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA()
    &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB()
    &#123;
        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);
        return &quot;------testB&quot;;
    &#125;
    @GetMapping(&quot;/testD&quot;)
    public String testD()
    &#123;
        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;
        log.info(&quot;testD 测试RT&quot;);
        
        return &quot;------testD&quot;;
    &#125;
&#125;
</code></pre>
<p>配置</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324133554619.png" alt="image-20210324133554619"></p>
<p>表示要求在200毫秒内处理异常，在未来的1秒钟以内如果没解决，就熔断，保护系统</p>
<p>JMeter压测：1秒发10个请求</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324134725942.png" alt="image-20210324134725942"></p>
<p>按照上述配置，永远1秒钟进来10个线程调用testD，我们希望200毫秒处理完本次服务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开，微服务不可用</p>
<p>此时就会触发熔断</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324135836455.png" alt="image-20210324135836455"></p>
<h3 id="3-2-异常比例"><a href="#3-2-异常比例" class="headerlink" title="3.2 异常比例"></a>3.2 异常比例</h3><p><img src="/2021/03/20/SpringCloud-10/image-20210324141232594.png" alt="image-20210324141232594"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324141354890.png" alt="image-20210324141354890"></p>
<p>测试代码：</p>
<pre><code class="java">@RestController
@Slf4j
public class FlowLimitController
&#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA()
    &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB()
    &#123;
        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);
        return &quot;------testB&quot;;
    &#125;
    @GetMapping(&quot;/testD&quot;)
    public String testD()
    &#123;

        log.info(&quot;testD 异常比例&quot;);
        int age = 10/0;
        return &quot;------testD&quot;;
    &#125;
&#125;
</code></pre>
<p>配置</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324141956227.png" alt="image-20210324141956227"></p>
<p>此时触发熔断：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324142115868.png" alt="image-20210324142115868"></p>
<p>若没有触发降级将直接报错：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324142401530.png" alt="image-20210324142401530"></p>
<p>所以，按照上述配置，单独访问一次，必然来一次报错一次，开启JMeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启（保险丝跳闸），微服务不可用了，不再报错error而是服务降级了</p>
<h3 id="3-3-异常数"><a href="#3-3-异常数" class="headerlink" title="3.3 异常数"></a>3.3 异常数</h3><p><img src="/2021/03/20/SpringCloud-10/image-20210324142708044.png" alt="image-20210324142708044"></p>
<p>时间窗口一定要大于60秒</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324142648446.png" alt="image-20210324142648446"></p>
<p>异常数是按分钟统计的</p>
<p>测试代码：</p>
<pre><code class="java">@RestController
@Slf4j
public class FlowLimitController
&#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA()
    &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB()
    &#123;
        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);
        return &quot;------testB&quot;;
    &#125;
    @GetMapping(&quot;/testD&quot;)
    public String testD()
    &#123;
//        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;
//        log.info(&quot;testD 测试RT&quot;);

        log.info(&quot;testD 异常比例&quot;);
        int age = 10/0;
        return &quot;------testD&quot;;
    &#125;
    @GetMapping(&quot;/testE&quot;)
    public String testE()
    &#123;
        log.info(&quot;testE 测试异常数&quot;);
        int age = 10/0;
        return &quot;------testE 测试异常数&quot;;
    &#125;
&#125;
</code></pre>
<p>配置：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324143355535.png" alt="image-20210324143355535"></p>
<p><a href="http://localhost:8401/testE%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%BB%9D%E5%AF%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E9%9B%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0error%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BE%BE%E5%88%B05%E6%AC%A1%E6%8A%A5%E9%94%99%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%86%94%E6%96%AD%E5%90%8E%E9%99%8D%E7%BA%A7">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324143928282.png" alt="image-20210324143928282"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324143759722.png" alt="image-20210324143759722"></p>
<h2 id="4、热点Key限流"><a href="#4、热点Key限流" class="headerlink" title="4、热点Key限流"></a>4、热点Key限流</h2><p><img src="/2021/03/20/SpringCloud-10/image-20210324144028937.png" alt="image-20210324144028937"></p>
<p>兜底方法分为系统默认和客户自定义两种，</p>
<p>之前的case，限流出问题之后，都是用Sentinel系统默认的提示：Blocked by Sentinel(flow limiting)</p>
<p>我们能够自定义，类似Hystrix，某个方法出问题了，就找对应的兜底降级方法。</p>
<p>从HystrixCommand到@SentinelResource</p>
<p>测试代码：</p>
<pre><code class="java">@RestController
@Slf4j
public class FlowLimitController
&#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA()
    &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB()
    &#123;
        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);
        return &quot;------testB&quot;;
    &#125;
    @GetMapping(&quot;/testD&quot;)
    public String testD()
    &#123;
//        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;
//        log.info(&quot;testD 测试RT&quot;);

        log.info(&quot;testD 异常比例&quot;);
        int age = 10/0;
        return &quot;------testD&quot;;
    &#125;
    @GetMapping(&quot;/testE&quot;)
    public String testE()
    &#123;
        log.info(&quot;testE 测试异常数&quot;);
        int age = 10/0;
        return &quot;------testE 测试异常数&quot;;
    &#125;
    @GetMapping(&quot;/testHotKey&quot;)
    @SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)
    public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1,
                             @RequestParam(value = &quot;p2&quot;,required = false) String p2)
    &#123;
        //int age = 10/0;
        return &quot;------testHotKey&quot;;
    &#125;
    public String deal_testHotKey (String p1, String p2, BlockException exception)
    &#123;
        return &quot;------deal_testHotKey,o(╥﹏╥)o&quot;;  //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)
    &#125;
&#125;
</code></pre>
<p>配置：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324150822616.png" alt="image-20210324150822616"></p>
<p>结果：第0个参数p1加了限制，一秒内点击超过1则降级处理</p>
<ul>
<li><code>@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;dealHandler_testHotKey&quot;)</code>出现自定义的兜底方法dealHandler_testHotKey</li>
<li><code>@SentinelResource(value = &quot;testHotKey&quot;)</code>出现默认的兜底方法显示error page，会将异常打到前台</li>
</ul>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324151003428.png" alt="image-20210324151003428"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324151808585.png" alt="image-20210324151808585"></p>
<h3 id="4-1-参数例外项"><a href="#4-1-参数例外项" class="headerlink" title="4.1 参数例外项"></a>4.1 参数例外项</h3><p>上述例子演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流</p>
<p>特殊情况：</p>
<ul>
<li>普通：超过1秒后，达到阈值1后马上被限流</li>
<li>我们期望当p1参数当它是某个特殊值时，它的限流和平时不一样</li>
<li>例如，加入p1值为5时，它的阈值达到200</li>
</ul>
<p>配置：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324153040177.png" alt="image-20210324153040177"></p>
<p>此时当p1等与5时，阈值为200，当p1不为5时，阈值变为平常的1</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324153309437.png" alt="image-20210324153309437"></p>
<p><strong>注意点：</strong>热点参数必须是基本类型或者String</p>
<h2 id="5、系统规则"><a href="#5、系统规则" class="headerlink" title="5、系统规则"></a>5、系统规则</h2><p><img src="/2021/03/20/SpringCloud-10/image-20210324154302335.png" alt="image-20210324154302335"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324154617818.png" alt="image-20210324154617818"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324154741268.png" alt="image-20210324154741268"></p>
<p>配置：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324155013852.png" alt="image-20210324155013852"></p>
<p>此时表示全局配置，只要1秒高于阈值，不管是testA，还是testB都熔断降级</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324155146013.png" alt="image-20210324155146013"></p>
<h2 id="6、-SentinelResource"><a href="#6、-SentinelResource" class="headerlink" title="6、@SentinelResource"></a>6、@SentinelResource</h2><h3 id="6-1-按资源名称限流-后序处理"><a href="#6-1-按资源名称限流-后序处理" class="headerlink" title="6.1 按资源名称限流+后序处理"></a>6.1 按资源名称限流+后序处理</h3><p>首先启动Nacos，Sentinel</p>
<p>修改Module：<code>cloudalibaba-sentinel-server8401</code></p>
<p>POM添加：</p>
<pre><code class="xml">&lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>YML不变</p>
<p>业务类增加RateLimitController</p>
<pre><code class="java">@RestController
public class RateLimitController
&#123;
    @GetMapping(&quot;/byResource&quot;)
    @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)
    public CommonResult byResource()
    &#123;
        return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;));
    &#125;
    public CommonResult handleException(BlockException exception)
    &#123;
        return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\t 服务不可用&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>配置流程规则：</strong></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324160615707.png" alt="image-20210324160615707"></p>
<p>表示1秒钟内查询次数大于1，就跑到我们自定义的处理信息，限流发生</p>
<p>测试：1秒钟点击一次，可以，一秒钟点击多次，限流发生</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324160734940.png" alt="image-20210324160734940"></p>
<h3 id="6-2-按URL地址限流-后序处理"><a href="#6-2-按URL地址限流-后序处理" class="headerlink" title="6.2 按URL地址限流+后序处理"></a>6.2 按URL地址限流+后序处理</h3><p>通过访问的URL限流,会返回Sentinel自带默认的限流处理信息</p>
<p>增加业务类RateLimitController代码</p>
<pre><code class="java">@GetMapping(&quot;/rateLimit/byUrl&quot;)
    @SentinelResource(value = &quot;byUrl&quot;)
    public CommonResult byUrl()
    &#123;
        return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));
    &#125;
</code></pre>
<p>配置流程规则：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324161527888.png" alt="image-20210324161527888"></p>
<p>此时资源名为URL地址，表示1秒钟内查询次数大于1，就会限流发生，我们没有自定义限流规则，是默认的页面</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324161637020.png" alt="image-20210324161637020"></p>
<p><strong>上述两种方式的问题：</strong></p>
<ol>
<li>系统默认的，没有体现我们自给的业务要求</li>
<li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观</li>
<li>每个业务方法都添加一个兜底的，那代码膨胀加剧</li>
<li>全局统一的处理方法没有体现</li>
</ol>
<h3 id="6-3-用户自定义限流处理逻辑"><a href="#6-3-用户自定义限流处理逻辑" class="headerlink" title="6.3 用户自定义限流处理逻辑"></a>6.3 用户自定义限流处理逻辑</h3><ul>
<li><p>创建CustomerBlockHandler类用于自定义限流处理逻辑</p>
<pre><code class="java">package com.practice.springcloud.alibaba.myhandler;

import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.practice.springcloud.entities.CommonResult;

public class CustomerBlockHandler
&#123;
    public static CommonResult handlerException(BlockException exception)
    &#123;
        return new CommonResult(4444,&quot;按客戶自定义,global handlerException----1&quot;);
    &#125;
    public static CommonResult handlerException2(BlockException exception)
    &#123;
        return new CommonResult(4444,&quot;按客戶自定义,global handlerException----2&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>修改业务类RateLimitController</p>
<pre><code class="java">package com.practice.springcloud.alibaba.controller;


import com.alibaba.csp.sentinel.annotation.SentinelResource;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.practice.springcloud.alibaba.myhandler.CustomerBlockHandler;
import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RateLimitController
&#123;
    @GetMapping(&quot;/byResource&quot;)
    @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)
    public CommonResult byResource()
    &#123;
        return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;));
    &#125;
    public CommonResult handleException(BlockException exception)
    &#123;
        return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\t 服务不可用&quot;);
    &#125;
    @GetMapping(&quot;/rateLimit/byUrl&quot;)
    @SentinelResource(value = &quot;byUrl&quot;)
    public CommonResult byUrl()
    &#123;
        return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));
    &#125;
    @GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)
    @SentinelResource(value = &quot;customerBlockHandler&quot;,
            blockHandlerClass = CustomerBlockHandler.class,
            blockHandler = &quot;handlerException2&quot;)
    public CommonResult customerBlockHandler()
    &#123;
        return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));
    &#125;
&#125;
</code></pre>
</li>
<li><p>启动服务，先调用一次<a href="http://localhost:8401/rateLimit/customerBlockHandler">http://localhost:8401/rateLimit/customerBlockHandler</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324164045293.png" alt="image-20210324164045293"></p>
</li>
<li><p>设置限流</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324164151463.png" alt="image-20210324164151463"></p>
</li>
<li><p>再测试，用户自定义</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324164217160.png" alt="image-20210324164217160"></p>
</li>
<li><p>说明：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324164329276.png" alt="image-20210324164329276"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324164739589.png" alt="image-20210324164739589"></p>
</li>
</ul>
<h2 id="7、服务熔断功能"><a href="#7、服务熔断功能" class="headerlink" title="7、服务熔断功能"></a>7、服务熔断功能</h2><p>Sentinel整合ribbon+openFeign+fallback</p>
<h3 id="7-1-Ribbon系列"><a href="#7-1-Ribbon系列" class="headerlink" title="7.1 Ribbon系列"></a>7.1 Ribbon系列</h3><p>启动Nacos和Sentinel</p>
<p>新建服务提供者Module：<code>cloudalibaba-provider-payment9003/9004</code></p>
<p>POM：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-provider-payment9003&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud ailibaba nacos --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringBoot整合Web组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--日常通用jar包配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>YML：</p>
<pre><code class="yml">server:
  port: 9003

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #配置Nacos地址

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<p>主启动类</p>
<pre><code class="java">package com.practice.springcloud.alibaba;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain9003
&#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain9003.class, args);
    &#125;
&#125;
</code></pre>
<p>业务类：controller</p>
<pre><code class="java">@RestController
public class PaymentController
&#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;();
    static
    &#123;
        hashMap.put(1L,new Payment(1L,&quot;28a8c1e3bc2742d8848569891fb42181&quot;));
        hashMap.put(2L,new Payment(2L,&quot;bba8c1e3bc2742d8848569891ac32182&quot;));
        hashMap.put(3L,new Payment(3L,&quot;6ua8c1e3bc2742d8848569891xt92183&quot;));
    &#125;

    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        Payment payment = hashMap.get(id);
        CommonResult&lt;Payment&gt; result = new CommonResult(200,&quot;from mysql,serverPort:  &quot;+serverPort,payment);
        return result;
    &#125;
&#125;
</code></pre>
<p>测试地址：<a href="http://localhost:9003/paymentSQL/1">http://localhost:9003/paymentSQL/1</a></p>
<p>9004与9003一致</p>
<p>新建服务消费者Module：<code>cloudalibaba-consumer-nacos-order84</code></p>
<p>POM：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloudalibaba-consumer-nacos-order84&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud openfeign --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringCloud ailibaba nacos --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--SpringCloud ailibaba sentinel --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringBoot整合Web组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--日常通用jar包配置--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>YML：</p>
<pre><code class="yml">server:
  port: 84


spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    sentinel:
      transport:
        #配置Sentinel dashboard地址
        dashboard: localhost:8080
        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
        port: 8719

#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)
service-url:
  nacos-user-service: http://nacos-payment-provider
</code></pre>
<p>业务类：</p>
<p>ApplicationContextConfig</p>
<pre><code class="java">package com.practice.springcloud.alibaba.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig
&#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate()
    &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<p>CircleBreakController：</p>
<pre><code class="java">@RestController
@Slf4j
public class CircleBreakerController
&#123;
    public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;;

    @Resource
    private RestTemplate restTemplate;

    @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)
    @SentinelResource(value = &quot;fallback&quot;) //没有配置
    public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id)
    &#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id,CommonResult.class,id);

        if (id == 4) &#123;
            throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);
        &#125;else if (result.getData() == null) &#123;
            throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);
        &#125;

        return result;
    &#125;
&#125;
</code></pre>
<p>主启动类：</p>
<pre><code class="java">@EnableDiscoveryClient
@SpringBootApplication
public class OrderNacosMain84
&#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderNacosMain84.class, args);
    &#125;
&#125;
</code></pre>
<p>测试地址：<a href="http://localhost:84/consumer/fallback/1%EF%BC%8C%E5%8F%91%E7%8E%B09003,9004%E7%AB%AF%E5%8F%A3%E4%BA%A4%E6%9B%BF%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">http://localhost:84/consumer/fallback/1，发现9003,9004端口交替出现，实现负载均衡</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324183001040.png" alt="image-20210324183001040"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324183015615.png" alt="image-20210324183015615"></p>
<h4 id="7-1-1-没有任何配置"><a href="#7-1-1-没有任何配置" class="headerlink" title="7.1.1 没有任何配置"></a>7.1.1 没有任何配置</h4><p>此时，上述程序什么都没有配置：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324200454067.png" alt="image-20210324200454067"></p>
<p>如果输入4会报非法参数异常，输入4之外的会报空指针异常(1,2,3，数据库中有，会查到正常数据)</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324200741518.png" alt="image-20210324200741518"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324200801379.png" alt="image-20210324200801379"></p>
<p>这种情况无熔断，无降级，直接给前端客户返回error界面，非常不友好</p>
<h4 id="7-1-2-只配置fallback"><a href="#7-1-2-只配置fallback" class="headerlink" title="7.1.2 只配置fallback"></a>7.1.2 只配置fallback</h4><p><strong>fallback方法管理运行异常，相当于服务降级</strong></p>
<p>此时加一个fallback方法，加一个异常处理的兜底方法</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324201323581.png" alt="image-20210324201323581"></p>
<p>此时再访问4或其他产生异常的数字</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324201440608.png" alt="image-20210324201440608"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324201423890.png" alt="image-20210324201423890"></p>
<p>此时，这两个页面相对于之前的error页面，就显得比较友好了</p>
<h4 id="7-1-3-只配置blockHandler"><a href="#7-1-3-只配置blockHandler" class="headerlink" title="7.1.3 只配置blockHandler"></a>7.1.3 只配置blockHandler</h4><p><img src="/2021/03/20/SpringCloud-10/image-20210324202041834.png" alt="image-20210324202041834"></p>
<p>blockHandler只负责sentinel控制台配置违规</p>
<p>此时正常访问</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324202352729.png" alt="image-20210324202352729"></p>
<p>配置Sentinel：表示1秒内阈值最大为1</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324202617127.png" alt="image-20210324202617127"></p>
<p>此时再点击<a href="http://localhost:84/consumer/fallback/5">http://localhost:84/consumer/fallback/5</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324202709809.png" alt="image-20210324202709809"></p>
<p>此时单击一下则出现error页面，因为这是运行时异常，fallback没设，而blockHandler管不了，所以会报error页面。</p>
<p>此时如果快速点击，则返回异常页面，因为此时已经超过Sentinel设定的最大阈值，所以跳到Sentinel控制的页面，也就是blockHandler所设置的方法</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324202910696.png" alt="image-20210324202910696"></p>
<h4 id="7-1-4-两个都配置"><a href="#7-1-4-两个都配置" class="headerlink" title="7.1.4 两个都配置"></a>7.1.4 两个都配置</h4><p><img src="/2021/03/20/SpringCloud-10/image-20210324203333500.png" alt="image-20210324203333500"></p>
<p>设定Sentinel配置</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324203549954.png" alt="image-20210324203549954"></p>
<p>此时如果每秒访问超过阈值，会报限流</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324203624772.png" alt="image-20210324203624772"></p>
<p>此时如果访问4，产生运行时异常，会显示fallback的兜底方法</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324203657736.png" alt="image-20210324203657736"></p>
<p>此时如果一秒内多次访问4，虽然有异常，但仍会被Sentinel拦截，显示blockHandler设定的方法</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324203814377.png" alt="image-20210324203814377"></p>
<p>所以，若blockHandler和fallback都进行了配置，则被限流级而抛出BlockException时只会进入blockHandler处理逻辑</p>
<h4 id="7-1-5-异常忽略"><a href="#7-1-5-异常忽略" class="headerlink" title="7.1.5 异常忽略"></a>7.1.5 异常忽略</h4><p><img src="/2021/03/20/SpringCloud-10/image-20210324204513619.png" alt="image-20210324204513619"></p>
<p>此时4的异常被忽略，不会fallback降级</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324204725384.png" alt="image-20210324204725384"></p>
<h3 id="7-2-OpenFeign系列"><a href="#7-2-OpenFeign系列" class="headerlink" title="7.2 OpenFeign系列"></a>7.2 OpenFeign系列</h3><p>修改84模块</p>
<ul>
<li>84消费者调用提供者9003，Feign组件一般是消费侧</li>
</ul>
<p>POM：加入依赖</p>
<pre><code class="xml"> &lt;!--SpringCloud openfeign --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>YML：</p>
<pre><code class="yml"># 激活Sentinel对Feign的支持
feign:
  sentinel:
    enabled: true
</code></pre>
<p>业务类Service:</p>
<p>PaymentService:</p>
<pre><code class="java">package com.practice.springcloud.alibaba.service;

import com.practice.springcloud.entities.CommonResult;
import com.practice.springcloud.entities.Payment;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)
public interface PaymentService
&#123;
    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<p>PaymentFallbackService:</p>
<pre><code class="java">@Component
public class PaymentFallbackService implements PaymentService
&#123;
    @Override
    public CommonResult&lt;Payment&gt; paymentSQL(Long id)
    &#123;
        return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;));
    &#125;
&#125;
</code></pre>
<p>业务类Controller：</p>
<pre><code class="java"> @Resource
    private PaymentService paymentService;

    @GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return paymentService.paymentSQL(id);
    &#125;
</code></pre>
<p>主启动类：</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324205611681.png" alt="image-20210324205611681"></p>
<p>运行测试：9004,9003轮询切换</p>
<p><a href="http://localhost:84/consumer/paymentSQL/1">http://localhost:84/consumer/paymentSQL/1</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324210022034.png" alt="image-20210324210022034"></p>
<p>测试当9003/9004关闭，看84消费侧是否会自动降级，不会被耗死</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324211043247.png" alt="image-20210324211043247"></p>
<p>再访问<a href="http://localhost:84/consumer/paymentSQL/1">http://localhost:84/consumer/paymentSQL/1</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324210943831.png" alt="image-20210324210943831"></p>
<p>发现服务自动降级</p>
<p>熔断框架比较</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324211135489.png" alt="image-20210324211135489"></p>
<h2 id="8、Sentinel持久化"><a href="#8、Sentinel持久化" class="headerlink" title="8、Sentinel持久化"></a>8、Sentinel持久化</h2><p>是什么？</p>
<ul>
<li>一旦我们重启应用,sentinel规则消失,生产环境需要将配置规则进行持久化</li>
</ul>
<p>怎么用？</p>
<ul>
<li>将限流规则持久进Nacos保存,只要刷新8401某个rest地址,sentinel控制台的流控规则就能看得到,只要Nacos里面的配置不删除,针对8401上的流控规则持续有效</li>
</ul>
<p>修改cloudalibaba-sentinel-server8401</p>
<ul>
<li>POM：添加nacos依赖</li>
</ul>
<pre><code class="xml">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<ul>
<li>YML，添加Nacos数据源配置</li>
</ul>
<pre><code class="yml">server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard地址
        port: 8719
      datasource:
        ds1:
          nacos:
            server-addr: localhost:8848
            dataId: cloudalibaba-sentinel-service
            groupId: DEFAULT_GROUP
            data-type: json
            rule-type: flow

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;

feign:
  sentinel:
    enabled: true # 激活Sentinel对Feign的支持
</code></pre>
<ul>
<li>添加Nacos的业务规则配置</li>
</ul>
<pre><code class="json">[
    &#123;
        &quot;resource&quot;: &quot;/rateLimit/byUrl&quot;,
        &quot;limitApp&quot;: &quot;default&quot;,
        &quot;grade&quot;: 1,
        &quot;count&quot;: 1,
        &quot;stragegy&quot;: 0,
        &quot;controlBehavior&quot;: 0,
        &quot;clusterMode&quot;: false
    &#125;
]
</code></pre>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324212807465.png" alt="image-20210324212807465"></p>
<p>启动8401刷新Sentinel发现业务规则变了</p>
<p><a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324212948486.png" alt="image-20210324212948486"></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324213041319.png" alt="image-20210324213041319"></p>
<p>此时多次刷新，发现触发流控规则</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324213423416.png" alt="image-20210324213423416"></p>
<p>看看是否持久化：</p>
<p>关闭8401，此时流控规则没有了</p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324213534477.png" alt="image-20210324213534477"></p>
<p>再启动8401，多次访问<a href="http://localhost:8401/rateLimit/byUrl%EF%BC%8C%E5%86%8D%E6%9F%A5%E7%9C%8B%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%87%BA%E7%8E%B0%E4%BA%86">http://localhost:8401/rateLimit/byUrl，再查看流控规则，发现出现了</a></p>
<p><img src="/2021/03/20/SpringCloud-10/image-20210324213703263.png" alt="image-20210324213703263"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基本使用</title>
    <url>/2020/09/30/Spring%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Spring5基本使用"><a href="#Spring5基本使用" class="headerlink" title="Spring5基本使用"></a>Spring5基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ol>
<li>Spring 是轻量级的开源的 JavaEE 框架 </li>
<li>Spring可以解决企业应用开发的复杂性 </li>
<li>Spring 有两个核心部分：IOC 和 Aop <ol>
<li>IOC：控制反转，把创建对象过程交给 Spring 进行管理，包括DI，依赖注入</li>
<li>Aop：面向切面，不修改源代码进行功能增强 </li>
</ol>
</li>
<li>Spring 特点 <ol>
<li>方便解耦，简化开发 </li>
<li>Aop 编程支持 </li>
<li>方便程序测试 </li>
<li>方便和其他框架进行整合 </li>
<li>方便进行事务操作 </li>
<li>降低 API 开发难度 </li>
</ol>
</li>
</ol>
<p>Spring4的模块划分图：从底向上看</p>
<p><img src="/2020/09/30/Spring%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/spring-overview.png" alt="spring-overview"></p>
<p><strong>Test</strong>：Spring的单元测试模块，spring-test-4.2.6.RELEASE.jar</p>
<p><strong>Core Container</strong>：核心容器（IOC）；黑色代表这部分功能由哪些jar包组成，要使用这部分的完整功能，这些jar包都需要导入：</p>
<ul>
<li>Bean：spring-beans-4.2.6.RELEASE.jar  </li>
</ul>
<ul>
<li>Core：spring-core-4.2.6.RELEASE.jar </li>
</ul>
<ul>
<li>Context： spring-context-4.2.6.RELEASE.jar  </li>
</ul>
<ul>
<li>SpEL(Spring Expression Language:Spring表达式语言)：spring-expression-4.2.6.RELEASE.jar</li>
</ul>
<p><strong>AOP+Aspects</strong>：面向切面模块 spring-aop-4.2.6.RELEASE.jar spring-aspects-4.2.6.RELEASE.jar</p>
<p><strong>Data Access/Integration</strong>：数据访问/集成</p>
<ul>
<li>数据访问相关：<ul>
<li>JDBC：spring-jdbc-4.2.6.RELEASE.jar</li>
<li>ORM(Object Relation Mapping)：对象关系映射 spring-orm-4.2.6.RELEASE.jar</li>
<li>Transactions：事务处理简写tx spring-tx-4.2.6.RELEASE.jar</li>
</ul>
</li>
<li>集成相关：OXM：spring-oxm-4.2.6.RELEASE.jar  JMS：spring-jms-4.2.6.RELEASE.jar</li>
</ul>
<p><strong>Web</strong>：Spring开发web应用的模块</p>
<ul>
<li>WebSocket：一门新技术，spring-websocket-4.2.6.RELEASE.jar</li>
</ul>
<ul>
<li>servlet：spring-web-4.2.6.RELEASE.jar，和原生web相关(Servlet)</li>
</ul>
<ul>
<li>Web：spring-webmvc-4.2.6.RELEASE.jar，开发web项目的(web)</li>
</ul>
<ul>
<li>portlet：spring-webmvc-portlet-4.2.6.RELEASE.jar，开发web应用的组件集成</li>
</ul>
<p>用哪个模块导哪个包</p>
<p>IOC(Inversion of Controller) ：控制反转</p>
<ul>
<li>控制：资源获取的方式;<ul>
<li>主动式：(要什么资源自给创造)</li>
<li>被动式：资源的获取不是我们自己创建，而是交给一个容器来创建和设置</li>
</ul>
</li>
</ul>
<p><strong>容器</strong>：管理所有的组件(有功能的类)；假设BookServlet受容器管理，BookService也受容器管理，容器可以自动探查出哪些组件(类)需要用到另一些组件(类)；容器帮我们创建BookService对象，并把BookService对象赋值过去</p>
<p>容器：主动的new资源变为被动的接受资源，称为控制反转</p>
<p>DI(Dependency Injection)：依赖注入；容器能知道哪个组件(类)运行的时候，需要另一个类(组件)；容器通过反射的形式，将容器中准备好的BookService对象注入(利用反射给属性赋值)到BookServlet中</p>
<p>只要容器管理的组件，都能使用容器提供的强大的功能；</p>
<h3 id="1-2-Spring入门"><a href="#1-2-Spring入门" class="headerlink" title="1.2 Spring入门"></a>1.2 Spring入门</h3><ol>
<li>导入Spring相关的jar包</li>
</ol>
<p><img src="/2020/09/30/Spring%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/jar%E5%8C%85.jpg" alt="jar包"></p>
<ol start="2">
<li>创建测试类</li>
</ol>
<pre><code class="java">package com.review.spring5;

public class User &#123;
    public void add()&#123;
        System.out.println(&quot;hello spring5&quot;);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>创建spring配置文件，在配置文件中配置测试的类</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.review.spring5.User&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>编写测试代码</li>
</ol>
<pre><code class="java">public class UserTest &#123;
    @Test
    public void test1()&#123;
        //加载spring配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        //获取配置文件的创建对象
        User user = context.getBean(&quot;user&quot;, User.class);
        System.out.println(user);
        user.add();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>会发现我们并未创建user类的对象，而成功调用了user的add方法</p>
</blockquote>
<h3 id="1-3-IOC概述"><a href="#1-3-IOC概述" class="headerlink" title="1.3 IOC概述"></a>1.3 IOC概述</h3><ol>
<li>IOC是什么<ol>
<li>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 </li>
<li>使用 IOC 目的：为了耦合度降低</li>
<li>IOC包括依赖注入(DI)和依赖查找(DL)</li>
</ol>
</li>
<li>IOC的底层原理<ol>
<li>xml 解析、工厂模式、反射</li>
</ol>
</li>
</ol>
<h3 id="1-4-IOC接口"><a href="#1-4-IOC接口" class="headerlink" title="1.4 IOC接口"></a>1.4 IOC接口</h3><ol>
<li><p>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 </p>
</li>
<li><p>Spring 提供 IOC 容器实现两种方式：（两个接口） </p>
<ol>
<li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用<ul>
<li> 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 </li>
</ul>
</li>
<li>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用<ul>
<li>加载配置文件时候就会把在配置文件对象进行创建 </li>
</ul>
</li>
</ol>
</li>
<li><p>ApplicationContext 接口两个常用的实现类</p>
<ol>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
</ol>
</li>
</ol>
<h3 id="1-5-IOC操作bean管理"><a href="#1-5-IOC操作bean管理" class="headerlink" title="1.5 IOC操作bean管理"></a>1.5 IOC操作bean管理</h3><ol>
<li>什么是 Bean 管理 ，Bean 管理指的是两个操作 <ol>
<li>Spring 创建对象 </li>
<li>Spirng 注入属性 </li>
</ol>
</li>
<li>Bean 管理操作有两种方式 <ol>
<li>基于 xml 配置文件方式实现 </li>
<li>基于注解方式实现</li>
</ol>
</li>
</ol>
<h3 id="1-6-基于XML方式实现bean管理"><a href="#1-6-基于XML方式实现bean管理" class="headerlink" title="1.6 基于XML方式实现bean管理"></a>1.6 基于XML方式实现bean管理</h3><h4 id="1-6-1-基于XML方式创建对象"><a href="#1-6-1-基于XML方式创建对象" class="headerlink" title="1.6.1 基于XML方式创建对象"></a>1.6.1 基于XML方式创建对象</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.review.spring5.User&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol>
<li>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 </li>
<li>在 bean 标签有很多属性，介绍常用的属性<ul>
<li>id 属性：唯一标识 </li>
<li>class 属性：类全路径（包类路径） </li>
</ul>
</li>
<li>创建对象时候，默认也是执行无参数构造方法完成对象创建</li>
</ol>
<h4 id="1-6-2-基于XML方式注入属性"><a href="#1-6-2-基于XML方式注入属性" class="headerlink" title="1.6.2 基于XML方式注入属性"></a>1.6.2 基于XML方式注入属性</h4><ul>
<li>DI：依赖注入，就是注入属性</li>
</ul>
<p><strong>第一种方式</strong>：set方式注入属性</p>
<ul>
<li>先创建带有属性的类</li>
</ul>
<pre><code class="java">package com.review.spring5.bean;

public class Bean &#123;
    //属性
    private String name;
    private String author;
    //设置属性对应的set方法
    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAuthor(String author) &#123;
        this.author = author;
    &#125;
&#125;
</code></pre>
<ul>
<li>创建spring配置文件</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;book&quot; class=&quot;com.review.spring5.bean.Book&quot;&gt;
        &lt;!--使用 property 完成属性注入
        name：类里面属性名称
        value：向属性注入的值
        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;红楼梦&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;author&quot; value=&quot;曹雪芹&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>测试类</li>
</ul>
<pre><code class="java">public class IOCTest &#123;
    @Test
    public void test01()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        //获取配置文件中需要创建的对象
        Book book = context.getBean(&quot;book&quot;, Book.class);
        System.out.println(book);//Book&#123;name=&#39;红楼梦&#39;, author=&#39;曹雪芹&#39;&#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>注意：配置文件中的id值和context.getBean()方法中的第一个参数值保持一致</p>
</blockquote>
<p><strong>第二种方式</strong>：使用有参构造进行属性注入</p>
<ul>
<li>创建测试类</li>
</ul>
<pre><code class="java">public class Orders &#123;
    //属性
    private String name;
    private int age;
    //有参构造器
    public Orders(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<ul>
<li>创建spring配置文件</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;order&quot; class=&quot;com.review.spring5.bean.Orders&quot;&gt;
        &lt;!--有参构造注入属性--&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;曹雪芹&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>测试类</li>
</ul>
<pre><code class="java">@Test
    public void test02()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;);
        //获取配置文件中需要创建的对象
        Orders order = context.getBean(&quot;order&quot;, Orders.class);
        System.out.println(order);//Orders&#123;name=&#39;曹雪芹&#39;, age=23&#125;
    &#125;
</code></pre>
<p><strong>第三种方式</strong>：</p>
<p><code>P名称空间注入</code>，需要有set方法(了解)</p>
<p>以Book测试类为例，xml配置文件，beans中设置<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建，再使用p命名空间--&gt;
    &lt;bean id=&quot;book1&quot; class=&quot;com.review.spring5.bean.Book&quot; p:name=&quot;红楼梦&quot; p:author=&quot;曹雪芹&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><code>c命名空间注入</code>，需要有有参构造方法(了解)</p>
<p>以Orders测试类为例，xml配置文件，beans中设置<code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建，再使用p命名空间--&gt;
    &lt;bean id=&quot;orders&quot; class=&quot;com.review.spring5.bean.Orders&quot; c:name=&quot;曹雪芹&quot; c:age=&quot;23&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="1-6-3-xml注入其他类型属性"><a href="#1-6-3-xml注入其他类型属性" class="headerlink" title="1.6.3 xml注入其他类型属性"></a>1.6.3 xml注入其他类型属性</h4><ol>
<li><p><strong>字面值</strong></p>
<ol>
<li>注入null值</li>
</ol>
<pre><code class="xml">&lt;property name=&quot;name&quot;&gt;
 &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<ol start="2">
<li>属性值有特殊符号</li>
</ol>
<pre><code class="xml">&lt;!--属性值包含特殊符号
    1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;
    2 把带特殊符号内容写到 CDATA
    --&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;&lt;![CDATA[&lt;&lt;红楼梦&gt;&gt;]]&gt;&lt;/value&gt;
    &lt;/property&gt;
</code></pre>
</li>
<li><p><strong>注入属性-外部bean</strong></p>
<ol>
<li>创建两个类 service 类和 dao 类</li>
<li>在 service 调用 dao 里面的方法</li>
</ol>
<pre><code class="java">public class UserDaoImpl implements UserDao &#123;
    @Override
    public void userDaoTest() &#123;
        System.out.println(&quot;userDao...........&quot;);
    &#125;
&#125;

public class UserService &#123;
    //创建userDao属性，生成set方法
    private UserDao userDao;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public void UserServiceTest()&#123;
        System.out.println(&quot;UserServiceTest..........&quot;);
        userDao.userDaoTest();
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>在 spring 配置文件中进行配置</li>
</ol>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建,在Service中调用dao--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.review.spring5.service.UserService&quot;&gt;
        &lt;!--注入 userDao 对象
        name 属性：类里面属性名称
        ref 属性：创建userDao对象bean标签id值
        --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.review.spring5.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>测试类</li>
</ol>
<pre><code class="java">@Test
    public void test03()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);
        //获取配置文件中需要创建的对象
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.UserServiceTest();
        System.out.println(userService);
    &#125;
</code></pre>
</li>
<li><p><strong>注入属性-内部bean</strong></p>
<ol>
<li>一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多 </li>
<li>在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</li>
</ol>
<pre><code class="java">public class Dept &#123;
    private String dname;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
public class Emp &#123;
    private String name;
    private int age;
    //员工属于某一个部门，使用对象形式表示
    private Dept dept;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public void setDept(Dept dept) &#123;
        this.dept = dept;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Emp&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, dept=&quot; + dept +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>在spring配置文件中进行配置</li>
</ol>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;emp&quot; class=&quot;com.review.spring5.bean.Emp&quot;&gt;
        &lt;!--使用 property 完成属性注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;dept&quot;&gt;
            &lt;bean id=&quot;dept&quot; class=&quot;com.review.spring5.bean.Dept&quot;&gt;
                &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>测试类</li>
</ol>
<pre><code class="java">@Test
    public void test04()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean5.xml&quot;);
        //获取配置文件中需要创建的对象
        Emp emp = context.getBean(&quot;emp&quot;, Emp.class);
        System.out.println(emp);//Emp&#123;name=&#39;张三&#39;, age=23, dept=com.review.spring5.bean.Dept@3bf7ca37&#125;
    &#125;
</code></pre>
</li>
<li><p><strong>注入属性-级联赋值</strong></p>
<ol>
<li>第一种方式</li>
</ol>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;emp&quot; class=&quot;com.review.spring5.bean.Emp&quot;&gt;
        &lt;!--p普通属性--&gt;
        &lt;property name=&quot;name&quot; value=&quot;红楼梦&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
        &lt;!--级联赋值--&gt;
        &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dept&quot; class=&quot;com.review.spring5.bean.Dept&quot;&gt;
        &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<h4 id="1-6-4-XML注入集合属性"><a href="#1-6-4-XML注入集合属性" class="headerlink" title="1.6.4 XML注入集合属性"></a>1.6.4 XML注入集合属性</h4><ol>
<li>测试类</li>
</ol>
<pre><code class="java">public class Stu &#123;
    //1 数组类型属性
    private String[] courses;
    //2 list 集合类型属性
    private List&lt;String&gt; list;
    //3 map 集合类型属性
    private Map&lt;String,String&gt; maps;
    //4 set 集合类型属性
    private Set&lt;String&gt; sets;
    public void setSets(Set&lt;String&gt; sets) &#123;
        this.sets = sets;
    &#125;
    public void setCourses(String[] courses) &#123;
        this.courses = courses;
    &#125;
    public void setList(List&lt;String&gt; list) &#123;
        this.list = list;
    &#125;
    public void setMaps(Map&lt;String, String&gt; maps) &#123;
        this.maps = maps;
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>配置文件</li>
</ol>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;stu&quot; class=&quot;com.review.spring5.bean.Stu&quot;&gt;
        &lt;!--数组类型属性注入--&gt;
        &lt;property name=&quot;courses&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;java 课程&lt;/value&gt;
                &lt;value&gt;数据库课程&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list 类型属性注入--&gt;
        &lt;property name=&quot;list&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;张三&lt;/value&gt;
                &lt;value&gt;小三&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map 类型属性注入--&gt;
        &lt;property name=&quot;maps&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set 类型属性注入--&gt;
        &lt;property name=&quot;sets&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;MySQL&lt;/value&gt;
                &lt;value&gt;Redis&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>集合属性中如果存入的值为对象时</li>
</ul>
<pre><code class="xml">&lt;!--创建多个 course 对象--&gt;
    &lt;bean id=&quot;course1&quot; class=&quot;com.review.spring5.bean.Course&quot;&gt;
        &lt;property name=&quot;cname&quot; value=&quot;Spring5 框架&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;course2&quot; class=&quot;com.review.spring5.bean.Course&quot;&gt;
        &lt;property name=&quot;cname&quot; value=&quot;MyBatis 框架&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--注入 list 集合类型，值是对象--&gt;
    &lt;bean id=&quot;stu&quot; class=&quot;com.review.spring5.bean.Stu&quot;&gt;
    &lt;property name=&quot;courseList&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<ul>
<li>把集合注入部分提取出来：在 spring 配置文件中引入名称空间 util</li>
</ul>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;

    &lt;util:list id=&quot;bookList&quot;&gt;
        &lt;value&gt;西游记&lt;/value&gt;
        &lt;value&gt;三国演义&lt;/value&gt;
        &lt;value&gt;水浒传&lt;/value&gt;
    &lt;/util:list&gt;
    &lt;!--2 提取 list 集合类型属性注入使用--&gt;
    &lt;bean id=&quot;book&quot; class=&quot;com.review.spring5.bean.Book&quot;&gt;
        &lt;property name=&quot;bookList&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="1-6-5-Bean管理-FactoryBean"><a href="#1-6-5-Bean管理-FactoryBean" class="headerlink" title="1.6.5 Bean管理(FactoryBean)"></a>1.6.5 Bean管理(FactoryBean)</h4><p>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p>
<ul>
<li><p>普通 bean：在配置文件中定义 bean 类型就是返回类型</p>
<pre><code class="xml">&lt;bean id=&quot;book&quot; class=&quot;com.review.spring5.bean.Book&quot;&gt;
        &lt;property name=&quot;bookList&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
Book book = context.getBean(&quot;book&quot;, Book.class);
</code></pre>
<blockquote>
<p>例如此配置文件中的class属性配置包路径Book，当你实现的时候返回的只能是Book类型，这就是普通bean</p>
</blockquote>
</li>
<li><p>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 </p>
<ul>
<li>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean </li>
<li>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</li>
</ul>
</li>
</ul>
<pre><code class="java">public class MyBean implements FactoryBean&lt;Book&gt; &#123;
    @Override
    public Book getObject() throws Exception &#123;
        Book book = new Book();
        book.setName(&quot;红楼梦&quot;);
        return book;
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        return null;
    &#125;

    @Override
    public boolean isSingleton() &#123;
        return false;
    &#125;
&#125;
</code></pre>
<ul>
<li>配置文件</li>
</ul>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;myBean&quot; class=&quot;com.review.spring5.bean.MyBean&quot;&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>测试类</li>
</ul>
<pre><code class="java">@Test
    public void test05()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean9.xml&quot;);
        //获取配置文件中需要创建的对象
        Book book = context.getBean(&quot;myBean&quot;, Book.class);
        System.out.println(book);
    &#125;
</code></pre>
<blockquote>
<p>虽然class配置的是MyBean但是我获取的是Book</p>
</blockquote>
<h4 id="1-6-6-Bean作用域"><a href="#1-6-6-Bean作用域" class="headerlink" title="1.6.6 Bean作用域"></a>1.6.6 Bean作用域</h4><p>在 Spring 里面，创建 bean 实例有单实例和多实例 </p>
<p>在 Spring 里面，默认情况下，bean 是单实例对象</p>
<p>例如：的到的book1和book2相同，说明是同一个对象</p>
<pre><code class="java">@Test
    public void test05()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        //获取配置文件中需要创建的对象
        Book book1 = context.getBean(&quot;book&quot;, Book.class);
        Book book2 = context.getBean(&quot;book&quot;, Book.class);
        System.out.println(book1==book2);
    &#125;
</code></pre>
<p><strong>设置单实例和多实例</strong> </p>
<ul>
<li>在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 </li>
<li>scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</li>
</ul>
<pre><code class="xml">&lt;!--先配置对象创建，设置多实例--&gt;
    &lt;bean id=&quot;book&quot; class=&quot;com.review.spring5.bean.Book&quot; scope=&quot;prototype&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;红楼梦&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;author&quot; value=&quot;曹雪芹&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">@Test
    public void test05()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean10.xml&quot;);
        //获取配置文件中需要创建的对象
        Book book1 = context.getBean(&quot;book&quot;, Book.class);
        Book book2 = context.getBean(&quot;book&quot;, Book.class);
        System.out.println(book1);
        System.out.println(book2);
        //com.review.spring5.bean.Book@6771beb3
        //com.review.spring5.bean.Book@51399530
    &#125;
</code></pre>
<p><strong>singleton 和 prototype 区别</strong> </p>
<ul>
<li>singleton 单实例，prototype 多实例 </li>
<li>设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 </li>
<li>设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</li>
</ul>
<h4 id="1-6-7-Bean生命周期"><a href="#1-6-7-Bean生命周期" class="headerlink" title="1.6.7 Bean生命周期"></a>1.6.7 Bean生命周期</h4><p>Bean生命周期：从对象创建到对象销毁的过程 </p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造） </li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ol>
<pre><code class="java">public class Order &#123;
    //无参数构造
    public Order() &#123;
        System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;);
    &#125;
    private String oname;
    public void setOname(String oname) &#123;
        this.oname = oname;
        System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;);
    &#125;
    //创建执行的初始化的方法
    public void initMethod() &#123;
        System.out.println(&quot;第三步 执行初始化的方法&quot;);
    &#125;
    //创建执行的销毁的方法
    public void destroyMethod() &#123;
        System.out.println(&quot;第五步 执行销毁的方法&quot;);
    &#125;
&#125;
</code></pre>
<p>设置spring配置文件，需要配置初始化方法<code>init-method</code>，配置销毁属性<code>destroy-method</code></p>
<pre><code class="xml">&lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;order&quot; class=&quot;com.review.spring5.bean.Order&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;
        &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<p>测试</p>
<pre><code class="java">@Test
    public void test06()&#123;
        //加载配置文件
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean11.xml&quot;);
        //获取配置文件中需要创建的对象
        Order order = context.getBean(&quot;order&quot;, Order.class);
        System.out.println(&quot;第四步，获得创建的bean对象&quot;);
        context.close();
    &#125;
</code></pre>
<p><strong>bean 的后置处理器</strong>，bean 生命周期有七步 </p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造） </li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization </li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法） </li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization </li>
<li>bean 可以使用了（对象获取到了） </li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ol>
<p><strong>添加后置处理器效果</strong>：</p>
<p>创建类，实现接口 <strong>BeanPostProcessor</strong>，创建后置处理器</p>
<pre><code class="java">public class MyBeanPost implements BeanPostProcessor &#123;
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;
        System.out.println(&quot;在初始化之前执行的方法&quot;);
        return bean;
    &#125;

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
        System.out.println(&quot;在初始化之后执行的方法&quot;);
        return bean;
    &#125;
&#125;
</code></pre>
<p>配置文件</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--先配置对象创建--&gt;
    &lt;bean id=&quot;order&quot; class=&quot;com.review.spring5.bean.Order&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;
        &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;myBeanPost&quot; class=&quot;com.review.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类</p>
<pre><code class="java">@Test
    public void test06()&#123;
        //加载配置文件
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean11.xml&quot;);
        //获取配置文件中需要创建的对象
        Order order = context.getBean(&quot;order&quot;, Order.class);
        System.out.println(&quot;第四步，获得创建的bean对象&quot;);
        context.close();
    &#125;
结果：
第一步 执行无参数构造创建 bean 实例
第二步 调用 set 方法设置属性值
在初始化之前执行的方法
第三步 执行初始化的方法
在初始化之后执行的方法
第四步，获得创建的bean对象
第五步 执行销毁的方法
</code></pre>
<h3 id="1-7-基于注解方式实现bean管理"><a href="#1-7-基于注解方式实现bean管理" class="headerlink" title="1.7 基于注解方式实现bean管理"></a>1.7 基于注解方式实现bean管理</h3><p>注解格式：@注解名称(属性名称=属性值, 属性名称=属性值..)</p>
<p>注解可以作用在类上面，方法上面，属性上面</p>
<p>使用注解目的：简化 xml 配置 </p>
<p>Spring 针对 Bean 管理中创建对象提供注解 </p>
<ul>
<li>@Component</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Repository </li>
</ul>
<p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p>
<h4 id="1-7-1-基于注解实现对象创建"><a href="#1-7-1-基于注解实现对象创建" class="headerlink" title="1.7.1 基于注解实现对象创建"></a>1.7.1 基于注解实现对象创建</h4><p>步骤：</p>
<p>第一步 引入依赖：<code>spring-aop-5.2.6.RELEASE.jar</code></p>
<p>第二步开启组件扫描，要设置命名空间：<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启组件扫描
    1 如果扫描多个包，多个包使用逗号隔开
    2 扫描包上层目录
    --&gt;
    &lt;context:component-scan base-package=&quot;com.review.spring5&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>第三步创建类，添加注解</p>
<pre><code class="java">//在注解里面 value 属性值可以省略不写，
//四个注解一样，都可以写
//默认值是类名称，首字母小写
//UserService -- userService
@Service
public class UserService &#123;
    public void add()&#123;
        System.out.println(&quot;add......&quot;);
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">@Test
    public void test1()&#123;
        //加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.add();
    &#125;
</code></pre>
<h4 id="1-7-2-组件扫描细节配置"><a href="#1-7-2-组件扫描细节配置" class="headerlink" title="1.7.2 组件扫描细节配置"></a>1.7.2 组件扫描细节配置</h4><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启组件扫描
    1 如果扫描多个包，多个包使用逗号隔开
    2 扫描包上层目录
    --&gt;
    &lt;context:component-scan base-package=&quot;com.review.spring5&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--示例 1
    use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter
    context:include-filter ，设置扫描哪些内容
    --&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;!--只扫描带有controller注解的类--&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
    &lt;!--示例 2
     下面配置扫描包所有内容
     context:exclude-filter： 设置哪些内容不进行扫描
    --&gt;
    &lt;context:component-scan base-package=&quot;com.review&quot;&gt;
        &lt;!--不扫描带有controller注解的类--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="1-7-3-基于注解方式实现属性注入"><a href="#1-7-3-基于注解方式实现属性注入" class="headerlink" title="1.7.3 基于注解方式实现属性注入"></a>1.7.3 基于注解方式实现属性注入</h4><p>@Autowired：根据属性类型进行自动装配</p>
<ul>
<li>把 service 和 dao 对象创建，在 service 和 dao 类<strong>添加创建对象注解</strong></li>
<li>在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在<strong>属性上面使用注解</strong></li>
</ul>
<pre><code class="java">@Repository
public class UserDaoImpl implements UserDao &#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;daoAdd....&quot;);
    &#125;
&#125;
@Service
public class UserService &#123;
    //定义 dao 类型属性
    //不需要添加 set 方法
    //添加注入属性注解
    @Autowired
    private UserDao userDao;
    public void add() &#123;
        System.out.println(&quot;service add.......&quot;);
        userDao.add();
    &#125;
&#125;
</code></pre>
<p>@Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用</p>
<p>如果一个接口有多个实现类，可以使用这个，单独使用@Autowired不清楚使用的是哪个实现类</p>
<pre><code class="java">@Repository
public class UserDaoImpl2 implements UserDao &#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;daoAdd2....&quot;);
    &#125;
&#125;
@Service
public class UserService &#123;
    //定义 dao 类型属性
    //不需要添加 set 方法
    //添加注入属性注解
    @Autowired //根据类型进行注入
    @Qualifier(value = &quot;userDaoImpl2&quot;) //根据名称进行注入，注入userDaoImpl2的不注入userDaoImpl
    private UserDao userDao;
    public void add() &#123;
        System.out.println(&quot;service add.......&quot;);
        userDao.add();
    &#125;
&#125;
</code></pre>
<p>@Resource：可以根据类型注入，可以根据名称注入</p>
<pre><code class="java">//@Resource //根据类型进行注入
@Resource(name = &quot;userDaoImpl2&quot;) //根据名称进行注入
private UserDao userDao;
</code></pre>
<p>以上三个注解都是针对对象类型</p>
<p>@Value：注入普通类型属性</p>
<pre><code class="java">@Value(value = &quot;abc&quot;)
private String name;
</code></pre>
<h3 id="1-8-完全注解开发"><a href="#1-8-完全注解开发" class="headerlink" title="1.8 完全注解开发"></a>1.8 完全注解开发</h3><ol>
<li>创建配置类，替代 xml 配置文件，@Configuration注解表示将当前类设置为配置类，@ComponentScan开启注解扫描</li>
</ol>
<pre><code class="java">@Configuration
@ComponentScan(basePackages = &#123;&quot;com.review&quot;&#125;)
public class SpringConfig &#123;
&#125;
</code></pre>
<ol start="2">
<li>编写测试类，替代了xml文件所以用的<code>AnnotationConfigApplicationContext</code></li>
</ol>
<pre><code class="java"> @Test
    public void testService2() &#123;
        //加载配置类
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService);
        userService.add();
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-05(Hystrix服务熔断，降级)</title>
    <url>/2021/02/14/SpringCloud-05/</url>
    <content><![CDATA[<h1 id="SpringCloud-05"><a href="#SpringCloud-05" class="headerlink" title="SpringCloud-05"></a>SpringCloud-05</h1><h2 id="1、Hystrix断路器"><a href="#1、Hystrix断路器" class="headerlink" title="1、Hystrix断路器"></a>1、Hystrix断路器</h2><p>分布式系统所面临的问题</p>
<ul>
<li>复杂分布式体系结构中的应用程序   有数10个依赖关系,每个依赖关系在某些时候将不可避免地失败</li>
</ul>
<p>服务雪崩</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318153247226.png" alt="image-20210318153247226"></p>
<ul>
<li>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。</li>
<li>如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应‘</li>
<li>对于高流量的应用来说，单一的后端依赖可能会导致所有的服务器上的所有资源都在几秒钟内饱和，比失败更糟糕的是，这些应用程序还可能导致服务之间延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统</li>
<li>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他模块，这样就会发生级联故障，或者叫雪崩</li>
</ul>
<h3 id="1-1-Hystrix概述"><a href="#1-1-Hystrix概述" class="headerlink" title="1.1 Hystrix概述"></a>1.1 Hystrix概述</h3><p><strong>Hystrix是什么</strong></p>
<ul>
<li>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统中，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</strong></li>
<li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，<strong>向调用方法返回一个符合预期的，可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间，不必要的被占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩</li>
</ul>
<p><strong>Hystrix能干什么</strong></p>
<ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>接近实时的监控</li>
</ul>
<p><strong>官网资料：</strong><a href="https://github.com/Netflix/hystrix/wiki">https://github.com/Netflix/hystrix/wiki</a></p>
<p><strong>Hystrix官宣，停更进维，停止更新，进入维护阶段</strong></p>
<h3 id="1-2-Hystrix重要概念"><a href="#1-2-Hystrix重要概念" class="headerlink" title="1.2 Hystrix重要概念"></a>1.2 Hystrix重要概念</h3><h4 id="1-2-1-服务降级（fallback）"><a href="#1-2-1-服务降级（fallback）" class="headerlink" title="1.2.1 服务降级（fallback）"></a>1.2.1 服务降级（fallback）</h4><p>服务器忙，稍后再试，不让客户端等待并立刻返回一个友好提示，fallback</p>
<p>哪些情况下会发生降级</p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
<h4 id="1-2-2-服务熔断（break）"><a href="#1-2-2-服务熔断（break）" class="headerlink" title="1.2.2 服务熔断（break）"></a>1.2.2 服务熔断（break）</h4><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p>
<p>服务的降级-&gt;进而熔断-&gt;恢复调用链路</p>
<h4 id="1-2-3-服务限流（flowlimit）"><a href="#1-2-3-服务限流（flowlimit）" class="headerlink" title="1.2.3 服务限流（flowlimit）"></a>1.2.3 服务限流（flowlimit）</h4><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p>
<h3 id="1-3-Hystrix案例"><a href="#1-3-Hystrix案例" class="headerlink" title="1.3 Hystrix案例"></a>1.3 Hystrix案例</h3><h4 id="1-3-1-建Module"><a href="#1-3-1-建Module" class="headerlink" title="1.3.1 建Module"></a>1.3.1 建Module</h4><p>新建<code>cloud-provider-hystrix-payment8001</code></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318161446529.png" alt="image-20210318161446529"></p>
<h4 id="1-3-2-改POM"><a href="#1-3-2-改POM" class="headerlink" title="1.3.2 改POM"></a>1.3.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;/artifactId&gt;
    &lt;description&gt;服务提供模块hystrix&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;!--hystrix--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--eureka client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="1-3-3-建yml"><a href="#1-3-3-建yml" class="headerlink" title="1.3.3 建yml"></a>1.3.3 建yml</h4><pre><code class="yml">server:
  port: 8001
spring:
  application:
    name: cloud-provider-hystrix-payment
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
</code></pre>
<h4 id="1-3-4-主启动"><a href="#1-3-4-主启动" class="headerlink" title="1.3.4 主启动"></a>1.3.4 主启动</h4><pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    &#125;
&#125;
</code></pre>
<h4 id="1-3-5-业务类"><a href="#1-3-5-业务类" class="headerlink" title="1.3.5 业务类"></a>1.3.5 业务类</h4><p>service</p>
<pre><code class="java">package com.practice.springcloud.service;

import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class PaymentService &#123;
    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_OK,id:&quot; + id + &quot;\t&quot; + &quot;O(∩_∩)O哈哈~&quot;;
    &#125;

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    public String paymentInfo_TimeOut(Integer id) &#123;
        int timeNumber = 3;
        try &#123;
            // 暂停3秒钟
            TimeUnit.SECONDS.sleep(timeNumber);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +
                &quot;O(∩_∩)O哈哈~  耗时(秒)&quot; + timeNumber;
    &#125;
&#125;
</code></pre>
<p>Controller</p>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Slf4j
public class PaymentController &#123;
    @Resource
    private PaymentService paymentService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String servicePort;

    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123;
        String result = paymentService.paymentInfo_OK(id);
        log.info(&quot;*****result:&quot; + result);
        return result;
    &#125;

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info(&quot;*****result:&quot; + result);
        return result;

    &#125;
&#125;
</code></pre>
<h4 id="1-3-6-测试"><a href="#1-3-6-测试" class="headerlink" title="1.3.6 测试"></a>1.3.6 测试</h4><ul>
<li>可以先将Eureka7001和Hystrix8001改成单机版，然后启动这两个模块</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318165209511.png" alt="image-20210318165209511"></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318165303960.png" alt="image-20210318165303960"></p>
<ul>
<li>正常访问<a href="http://localhost:8001/payment/hystrix/ok/31%EF%BC%8C%E6%97%A0%E5%BB%B6%E8%BF%9F">http://localhost:8001/payment/hystrix/ok/31，无延迟</a></li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318165610934.png" alt="image-20210318165610934"></p>
<ul>
<li>每次调用耗费3秒钟的访问<a href="http://localhost:8001/payment/hystrix/timeout/31">http://localhost:8001/payment/hystrix/timeout/31</a></li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210318165707536.png" alt="image-20210318165707536"></p>
<h3 id="1-4-高并发测试"><a href="#1-4-高并发测试" class="headerlink" title="1.4 高并发测试"></a>1.4 高并发测试</h3><p>上述Hystrix案例在非高并发情形下，还能勉强满足</p>
<h4 id="1-4-1-Jmeter压测测试"><a href="#1-4-1-Jmeter压测测试" class="headerlink" title="1.4.1 Jmeter压测测试"></a>1.4.1 Jmeter压测测试</h4><p>JMeter下载安装</p>
<ul>
<li>在<a href="https://jmeter.apache.org/%E4%B8%8B%E8%BD%BDJMeter%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%8F%8C%E5%87%BBbin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84jmeter.bat%E6%96%87%E4%BB%B6%E5%8D%B3%E5%8F%AF%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F">https://jmeter.apache.org/下载JMeter，然后解压到一个文件夹，双击bin目录下的jmeter.bat文件即可启动成功</a></li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319085613644.png" alt="image-20210319085613644"></p>
<ul>
<li>修改JMeter语言为中文</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319090614513.png" alt="image-20210319090614513"></p>
<ul>
<li><p>开启Jmeter，来20000个并发压死8001,20000个请求都去访问paymentInfo_TimeOut服务</p>
<ul>
<li>添加线程组</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319090501669.png" alt="image-20210319090501669"></p>
<ul>
<li>设置线程数200，循环次数100，则有20000，然后Ctrl+s保存</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319091035408.png" alt="image-20210319091035408"></p>
<ul>
<li>发送Http请求，全部发向延迟三秒钟的<code>timeout/31</code>服务</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319091408836.png" alt="image-20210319091408836"></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319091826666.png" alt="image-20210319091826666"></p>
</li>
</ul>
<p>此时测试<a href="http://localhost:8001/payment/hystrix/ok/31%E5%92%8Chttp://localhost:8001/payment/hystrix/timeout/31">http://localhost:8001/payment/hystrix/ok/31和http://localhost:8001/payment/hystrix/timeout/31</a></p>
<ul>
<li>发现两份请求都有延迟响应，由此可见当高并发情况下<code>timeout/31</code>延迟三秒的服务会拖慢<code>hystrix/ok/31</code>正常的服务，因为tomcat默认的工作线程数全都去帮助<code>timeout/31</code>服务，没什么线程去访问正常的<code>hystrix/ok/31</code>服务，没有多余的线程来分解压力和处理</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319092207866.png" alt="image-20210319092207866"></p>
<h4 id="1-4-5-JMeter压测结论"><a href="#1-4-5-JMeter压测结论" class="headerlink" title="1.4.5 JMeter压测结论"></a>1.4.5 JMeter压测结论</h4><ul>
<li>上面还只是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死</li>
</ul>
<h3 id="1-5-80消费端加入"><a href="#1-5-80消费端加入" class="headerlink" title="1.5 80消费端加入"></a>1.5 80消费端加入</h3><h4 id="1-5-1-新建module"><a href="#1-5-1-新建module" class="headerlink" title="1.5.1 新建module"></a>1.5.1 新建module</h4><ul>
<li>cloud-consumer-feign-hystrix-order80</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319094202930.png" alt="image-20210319094202930"></p>
<h4 id="1-5-2-改POM"><a href="#1-5-2-改POM" class="headerlink" title="1.5.2 改POM"></a>1.5.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;/artifactId&gt;
    &lt;description&gt;服务消费模块hystrix&lt;/description&gt;
    
    &lt;dependencies&gt;
        &lt;!--openfeign--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--eureka client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="1-5-3-建yml"><a href="#1-5-3-建yml" class="headerlink" title="1.5.3 建yml"></a>1.5.3 建yml</h4><pre><code class="yml">server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
</code></pre>
<h4 id="1-5-4-主启动类"><a href="#1-5-4-主启动类" class="headerlink" title="1.5.4 主启动类"></a>1.5.4 主启动类</h4><pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class OrderHystrixMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderHystrixMain80.class, args);
    &#125;
&#125;

</code></pre>
<h4 id="1-5-5-业务类"><a href="#1-5-5-业务类" class="headerlink" title="1.5.5 业务类"></a>1.5.5 业务类</h4><ul>
<li>Service</li>
</ul>
<pre><code class="java">package com.practice.springcloud.service;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Component
@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)
public interface PaymentHystrixService &#123;

    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);

&#125;
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.service.PaymentHystrixService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderHystrixController &#123;


    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_OK(id);

        return result;
    &#125;
    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        return result;
    &#125;
&#125;
</code></pre>
<h4 id="1-5-6-正常测试"><a href="#1-5-6-正常测试" class="headerlink" title="1.5.6 正常测试"></a>1.5.6 正常测试</h4><ul>
<li><a href="http://localhost/consumer/payment/hystrix/ok/32">http://localhost/consumer/payment/hystrix/ok/32</a></li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319101127760.png" alt="image-20210319101127760"></p>
<h4 id="1-5-7-高并发测试"><a href="#1-5-7-高并发测试" class="headerlink" title="1.5.7 高并发测试"></a>1.5.7 高并发测试</h4><ul>
<li>启动JMeter，发送Http请求</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319101314758.png" alt="image-20210319101314758"></p>
<ul>
<li>再查看<a href="http://localhost/consumer/payment/hystrix/ok/32">http://localhost/consumer/payment/hystrix/ok/32</a><ul>
<li>要么转圈圈等待，要么消费端报超时错误</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319101449727.png" alt="image-20210319101449727"></p>
<p>故障和导致现象：</p>
<ul>
<li>8001同一层次的其他接口被困死，因为tomcat线程池里面的工作线程已经被挤占完毕，80此时调用8001，客户端访问响应缓慢，转圈圈</li>
</ul>
<p>因此，降级/容错/限流等技术诞生</p>
<h4 id="1-5-8-如何解决高并发"><a href="#1-5-8-如何解决高并发" class="headerlink" title="1.5.8 如何解决高并发"></a>1.5.8 如何解决高并发</h4><p>超时导致服务器变慢(转圈)</p>
<ul>
<li>超时不再等待</li>
</ul>
<p>出错(宕机或程序运行出错)</p>
<ul>
<li>出错要有兜底</li>
</ul>
<p>解决：</p>
<ul>
<li><p><strong>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级</strong></p>
</li>
<li><p><strong>对方服务(8001)宕机了，调用者(80)不能一直卡死等待，必须有服务降级</strong></p>
</li>
<li><p><strong>对方服务(8001)ok，调用者(80)自己有故障或有自我要求(自己等待时间小于服务提供者)</strong></p>
</li>
</ul>
<h2 id="2、服务降级（fallback）"><a href="#2、服务降级（fallback）" class="headerlink" title="2、服务降级（fallback）"></a>2、服务降级（fallback）</h2><p>fallback服务降级，既可以放在消费端80，也可以放在支付端8001，但是我们一般放在消费端80</p>
<p>降级配置</p>
<ul>
<li><code>@HystrixCommand</code>注解</li>
</ul>
<p>8001先从自身找问题</p>
<ul>
<li>设置自身调用超时时间的峰值，峰值时间内可以正常运行，超过了需要有兜底的方法处理，做服务降级fallback</li>
</ul>
<h3 id="2-1-8001-fallback"><a href="#2-1-8001-fallback" class="headerlink" title="2.1 8001 fallback"></a>2.1 8001 fallback</h3><p>业务类启用 @HystrixCommand 注解(在8001的Service)</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319105744458.png" alt="image-20210319105744458"></p>
<p>一旦调用服务方法失败并抛出了错误信息后，会自动的调用@HystrixCommand标注好的fallbackMethod调用类中指定方法</p>
<pre><code class="java">package com.practice.springcloud.service;

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class PaymentService &#123;
    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_OK,id:&quot; + id + &quot;\t&quot; + &quot;O(∩_∩)O哈哈~&quot;;
    &#125;

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    @HystrixCommand(fallbackMethod = &quot;payment_TimeOutHandler&quot;, commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;)
    &#125;)
    public String paymentInfo_TimeOut(Integer id) &#123;
        int timeNumber = 3;
        try &#123;
            // 暂停3秒钟
            TimeUnit.SECONDS.sleep(timeNumber);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +
                &quot;O(∩_∩)O哈哈~  耗时(秒)&quot; + timeNumber;
    &#125;

    public String payment_TimeOutHandler(Integer id) &#123;

        return &quot;/(ToT)/调用支付接口超时或异常：\t&quot;+&quot;\t当前线程池名字&quot;+Thread.currentThread().getName();
    &#125;

&#125;
</code></pre>
<ul>
<li>主启动类激活@EnableCircuitBreaker</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319105921154.png" alt="image-20210319105921154"></p>
<ul>
<li>测试，因为8001，会等待5秒，所以会走payment_TimeOutHandler方法</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319110247721.png" alt="image-20210319110247721"></p>
<p>当出现异常时，也会服务降级，所以，不管是超时，还是运行报错，都会执行payment_TimeOutHandler方法</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319131103041.png" alt="image-20210319131103041"></p>
<h3 id="2-2-80-fallback"><a href="#2-2-80-fallback" class="headerlink" title="2.2 80 fallback"></a>2.2 80 fallback</h3><ul>
<li><p>80订单微服务，也可以更好的保护自己，当请求8001迟迟没有回应，也对自己进行客户端降级保护</p>
</li>
<li><p>注意：若配置了热部署方法对java代码改动会自动重启，但对@HystrixCommand内 属性的修改修改，建议手动重启微服务</p>
</li>
<li><p>改POM</p>
</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319134056775.png" alt="image-20210319134056775"></p>
<pre><code class="xml">&lt;!--hystrix--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<ul>
<li>修改YML</li>
</ul>
<pre><code class="yml">server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka #单机版
#      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
feign:
  hystrix:
    enabled: true
</code></pre>
<ul>
<li>主启动类上加上@EnableHystrix注解</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319133719121.png" alt="image-20210319133719121"></p>
<ul>
<li>业务类，controller</li>
</ul>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.service.PaymentHystrixService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;

import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderHystrixController &#123;


    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_OK(id);

        return result;
    &#125;


    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)
    &#125;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;
        //int age = 10/0;
        return paymentHystrixService.paymentInfo_TimeOut(id);
    &#125;

    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return &quot;我是消费者80,对方支付系统繁忙请10秒种后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;;
    &#125;
&#125;
</code></pre>
<ul>
<li>测试，消费端，访问8001服务支付端，此时8001延迟3秒响应，80设置只等1.5秒</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319134608424.png" alt="image-20210319134608424"></p>
<ul>
<li>此时发现，8001设置延迟两秒响应，80设置等待三秒，也会服务降级，因为ribbon默认时间为1秒，所以需要在配置文件中设置ribbon，还要将feign.hystrix.enabled=false</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319140737400.png" alt="image-20210319140737400"></p>
<ul>
<li>此时测试通过</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319140645252.png" alt="image-20210319140645252"></p>
<p>此时，每个业务方法对应一个兜底的方法，代码膨胀</p>
<p><strong>统一和自定义的分开</strong></p>
<ul>
<li>每个方法都有一个兜底的方法，这样不方便，需要设置一个全局的兜底的方法，这个兜底的方法涵盖大部分的方法，只有小部分的方法需要自定义兜底的方法</li>
</ul>
<h3 id="2-3-解决代码膨胀问题"><a href="#2-3-解决代码膨胀问题" class="headerlink" title="2.3 解决代码膨胀问题"></a>2.3 解决代码膨胀问题</h3><p>@DefaultProperties(defaultFallback=””)</p>
<ul>
<li>1对1，每个方法都配置一个服务降级方法，技术上可以，实际很傻</li>
<li>1对N，除了个别核心业务有专属服务降级方法，其他的普通的可以通过@DefaultProperties(defaultFallback=””)统一跳转到统一结果处理页面</li>
<li>通用的和独享的分开，避免了代码膨胀，合理减少了代码量。</li>
</ul>
<p>修改controller</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319143733213.png" alt="image-20210319143733213"></p>
<pre><code class="java">package com.practice.springcloud.controller;
import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
import com.practice.springcloud.service.PaymentHystrixService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;

import javax.annotation.Resource;

@RestController
@Slf4j
@DefaultProperties(defaultFallback=&quot;payment_Global_FallbackMethod&quot;)
public class OrderHystrixController &#123;

    @Resource
    private PaymentHystrixService paymentHystrixService;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_OK(id);

        return result;
    &#125;

    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
//    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;
//            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;)
//    &#125;)
    @HystrixCommand
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;
        int age = 10/0;
        return paymentHystrixService.paymentInfo_TimeOut(id);
    &#125;

    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return &quot;我是消费者80,对方支付系统繁忙请10秒种后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;;
    &#125;

    //下面是全局fallback
    public String payment_Global_FallbackMethod()&#123;
        return &quot;Global异常处理信息，请稍后再试&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="2-4-解决代码耦合度高的问题"><a href="#2-4-解决代码耦合度高的问题" class="headerlink" title="2.4 解决代码耦合度高的问题"></a>2.4 解决代码耦合度高的问题</h3><p>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</p>
<p>本次案例服务降级处理是<strong>在客户端80</strong>实现完成，与服务端8001没有任何关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</p>
<p>未来我们要面对的异常：运行、超时、宕机</p>
<p>再看看我们的业务类OrderHystrixController，混合在一起，每一个业务方法都要提供一个</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319144653251.png" alt="image-20210319144653251"></p>
<p>修改<code>cloud-consumer-feign-hystrix-order80</code></p>
<p>根据<code>cloud-consumer-feign-hystrix-order80</code>已经有的<code>PaymentHystrixService</code>接口，重新新建一个类(<code>PaymentFallbackService</code>)实现接口，统一为接口里面的方法进行异常处理</p>
<pre><code class="java">package com.practice.springcloud.service;


public class PaymentFallbackService implements PaymentHystrixService &#123;
    @Override
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;-----PaymentFallbackService fall back paymentInfo_OK o(╥﹏╥)o&quot;;
    &#125;

    @Override
    public String paymentInfo_TimeOut(Integer id) &#123;
        return &quot;-----PaymentFallbackService fall back paymentInfo_TimeOut o(╥﹏╥)o&quot;;
    &#125;
&#125;
</code></pre>
<p>修改YML</p>
<pre><code class="yml">feign:
  hystrix:
    enabled: true #在Feign中开启Hystrix
</code></pre>
<p>将<code>PaymentFallbackService</code>类配到<code>PaymentHystrixService</code>接口中</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319145913139.png" alt="image-20210319145913139">测试：</p>
<p>启动7001,8001,80，此时正常访问<a href="http://localhost/consumer/payment/hystrix/ok/32%EF%BC%8C%E5%BD%93%E5%85%B3%E9%97%AD8001%E6%A8%A1%E6%8B%9F%E5%AE%95%E6%9C%BA%E6%97%B6%EF%BC%8C%E8%B5%B7%E5%88%B0%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E4%BD%9C%E7%94%A8">http://localhost/consumer/payment/hystrix/ok/32，当关闭8001模拟宕机时，起到服务降级作用</a></p>
<p>此时服务器provider已经down，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319150325579.png" alt="image-20210319150325579"></p>
<h2 id="3、服务熔断"><a href="#3、服务熔断" class="headerlink" title="3、服务熔断"></a>3、服务熔断</h2><p>断路器：相当于保险丝</p>
<h3 id="3-1-熔断是什么"><a href="#3-1-熔断是什么" class="headerlink" title="3.1 熔断是什么"></a>3.1 熔断是什么</h3><p>熔断机制概述：</p>
<ul>
<li>熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误信息</li>
<li><strong>当检测到该节点微服务调用响应正常后，恢复调用链路</strong></li>
<li>在Spring Cloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制注解是@HystrixCommand</li>
</ul>
<h3 id="3-2-实际操作"><a href="#3-2-实际操作" class="headerlink" title="3.2 实际操作"></a>3.2 实际操作</h3><p>修改<code>cloud-provider-hystrix-payment8001</code></p>
<p>PaymentService</p>
<pre><code class="java">package com.practice.springcloud.service;

import cn.hutool.core.util.IdUtil;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.concurrent.TimeUnit;

@Service
public class PaymentService &#123;
    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_OK,id:&quot; + id + &quot;\t&quot; + &quot;O(∩_∩)O哈哈~&quot;;
    &#125;

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    @HystrixCommand(fallbackMethod = &quot;payment_TimeOutHandler&quot;, commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;5000&quot;)
    &#125;)
    public String paymentInfo_TimeOut(Integer id) &#123;
//        int a = 10/0;
        int timeNumber = 5000;
        try &#123;
            // 暂停5秒钟
            TimeUnit.MILLISECONDS.sleep(timeNumber);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +
                &quot;O(∩_∩)O哈哈~  耗时(秒)&quot; + timeNumber;
    &#125;

    public String payment_TimeOutHandler(Integer id) &#123;

        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; 系统繁忙或者运行报错，稍后再试,id:&quot; + id + &quot;\t&quot; +&quot;o(╥﹏╥)o&quot;;
    &#125;


    //====服务熔断

    @HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;
            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),//是否开启断路器
            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),//请求次数
            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),//时间窗口期
            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少跳闸
    &#125;)
    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123;
        if (id&lt;0)&#123;
            throw new RuntimeException(&quot;****id不能为负数&quot;);
        &#125;

        String serialNumber = IdUtil.simpleUUID();
        return Thread.currentThread().getName()+&quot;\t&quot;+&quot;调用成功，流水号：&quot;+serialNumber;
    &#125;

    public  String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return &quot;id 不能负数，请稍后再试，/(ToT)/~~ id: &quot;+id;
    &#125;
&#125;
</code></pre>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319155435378.png" alt="image-20210319155435378"></p>
<p>PaymentController</p>
<pre><code class="java">package com.practice.springcloud.controller;

import com.practice.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Slf4j
public class PaymentController &#123;
    @Resource
    private PaymentService paymentService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String servicePort;

    /**
     * 正常访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123;
        String result = paymentService.paymentInfo_OK(id);
        log.info(&quot;*****result:&quot; + result);
        return result;
    &#125;

    /**
     * 超时访问
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info(&quot;*****result:&quot; + result);
        return result;
    &#125;

    @GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)
    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentService.paymentCircuitBreaker(id);
        log.info(&quot;result: &quot;+result);
        return result;
    &#125; 
    
&#125;
</code></pre>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319155744719.png" alt="image-20210319155744719"></p>
<p>测试：启动7001和8001</p>
<p>输入正数，返回成功</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319161021277.png" alt="image-20210319161021277"></p>
<p>输入负数，返回失败</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319161052968.png" alt="image-20210319161052968"></p>
<p>测试：当多次请求负数，8001会启动熔断机制，此时再输入正确数字也不会访问成功，当多次访问正确数字，会恢复调用链路，此时会出现成功页面</p>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>熔断的论文：<a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319161956403.png" alt="image-20210319161956403"></p>
<p><strong>熔断类型：</strong></p>
<ul>
<li>熔断打开：请求不再调用当前服务，内部设置一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态</li>
<li>熔断关闭：熔断关闭后不会对服务进行熔断</li>
<li>熔断半开：部分请求根据规则调用当前服务器，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</li>
</ul>
<p><strong>断路器在什么情况下起作用</strong></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319162442538.png" alt="image-20210319162442538"></p>
<p>涉及到断路器的三个重要参数：快照时间窗，请求总数阈值，错误百分比阈值</p>
<ol>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒</li>
<li>请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，意味着在10秒内，如果该Hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开</li>
<li>错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%错误比百分，在默认设定50%阈值情况下，这时候就会将断路器打开</li>
</ol>
<p><strong>断路器开启或关闭条件</strong></p>
<ul>
<li>当满足一定的阈值的时候(默认10秒钟超过20个请求次数)</li>
<li>当失败率达到一定的时候(默认10秒内超过50%的请求次数)</li>
<li>到达以上阈值,断路器将会开启</li>
<li>当开启的时候,所有请求都不会进行转发</li>
<li>一段时间之后(默认5秒),这个时候断路器是半开状态,会让其中一个请求进行转发. 如果成功,断路器会关闭,若失败,继续开启.重复4和5</li>
</ul>
<p><strong>断路器打开之后：</strong></p>
<ul>
<li>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback，通过断路器，实现了自动的发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果</li>
</ul>
<p>原来的主逻辑要如何恢复呢？</p>
<ul>
<li>对于这一问题，Hystrix也为我们实现了自动恢复功能。</li>
<li>当断路器打开，对主逻辑进行熔断之后，Hystrix会启动一个休眠时间窗，这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器将继续进入打开状态，休眠时间窗重新计时</li>
</ul>
<h2 id="4、ALI配置"><a href="#4、ALI配置" class="headerlink" title="4、ALI配置"></a>4、ALI配置</h2><pre><code class="java">@HystrixCommand(fallbackMethod = &quot;str_fallbackMethod&quot;,
            groupKey = &quot;strGroupCommand&quot;,
            commandKey = &quot;strCommand&quot;,
            threadPoolKey = &quot;strThreadPool&quot;,

            commandProperties = &#123;
                    //设置隔离策略，THREAD，表示线程池 SEMAPHORE：信号池隔离
                    @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;),
                    //当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）
                    @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),
                    //配置命令执行的超时时间
                    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;10&quot;),
                    //是否启用超时时间
                    @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;),
                    //执行超时的时候是否中断
                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;),
                    //执行被取消的时候是否中断
                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnFutureCancel&quot;, value = &quot;true&quot;),
                    //允许回调方法执行的最大并发数
                    @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),
                    //服务降级是否启用，是否执行回调函数
                    @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;),
                    //是否启用断路器
                    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),
                    //该属性用来设置在滚动时间窗中，断路器熔断的最小请求数，例如，默认该值是20的时候，如果滚动时间窗(默认10秒)
                    //内仅收到19个请求，即使这十九个请求都失败了，断路器也不会打开
                    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),
                    //该属性用来设置在滚动时间窗中，表示滚动时间窗中，在请求数量超过circuitBreaker.requestVolumeThreshold
                    //的情况下，如果错误请求数的百分比超过50，就把断路器设置为“打开”状态，否则设置为“关闭”状态
                    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),
                    //该属性用来设置当断路器打开之后的休眠时间窗，休眠时间窗结束后，会将断路器设置为&quot;半开&quot;状态
                    //尝试熔断的请求命令，如果依然失败就将断路器继续设置为“打开”状态，如果成功设置为“关闭”状态
                    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;5000&quot;),
                    //断路器强制打开
                    @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;),
                    //断路器强制关闭
                    @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;),
                    //滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间
                    @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;10000&quot;),
                    //该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候
                    // 会根据设置的时间窗长度拆分成多个“桶”来累计各度量值，每个“桶”记录了一段时间内的采集指标。比如
                    //10秒内拆分成10个“桶”收集这样，所以timeInMilliseconds必须能被numBuckets整除，否则会抛异常
                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;),
                    //该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算，如果设置为false，那么所有的概要统计
                    //都将返回-1
                    @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;),
                    //该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒
                    @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;),
                    //该属性用来设置百分位统计的滚动窗口中使用“桶”的数量
                    @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;),
                    //该属性用来设置在执行过程中每个“桶”中保留的最大执行次数，如果在滚动时间窗内发生超过该设定值的执行次数
                    //就从最初的位置开始重写，例如，将该值设为100，滚动窗口为10秒，若在10秒内一个“桶”中发生了500次执行，
                    //那么该“桶”中只保留了最后的100次执行的统计。另外增加该值的大小会增加内存量的消耗，并增加排序百分位数所需的计算时间
                    @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;),
                    //该属性用来设置采集影响断路器状态的健康快照(请求1成功，错误百分比)的间隔等待时间
                    @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalInMilliseconds&quot;, value = &quot;500&quot;),
                    //是否开启请求缓存
                    @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;),
                    //HystrixCommand的执行和时间是否打印日志到HystrixRequestLog中
                    @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;),
            &#125;,
            threadPoolProperties = &#123;
                    //该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量
                    @HystrixProperty(name = &quot;coreSize&quot;,value = &quot;10&quot;),
                    //该参数用来设置线程池的最大队列大小，当设置为-1是，线程池将使用SynchronousQueue实现的队列
                    //否则将使用LinkedBlockingQueue实现的队列
                    @HystrixProperty(name = &quot;maxQueueSize&quot;,value = &quot;-1&quot;),
                    //该参数用来为队列设置拒绝阈值，通过该参数，即使队列没有达到最大值也能拒绝请求，
                    //该参数主要是对LinkedBlockingQueue队列的补充，因为LinkedBlockingQueue队列
                    //不能动态的修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了
                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;,value = &quot;5&quot;),
    &#125;)
    public String  strConsumer()&#123;
        return &quot;cloud 2020&quot;;
    &#125;
</code></pre>
<h2 id="5、服务限流"><a href="#5、服务限流" class="headerlink" title="5、服务限流"></a>5、服务限流</h2><ul>
<li>在alibaba的Sentinel中说明</li>
</ul>
<h2 id="6、Hystrix工作流程"><a href="#6、Hystrix工作流程" class="headerlink" title="6、Hystrix工作流程"></a>6、Hystrix工作流程</h2><p>文档：<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p>
<p>官网图例：</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319183804145.png" alt="image-20210319183804145"></p>
<p>步骤说明：</p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319184703159.png" alt="image-20210319184703159"></p>
<h2 id="7、服务监控hystrixDashboard"><a href="#7、服务监控hystrixDashboard" class="headerlink" title="7、服务监控hystrixDashboard"></a>7、服务监控hystrixDashboard</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p>除了隔离依赖服务的调用以外，Hystrix还提供了**准实时的调用监控(Hystrix Dashboard)**，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等，Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面</p>
<h3 id="7-2-仪表盘9001"><a href="#7-2-仪表盘9001" class="headerlink" title="7.2 仪表盘9001"></a>7.2 仪表盘9001</h3><h4 id="7-2-1-建Module"><a href="#7-2-1-建Module" class="headerlink" title="7.2.1 建Module"></a>7.2.1 建Module</h4><ul>
<li>新建<code>cloud-consumer-hystrix-dashboard9001</code></li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319194926935.png" alt="image-20210319194926935"></p>
<h4 id="7-2-2-改POM"><a href="#7-2-2-改POM" class="headerlink" title="7.2.2 改POM"></a>7.2.2 改POM</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.practice.springcloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt;


    &lt;dependencies&gt;
        &lt;!--hystrix dashboard--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h4 id="7-2-3-改YML"><a href="#7-2-3-改YML" class="headerlink" title="7.2.3 改YML"></a>7.2.3 改YML</h4><pre><code class="yml">server:
  port: 9001
</code></pre>
<h4 id="7-2-4-主启动类"><a href="#7-2-4-主启动类" class="headerlink" title="7.2.4 主启动类"></a>7.2.4 主启动类</h4><ul>
<li>加@EnableHystrixDashboard注解</li>
</ul>
<pre><code class="java">package com.practice.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

@SpringBootApplication
@EnableHystrixDashboard
public class HystrixDashboardMain9001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HystrixDashboardMain9001.class);
    &#125;
&#125;
</code></pre>
<h4 id="7-2-5-监控依赖配置"><a href="#7-2-5-监控依赖配置" class="headerlink" title="7.2.5 监控依赖配置"></a>7.2.5 监控依赖配置</h4><p>所有的Provider微服务提供类(8001/8002/8003)都需要监控依赖配置</p>
<pre><code class="xml">&lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h4 id="7-2-6-测试"><a href="#7-2-6-测试" class="headerlink" title="7.2.6 测试"></a>7.2.6 测试</h4><ul>
<li>启动9001</li>
<li><a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></li>
<li>后序将会监控其他服务</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319200044743.png" alt="image-20210319200044743"></p>
<h3 id="7-3-断路器演示"><a href="#7-3-断路器演示" class="headerlink" title="7.3 断路器演示"></a>7.3 断路器演示</h3><p><strong>9001来监控8001</strong></p>
<ul>
<li><p>修改<code>cloud-provider-hystrix-payment8001</code></p>
</li>
<li><p>新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径</p>
</li>
</ul>
<pre><code class="java">package com.practice.springcloud;

import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableEurekaClient
@EnableCircuitBreaker
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    &#125;

    /**
     * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑
     * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream
     * 只要在自己的项目中配置上下面的servlet即可
     * @return
     */
    @Bean
    public ServletRegistrationBean getServlet()&#123;
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    &#125;
&#125;
</code></pre>
<ul>
<li>启动一个Eureka或者三个Eureka集群均可</li>
</ul>
<p>9001监控8001，填写监控地址</p>
<p><a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319201105574.png" alt="image-20210319201105574"></p>
<p>此时启动8001，测试两个地址</p>
<p><a href="http://localhost:8001/payment/circuit/31">http://localhost:8001/payment/circuit/31</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319201356050.png" alt="image-20210319201356050"></p>
<p><a href="http://localhost:8001/payment/circuit/-31">http://localhost:8001/payment/circuit/-31</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319201342494.png" alt="image-20210319201342494"></p>
<p>说明8001自测没问题</p>
<p>连续点击正确地址<a href="http://localhost:8001/payment/circuit/31%EF%BC%8C%E6%9F%A5%E7%9C%8BHystrix%E7%9B%91%E6%8E%A7">http://localhost:8001/payment/circuit/31，查看Hystrix监控</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319201630672.png" alt="image-20210319201630672"></p>
<p>连续点击错误地址<a href="http://localhost:8001/payment/circuit/-31%EF%BC%8C%E6%9F%A5%E7%9C%8BHystrix%E7%9B%91%E6%8E%A7%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%96%AD%E8%B7%AF%E5%99%A8%E5%B7%B2%E7%BB%8F%E6%89%93%E5%BC%80">http://localhost:8001/payment/circuit/-31，查看Hystrix监控，发现断路器已经打开</a></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319201810515.png" alt="image-20210319201810515"></p>
<p>监控如何看</p>
<ul>
<li>七色</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319202309294.png" alt="image-20210319202309294"></p>
<ul>
<li>1圈</li>
</ul>
<p>实心圆：共有两种含义，它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</p>
<p>该实心圆除了颜色的变化外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆越大，所以通过该实心圆的展示，就可以在大量的实例中快速的发现<strong>故障实例和高压力实例</strong>。</p>
<ul>
<li>1线</li>
</ul>
<p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势</p>
<ul>
<li>整图说明</li>
</ul>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319203106441.png" alt="image-20210319203106441"></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319203138698.png" alt="image-20210319203138698"></p>
<p><img src="/2021/02/14/SpringCloud-05/image-20210319203210884.png" alt="image-20210319203210884"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
